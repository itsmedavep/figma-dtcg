<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DTCG Import/Export</title>
  <style>/* src/app/ui.css */
:root {
  --bg: #040511;
  --bg-gradient:
    radial-gradient(
      120% 140% at 20% 15%,
      #1d2144 0%,
      #080919 55%,
      #020205 100%);
  --surface: rgba(16, 20, 39, 0.9);
  --surface-elevated: rgba(24, 29, 58, 0.95);
  --surface-muted: rgba(255, 255, 255, 0.03);
  --ink: #ffffff;
  --ink-subtle: #f3f5ff;
  --ink-muted: #dfe4ff;
  --accent: #fe8ac9;
  --accent-secondary: #9c8aff;
  --accent-ink: #160919;
  --border: rgba(255, 255, 255, 0.14);
  --border-strong: rgba(255, 255, 255, 0.24);
  --glow-pink: 0 0 18px rgba(254, 138, 201, 0.35);
  --glow-indigo: 0 0 18px rgba(156, 138, 255, 0.3);
  --log-surface: rgba(5, 6, 16, 0.92);
  --drawer-h: 260px;
  --drawer-collapsed-h: 2rem;
}
[data-theme=light] {
  --bg: #f5f5f7;
  --bg-gradient:
    radial-gradient(
      120% 140% at 20% 15%,
      #ffffff 0%,
      #f0f2f5 55%,
      #e1e4e8 100%);
  --surface: rgba(255, 255, 255, 0.85);
  --surface-elevated: rgba(255, 255, 255, 0.95);
  --surface-muted: rgba(0, 0, 0, 0.03);
  --ink: #1a1a1a;
  --ink-subtle: #4a4a4a;
  --ink-muted: #6a6a6a;
  --accent: #d02c85;
  --accent-secondary: #6344e8;
  --accent-ink: #ffffff;
  --border: rgba(0, 0, 0, 0.1);
  --border-strong: rgba(0, 0, 0, 0.2);
  --glow-pink: 0 2px 8px rgba(208, 44, 133, 0.25);
  --glow-indigo: 0 2px 8px rgba(99, 68, 232, 0.2);
  --log-surface: rgba(255, 255, 255, 0.9);
}
html,
body {
  height: 100%;
  margin: 0;
}
body {
  background: var(--bg-gradient);
  background-color: var(--bg);
  color: var(--ink);
  font-family:
    "Inter",
    "SF Pro Display",
    ui-sans-serif,
    system-ui,
    -apple-system,
    Segoe UI,
    Roboto,
    Arial,
    sans-serif;
  line-height: 1.4;
  -webkit-font-smoothing: antialiased;
}
.shell {
  height: 100vh;
  width: 100%;
  display: grid;
  grid-template-columns: minmax(0, 1fr) minmax(0, 1.2fr) minmax(0, 1fr);
  grid-template-rows: 1fr var(--drawer-h);
  gap: 16px;
  padding: 18px;
  box-sizing: border-box;
  grid-auto-flow: row;
  backdrop-filter: blur(22px);
  background: rgba(3, 4, 12, 0.35);
}
.shell.drawer-collapsed {
  grid-template-rows: 1fr var(--drawer-collapsed-h);
}
.shell.drawer-collapsed .drawer .drawer-body {
  display: none;
}
.drawer-toggle {
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 999px;
  background: var(--surface);
  color: var(--ink);
  font-size: 12px;
  cursor: pointer;
  transition: background 180ms ease, box-shadow 180ms ease;
  box-shadow: var(--glow-indigo);
}
.drawer-toggle:hover {
  background: rgba(255, 255, 255, 0.06);
}
.col {
  display: flex;
  flex-direction: column;
  min-width: 0;
  min-height: 0;
}
.panel {
  display: flex;
  flex-direction: column;
  min-width: 0;
  min-height: 0;
  flex: 1;
  border: 1px solid var(--border);
  background: var(--surface);
  border-radius: 18px;
  padding: .75rem;
  overflow: hidden;
  box-shadow: 0 30px 60px rgba(2, 2, 8, 0.55), var(--glow-indigo);
}
.panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 10px 14px 8px 14px;
  border-bottom: 1px solid var(--border);
}
.eyebrow {
  font-size: 11px;
  letter-spacing: .18em;
  text-transform: uppercase;
  color: var(--ink-muted);
  margin: 0 0 2px 0;
}
.title {
  font-size: 18px;
  font-weight: 700;
  margin: 0;
  display: inline-flex;
  align-items: center;
  gap: 10px;
  background:
    linear-gradient(
      120deg,
      var(--accent),
      var(--accent-secondary));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
}
.title::before {
  content: "";
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background:
    linear-gradient(
      120deg,
      var(--accent),
      var(--accent-secondary));
  box-shadow: 0 0 12px rgba(254, 138, 201, 0.7);
  flex-shrink: 0;
}
.panel-body {
  padding: .5rem;
  display: flex;
  flex-direction: column;
  gap: 14px;
  min-width: 0;
  min-height: 0;
  flex: 1;
  overflow: auto;
  max-height: 100%;
}
.row {
  display: flex;
  gap: 12px;
  align-items: center;
}
.row > * {
  flex: 1;
  min-width: 0;
}
label {
  font-size: 12px;
  color: var(--ink-subtle);
  display: block;
  margin-bottom: 4px;
  letter-spacing: .04em;
}
label:has(input[type=checkbox]),
label:has(input[type=radio]) {
  display: flex;
  align-items: center;
  gap: .35rem;
}
input[type=text],
input[type=password],
select,
input[type=file],
textarea {
  width: 100%;
  padding: 10px 12px;
  border: 1px solid var(--border);
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.04);
  color: var(--ink);
  font-size: 13px;
  box-sizing: border-box;
  transition: border-color 150ms ease, box-shadow 150ms ease;
  backdrop-filter: blur(6px);
}
input[type=file] {
  padding: 10px;
  color: var(--ink-muted);
}
input[type=file]::-webkit-file-upload-button,
input[type=file]::file-selector-button {
  padding: 8px 14px;
  border: none;
  border-radius: 999px;
  font-size: 12px;
  font-weight: 600;
  color: var(--accent-ink);
  background:
    linear-gradient(
      125deg,
      var(--accent),
      var(--accent-secondary));
  cursor: pointer;
  margin-right: 12px;
  transition: transform 150ms ease, box-shadow 150ms ease;
  box-shadow: var(--glow-pink);
}
input[type=file]::-webkit-file-upload-button:hover,
input[type=file]::file-selector-button:hover {
  transform: translateY(-1px);
  box-shadow: 0 14px 30px rgba(254, 138, 201, 0.35);
}
input[type=checkbox],
input[type=radio] {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 4px;
  border: 2px solid var(--accent-secondary);
  background: var(--log-surface);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition:
    border-color 140ms ease,
    box-shadow 140ms ease,
    background 140ms ease;
  position: relative;
  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.45);
}
input[type=radio] {
  border-radius: 50%;
}
input[type=checkbox]::after,
input[type=radio]::after {
  content: "";
  position: absolute;
  top: 50%;
  left: 50%;
  transition: transform 140ms ease;
  transform: translate(-50%, -50%) scale(0);
}
input[type=checkbox]::after {
  width: 6px;
  height: 10px;
  border-right: 2px solid #000;
  border-bottom: 2px solid #000;
  transform-origin: center;
  transform: translate(-50%, -60%) rotate(45deg) scale(0);
}
input[type=radio]::after {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #000;
  transform-origin: center;
}
input[type=checkbox]:checked,
input[type=radio]:checked {
  border-color: transparent;
  background:
    linear-gradient(
      125deg,
      var(--accent),
      var(--accent-secondary));
  box-shadow: var(--glow-pink);
}
input[type=radio]:checked {
  border: 2px solid var(--accent-secondary);
  background: var(--log-surface);
  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.45);
}
input[type=checkbox]:checked::after {
  transform: translate(-50%, -60%) rotate(45deg) scale(1);
}
[data-theme=light] input[type=checkbox]::after {
  border-color: #fff;
}
input[type=radio]:checked::after {
  background:
    linear-gradient(
      125deg,
      var(--accent),
      var(--accent-secondary));
  transform: translate(-50%, -50%) scale(1);
}
input[type=checkbox]:focus-visible,
input[type=radio]:focus-visible {
  outline: 2px solid rgba(255, 255, 255, 0.4);
  outline-offset: 2px;
}
input[type=text]::placeholder,
input[type=password]::placeholder,
textarea::placeholder {
  color: var(--ink-muted);
}
input[type=text]:focus,
input[type=password]:focus,
select:focus,
input[type=file]:focus,
textarea:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 1px rgba(254, 138, 201, 0.4);
}
select {
  background-color: rgba(255, 255, 255, 0.04);
  color: var(--ink);
}
.gh-folder-display {
  width: 100%;
  padding: 10px 12px;
  border: 1px dashed var(--border);
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.04);
  color: var(--ink);
  font-size: 12px;
  min-height: 40px;
  display: flex;
  align-items: center;
  box-sizing: border-box;
}
.gh-folder-display.is-placeholder {
  color: var(--ink-muted);
  font-style: italic;
}
.gh-input-error {
  color: #b91c1c;
  font-size: 11px;
  margin-top: 4px;
}
button {
  padding: 11px 18px;
  border: none;
  border-radius: 999px;
  color: var(--accent-ink);
  font-weight: 600;
  cursor: pointer;
  font-size: 14px;
  background:
    linear-gradient(
      125deg,
      var(--accent),
      var(--accent-secondary));
  box-shadow: var(--glow-pink);
  transition: transform 150ms ease, box-shadow 150ms ease;
}
button:hover:not([disabled]) {
  transform: translateY(-1px);
  box-shadow: 0 14px 30px rgba(254, 138, 201, 0.35);
}
button[disabled] {
  opacity: .4;
  cursor: not-allowed;
  box-shadow: none;
}
.css-button-neumorphic {
  min-width: 130px;
  height: 44px;
  padding: 0 20px;
  font-weight: 500;
  border: 1px solid rgba(255, 255, 255, 0.18);
  background:
    linear-gradient(
      160deg,
      rgba(255, 255, 255, 0.08),
      rgba(8, 9, 18, 0.9));
  color: var(--ink);
  border-radius: 999px;
  box-shadow:
    inset 0 1px 3px rgba(255, 255, 255, 0.15),
    inset 0 -4px 8px rgba(3, 4, 12, 0.9),
    var(--glow-indigo);
}
.css-button-neumorphic:active {
  box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.6), inset 0 6px 12px rgba(255, 255, 255, 0.05);
}
[data-theme=light] #importBtn,
[data-theme=light] #exportBtn,
[data-theme=light] #exportTypographyBtn,
[data-theme=light] #ghConnectBtn,
[data-theme=light] #ghLogoutBtn,
[data-theme=light] #ghBranchRefreshBtn,
[data-theme=light] #ghNewBranchBtn,
[data-theme=light] #ghCreateBranchConfirmBtn,
[data-theme=light] #ghPickFolderBtn,
[data-theme=light] #ghExportAndCommitBtn,
[data-theme=light] #ghFetchTokensBtn {
  background:
    linear-gradient(
      125deg,
      var(--accent),
      var(--accent-secondary));
  box-shadow: var(--glow-pink);
  color: var(--accent-ink);
  border: none;
}
[data-theme=light] #importBtn:hover:not([disabled]),
[data-theme=light] #exportBtn:hover:not([disabled]),
[data-theme=light] #exportTypographyBtn:hover:not([disabled]),
[data-theme=light] #ghConnectBtn:hover:not([disabled]),
[data-theme=light] #ghLogoutBtn:hover:not([disabled]),
[data-theme=light] #ghBranchRefreshBtn:hover:not([disabled]),
[data-theme=light] #ghNewBranchBtn:hover:not([disabled]),
[data-theme=light] #ghCreateBranchConfirmBtn:hover:not([disabled]),
[data-theme=light] #ghPickFolderBtn:hover:not([disabled]),
[data-theme=light] #ghExportAndCommitBtn:hover:not([disabled]),
[data-theme=light] #ghFetchTokensBtn:hover:not([disabled]) {
  transform: translateY(-1px);
  box-shadow: 0 14px 30px rgba(254, 138, 201, 0.35);
}
.muted {
  color: var(--ink-muted);
  font-size: 12px;
}
.gh-import-status {
  font-size: 12px;
  margin-top: 6px;
  color: var(--ink-muted);
}
.gh-import-status--ready {
  color: var(--ink-subtle);
}
.gh-import-status--progress {
  color: var(--accent);
}
.gh-import-status--success {
  color: #047857;
}
.gh-import-status--error {
  color: #b91c1c;
}
.import-scope-summary {
  border: 1px solid var(--border);
  border-radius: 14px;
  background: rgba(255, 255, 255, 0.03);
  padding: .75rem;
  display: flex;
  flex-direction: column;
  gap: .35rem;
  box-shadow: inset 0 0 30px rgba(255, 255, 255, 0.02);
}
.import-skip-log {
  margin-top: 1rem;
  display: flex;
  flex-direction: column;
  gap: .5rem;
  flex: 1;
  min-height: 0;
}
.import-skip-log-list {
  display: flex;
  flex-direction: column;
  gap: .5rem;
  flex: 1;
  min-height: 0;
  overflow: auto;
}
.import-skip-log-entry {
  border: 1px solid var(--border);
  border-radius: 14px;
  background: rgba(255, 255, 255, 0.02);
  padding: .75rem;
  font-size: 12px;
  display: flex;
  flex-direction: column;
  gap: .35rem;
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
}
.import-skip-log-entry-header {
  font-weight: 600;
  font-size: 12px;
  letter-spacing: .05em;
  text-transform: uppercase;
  color: var(--ink-muted);
}
.import-skip-log-entry-note {
  color: var(--ink-muted);
  font-size: 11px;
}
.import-skip-log-token-list {
  margin: 0;
  padding-left: 1.1rem;
}
.import-skip-log-token-list li {
  margin-bottom: .2rem;
}
button.link-button {
  background: none;
  border: none;
  padding: 0;
  color: var(--accent);
  font-size: 12px;
  cursor: pointer;
  text-decoration: underline;
}
button.link-button:disabled {
  opacity: .5;
  cursor: not-allowed;
  text-decoration: none;
}
pre {
  margin: 0;
  padding: .75rem;
  background: var(--log-surface);
  color: var(--ink);
  border: 1px solid var(--border);
  border-radius: 16px;
  font-family:
    "SFMono-Regular",
    Menlo,
    Consolas,
    "Cascadia Code",
    "Source Code Pro",
    "JetBrains Mono",
    ui-monospace,
    monospace;
  font-size: 11px;
  white-space: pre-wrap;
  overflow-wrap: anywhere;
  word-break: break-word;
  overflow: auto;
  min-width: 0;
  min-height: 0;
  flex: 1;
  height: 100%;
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
}
#log {
  background: var(--log-surface);
  color: var(--ink);
  font-family:
    ui-monospace,
    SFMono-Regular,
    Menlo,
    Consolas,
    "Liberation Mono",
    monospace;
  font-size: 12px;
  line-height: 1.5;
  padding: 16px;
  border-radius: 16px;
  border: 1px solid var(--border);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05), 0 10px 25px rgba(0, 0, 0, 0.55);
  overflow-y: auto;
  min-height: 140px;
  max-height: 100%;
}
#log a {
  color: var(--accent);
  font-weight: 600;
  text-decoration-color: rgba(254, 138, 201, 0.6);
  text-underline-offset: 3px;
}
#log a:hover,
#log a:focus-visible {
  color: var(--ink);
  text-decoration-color: rgba(255, 255, 255, 0.9);
  outline: 2px solid rgba(254, 138, 201, 0.4);
  outline-offset: 2px;
}
#log > div {
  padding: 2px 0;
  white-space: pre-wrap;
}
.stack {
  display: flex;
  flex-direction: column;
  gap: 10px;
  flex: 1;
  min-height: 0;
}
.row-center {
  display: flex;
  gap: 8px;
  align-items: center;
  justify-content: space-between;
}
.drawer {
  grid-column: 1 / -1;
  grid-row: 2;
  display: flex;
  flex-direction: column;
  min-height: 0;
  min-width: 0;
  border: 1px solid var(--border);
  background: var(--surface-elevated);
  border-radius: 22px;
  padding: .75rem;
  box-shadow: 0 20px 50px rgba(0, 0, 0, 0.55);
}
.drawer .panel-header {
  border-bottom: 1px solid var(--border);
}
.drawer-body {
  padding: .5rem;
  min-height: 0;
  min-width: 0;
  flex: 1;
  display: flex;
  flex-direction: column;
}
#log {
  display: block;
  padding: 16px;
  background: var(--log-surface);
  color: var(--ink);
  border: 1px solid var(--border);
  border-radius: 16px;
  font-family:
    ui-monospace,
    SFMono-Regular,
    Menlo,
    Consolas,
    "Liberation Mono",
    monospace;
  font-size: 12px;
  white-space: pre-wrap;
  overflow-y: auto;
  min-width: 0;
  min-height: 0;
  flex: 1;
  height: 100%;
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05), 0 12px 30px rgba(0, 0, 0, 0.6);
}
.resize-handle {
  position: fixed;
  right: 6px;
  bottom: 6px;
  width: 14px;
  height: 14px;
  border-radius: 3px;
  cursor: nwse-resize;
  display: grid;
  place-items: center;
  z-index: 2147483647;
  touch-action: none;
  user-select: none;
}
.resize-handle::after {
  content: "";
  width: 8px;
  height: 8px;
  border-right: 2px solid rgba(255, 255, 255, 0.4);
  border-bottom: 2px solid rgba(255, 255, 255, 0.4);
  transform: translate(1px, 1px);
  pointer-events: none;
}
#exportBtn {
  margin-top: .5rem;
  width: 100%;
}
.shell.drawer-collapsed .drawer {
  padding: 0;
  background: transparent;
  border: 0;
}
.shell.drawer-collapsed .drawer .panel-header {
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 14px;
  background: var(--surface);
  border-bottom: 1px solid var(--border);
}
.shell.drawer-collapsed .drawer .title {
  display: none;
}
.shell.drawer-collapsed .drawer .eyebrow {
  margin: 0;
}
.panel-header .actions {
  display: flex;
  gap: 8px;
  align-items: center;
}
.panel-header button {
  font-size: 11px;
  padding: 6px 12px;
  border: 1px solid var(--border);
  background: rgba(255, 255, 255, 0.08);
  color: var(--ink);
  border-radius: 999px;
  cursor: pointer;
  transition: background 140ms ease;
}
.panel-header button:hover {
  background: rgba(255, 255, 255, 0.18);
}
.tabs {
  display: flex;
  gap: .25rem;
  align-items: center;
}
.tab-btn {
  font-size: 1rem;
  padding: .45rem 1rem;
  border: 1px solid var(--border);
  background: rgba(255, 255, 255, 0.06);
  color: var(--ink);
  border-radius: 999px;
  cursor: pointer;
  transition:
    background 150ms ease,
    color 150ms ease,
    border-color 150ms ease;
}
.tab-btn:hover {
  color: var(--ink);
  background: rgba(255, 255, 255, 0.12);
}
.tab-btn.is-active:hover {
  background:
    linear-gradient(
      120deg,
      var(--accent),
      var(--accent-secondary));
  color: var(--accent-ink);
  cursor: default;
}
.tab-btn.is-active {
  background:
    linear-gradient(
      120deg,
      var(--accent),
      var(--accent-secondary));
  color: var(--accent-ink);
  border-color: transparent;
  box-shadow: var(--glow-pink);
}
.modal-overlay {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(2, 3, 8, 0.75);
  backdrop-filter: blur(10px);
  padding: 1.5rem;
  z-index: 99999;
}
.modal-overlay.is-open {
  display: flex;
}
.folder-picker-modal {
  width: min(560px, 92vw);
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  gap: 12px;
  background: rgba(7, 9, 22, 0.95);
  border: 1px solid var(--border);
  border-radius: 18px;
  box-shadow: 0 40px 80px rgba(0, 0, 0, .6);
  padding: 16px;
}
.import-scope-modal {
  width: min(420px, 92vw);
}
.import-scope-body {
  max-height: 240px;
  overflow: auto;
  display: flex;
  flex-direction: column;
  gap: .5rem;
}
.import-scope-group {
  border: 1px solid var(--border);
  border-radius: 14px;
  background: rgba(255, 255, 255, 0.03);
  padding: .75rem;
  display: flex;
  flex-direction: column;
  gap: .35rem;
}
.import-scope-group h3 {
  margin: 0 0 .25rem 0;
  font-size: 13px;
}
.import-scope-mode {
  display: flex;
  align-items: center;
  gap: .5rem;
  font-size: 12px;
}
.import-scope-footer {
  display: flex;
  gap: .5rem;
  justify-content: flex-end;
}
.import-scope-remember {
  display: flex;
  flex-direction: column;
  gap: .25rem;
  font-size: 12px;
}
.import-scope-remember label {
  display: flex;
  align-items: center;
  gap: .35rem;
}
.import-scope-missing {
  font-size: 11px;
  color: var(--ink-muted);
  margin: 0;
}
.folder-picker-header {
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.folder-picker-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--ink);
}
.folder-picker-path-row {
  display: flex;
  gap: 8px;
  align-items: center;
}
.folder-picker-path-row input {
  flex: 1;
}
.folder-picker-list {
  border: 1px solid var(--border);
  border-radius: 14px;
  background: rgba(255, 255, 255, 0.02);
  min-height: 160px;
  max-height: 50vh;
  overflow: auto;
  padding: 6px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}
.folder-picker-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 8px;
  border: 0;
  border-radius: 6px;
  background: transparent;
  font-size: 12px;
  color: inherit;
  cursor: pointer;
  text-align: left;
}
.folder-picker-row:not([disabled]):hover {
  background: rgba(255, 255, 255, 0.08);
}
.folder-picker-row.is-muted {
  color: var(--ink-muted);
  cursor: default;
}
.folder-picker-row.is-muted:hover {
  background: transparent;
}
.folder-picker-row[disabled] {
  cursor: default;
}
.folder-picker-actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
}
.tab-panel {
  display: none;
  flex-direction: column;
  gap: 12px;
  min-width: 0;
  min-height: 0;
  flex: 1;
}
.tab-panel.is-active {
  display: flex;
}
.tab-panel--scroll {
  flex: 1 1 auto;
  min-height: 0;
  overflow: auto;
}
.github-panel {
  gap: 12px;
}
#panel-github button {
  font-size: 12px;
  padding: 6px 10px;
  border-width: 1px;
}
#panel-github .css-button-neumorphic {
  min-width: 0;
  height: auto;
  padding: 6px 10px;
}
.gh-section {
  display: flex;
  flex-direction: column;
  gap: 6px;
  flex: 0 0 auto;
  min-height: auto;
}
.gh-auth-actions {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}
.gh-auth-actions button {
  min-width: 0;
}
.gh-auth-status,
.gh-auth-meta {
  font-size: 12px;
}
.gh-remember {
  display: flex;
  align-items: center;
  gap: 6px;
  flex-wrap: wrap;
}
.gh-remember-toggle {
  display: inline-flex;
  align-items: center;
  gap: 4px;
}
.gh-repo-combo {
  position: relative;
  display: flex;
  align-items: center;
}
.gh-repo-combo select {
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  padding-right: 28px;
  border-radius: 12px;
  background-color: rgba(255, 255, 255, 0.04);
  cursor: pointer;
}
.gh-repo-combo select:disabled {
  cursor: not-allowed;
  color: var(--ink-muted);
  background: rgba(255, 255, 255, 0.02);
}
.gh-repo-combo::after {
  content: "\25be";
  position: absolute;
  right: 10px;
  pointer-events: none;
  color: var(--ink-muted);
  font-size: 20px;
}
.gh-repo-combo:focus-within select:not(:disabled) {
  border-color: var(--accent);
}
.gh-branch-search {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}
.gh-branch-combo {
  position: relative;
  flex: 1 1 auto;
  min-width: 0;
  display: flex;
  align-items: stretch;
}
.gh-branch-combo input {
  flex: 1 1 auto;
  min-width: 0;
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
.gh-branch-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0 10px;
  border: 1px solid var(--border);
  border-left: none;
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
  border-top-right-radius: 12px;
  border-bottom-right-radius: 12px;
  background: rgba(255, 255, 255, 0.06);
  color: var(--ink);
  font-size: 12px;
  cursor: pointer;
}
.gh-branch-toggle:hover:not([disabled]) {
  background: rgba(255, 255, 255, 0.12);
}
.gh-branch-toggle[disabled] {
  cursor: not-allowed;
  opacity: .5;
}
.gh-branch-menu {
  position: absolute;
  top: calc(100% + 4px);
  left: 0;
  right: 0;
  max-height: 216px;
  margin: 0;
  padding: 4px 0;
  list-style: none;
  border: 1px solid var(--border);
  border-radius: 14px;
  background: rgba(4, 5, 16, 0.95);
  box-shadow: 0 25px 45px rgba(0, 0, 0, 0.55);
  overflow-y: auto;
  z-index: 20;
}
.gh-branch-menu[hidden] {
  display: none;
}
.gh-branch-item {
  padding: 6px 10px;
  font-size: 12px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  color: var(--ink);
}
.gh-branch-item[data-active="1"],
.gh-branch-item:hover {
  background: rgba(255, 255, 255, 0.08);
}
.gh-branch-item[aria-disabled=true] {
  cursor: default;
  color: var(--ink-muted);
  background: transparent;
}
.gh-branch-item-action {
  font-weight: 600;
}
.gh-branch-item-empty {
  cursor: default;
  color: var(--ink-muted);
}
.gh-branch-menu::after {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: 14px;
  pointer-events: none;
}
.gh-branch-combo:focus-within .gh-branch-toggle:not([disabled]) {
  border-color: var(--accent);
}
.gh-branch-combo:focus-within input:not(:disabled) {
  border-color: var(--accent);
}
.gh-branch-count {
  white-space: nowrap;
  font-size: 12px;
}
.gh-branch-actions {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-self: flex-start;
}
.gh-branch-actions button {
  flex: 0 0 auto;
}
.gh-branch-refresh,
.gh-new-branch-btn,
#ghPickFolderBtn {
  align-self: flex-start;
}
.gh-new-branch-row {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}
.gh-new-branch-row input {
  flex: 1 1 auto;
  min-width: 0;
}
#ghTokenInput.gh-mask {
  -webkit-text-security: disc;
}
/*# sourceMappingURL=ui.css.map */
</style>
</head>

<body>
  <div class="shell">
    <!-- Left: Actions -->
    <div class="col">
      <div class="panel">
        <div class="panel-header">
          <div>
            <div class="eyebrow">Actions</div>
            <h2 class="title">Import, Export &amp; GitHub</h2>
          </div>
          <div class="tabs" role="tablist" aria-label="Actions tabs">
            <button class="tab-btn is-active" data-tab="import" role="tab" aria-selected="true"
              aria-controls="panel-import">Import</button>
            <button class="tab-btn" data-tab="export" role="tab" aria-selected="false"
              aria-controls="panel-export">Export</button>
            <button class="tab-btn" data-tab="github" role="tab" aria-selected="false"
              aria-controls="panel-github">GitHub</button>
          </div>
        </div>

        <div class="panel-body">
          <!-- Import tab -->
          <div class="tab-panel is-active" id="panel-import" data-tab="import" role="tabpanel"
            aria-labelledby="tab-import">
            <div class="stack">
              <div class="eyebrow">Import DTCG</div>
              <div>
                <label>Choose a DTCG JSON file</label>
                <div class="muted" style="padding: .5rem 0">Imports collections/modes as defined in the file.</div>
                <input id="file" type="file" accept=".json,application/json" />
              </div>
              <div class="row">
                <button id="importBtn" class="css-button-neumorphic">Import</button>
              </div>
              <div class="row">
                <div style="display: flex; gap: .25rem;">
                  <input id="allowHexChk" type="checkbox" />
                  <label for="allowHexChk" class="muted" style="padding-top: .35rem;">Accept hex strings as
                    colors</label>
                </div>
              </div>
              <!-- <div id="importScopeSummary" class="import-scope-summary" hidden>
                <div id="importScopeSummaryText" class="muted"></div>
                <button id="importScopeClearBtn" class="link-button" type="button">Clear remembered selection</button>
              </div> -->
              <div class="import-skip-log">
                <div class="eyebrow">Import summaries</div>
                <div id="importSkipLogEmpty" class="muted">No partial import history yet.</div>
                <div id="importSkipLogList" class="import-skip-log-list"></div>
              </div>
            </div>
          </div>

          <!-- Export tab -->
          <div class="tab-panel" id="panel-export" data-tab="export" role="tabpanel" aria-labelledby="tab-export">
            <div class="stack" style="border-top:1px solid var(--border);padding-top:12px;">
              <div class="eyebrow">Export DTCG</div>
              <div class="row-center"></div>
              <div class="stack" id="exportPickers">
                <div>
                  <label>Collection</label>
                  <select id="collectionSelect"></select>
                </div>
                <div>
                  <label>Mode (within collection)</label>
                  <select id="modeSelect"></select>
                </div>
                <div>
                  <div class="muted">Select a collection and mode, or check “Export all”.</div>
                  <label><input type="checkbox" id="exportAllChk" /> Export all collections &amp; modes (creates a
                    single
                    file)</label>
                  <div class="stack" style="gap:6px; margin:8px 0;">
                    <label class="muted" style="display:flex; align-items:center; gap:.35rem;">
                      <input type="checkbox" id="styleDictionaryChk" />
                      <span>Export color tokens as hex values</span>
                    </label>
                    <label class="muted" style="display:flex; align-items:center; gap:.35rem;">
                      <input type="checkbox" id="flatTokensChk" />
                      <span>Flatten collections (omit top-level collection groups)</span>
                    </label>
                  </div>
                  <button id="exportBtn" class="css-button-neumorphic">Export</button>
                </div>
                <div style="border-top:1px solid var(--border); padding-top:12px; margin-top:8px;">
                  <div class="muted" style="margin-bottom:8px;">Typography tokens are exported separately.</div>
                  <button id="exportTypographyBtn" class="css-button-neumorphic">Export typography.json</button>
                  <div class="muted" style="margin-top:6px;">Saves all local text styles as DTCG typography tokens.
                  </div>
                </div>
              </div>
            </div>
          </div>
          <!-- /Export tab -->

          <!-- GitHub tab -->
          <div class="tab-panel" id="panel-github" data-tab="github" role="tabpanel" aria-labelledby="tab-github">
            <div class="stack tab-panel--scroll github-panel">

              <!-- Auth row -->
              <div class="stack gh-section gh-auth">
                <h3 class="eyebrow">GitHub Authentication</h3>
                <label>Personal Access Token (PAT)</label>
                <input id="ghTokenInput" type="password" placeholder="GitHub personal access token"
                  autocomplete="off" />
                <div class="muted gh-remember">
                  <span>Store on this device?</span>
                  <div class="row">
            <label>
              <input type="checkbox" id="githubRememberChk" checked />
              Remember access token
            </label>
          </div>      </div>
                <div class="gh-auth-actions" style="margin-bottom: .5rem;">
                  <button id="ghConnectBtn" class="css-button-neumorphic">Connect</button>
                  <button id="ghLogoutBtn" class="css-button-neumorphic" type="button">Log out</button>
                </div>
                <div id="ghAuthStatus" class="muted gh-auth-status"></div>
                <div id="ghTokenMeta" class="muted gh-auth-meta"></div>
              </div>

              <!-- Export scope -->
              <div class="row">
                <div>
                  <h3 class="eyebrow" style="margin: .5rem;">Export scope</h3>
                  <div class="col" style="gap:.5rem;">
                    <label style="display:flex; align-items:center; gap:.35rem;">
                      <input type="radio" name="ghScope" id="ghScopeSelected" checked />
                      Use export tab selection (collection and mode)
                    </label>
                    <label style="display:flex; align-items:center; gap:.35rem;">
                      <input type="radio" name="ghScope" id="ghScopeAll" />
                      All collections &amp; modes
                    </label>
                    <label style="display:flex; align-items:center; gap:.35rem;">
                      <input type="radio" name="ghScope" id="ghScopeTypography" />
                      Typography (text styles)
                    </label>
                  </div>
                </div>
              </div>

              <!-- Repo picker -->
              <div class="stack gh-section">
                <h3 class="eyebrow">Export repository details</h3>
                <label>Export repository</label>
                <div class="gh-repo-combo">
                  <select id="ghRepoSelect" disabled></select>
                </div>
                <div class="muted">Repos you own or are a member of (populated after Connect).</div>
              </div>

              <!-- Branch controls -->
              <div class="stack gh-section">
                <label>Export repository branch</label>
                <div class="gh-branch-search">
                  <div class="gh-branch-combo">
                    <input id="ghBranchInput" type="text" placeholder="Pick a repository first…" autocomplete="off"
                      disabled />
                    <button id="ghBranchToggleBtn" class="gh-branch-toggle" type="button" aria-label="Show branches"
                      aria-haspopup="listbox" disabled>
                      <span aria-hidden="true">▾</span>
                    </button>
                    <ul id="ghBranchMenu" class="gh-branch-menu" role="listbox" aria-label="Branches" hidden></ul>
                  </div>
                  <div id="ghBranchCount" class="muted gh-branch-count"></div>
                </div>
                <div class="gh-branch-actions">
                  <button id="ghBranchRefreshBtn" class="css-button-neumorphic gh-branch-refresh"
                    type="button">Refresh</button>
                  <button id="ghNewBranchBtn" class="css-button-neumorphic gh-new-branch-btn" disabled
                    type="button">Create new…</button>
                </div>
                <div id="ghNewBranchRow" class="gh-new-branch-row" style="display:none;">
                  <input id="ghNewBranchName" type="text" placeholder="feature/my-branch" />
                  <button id="ghCreateBranchConfirmBtn" class="css-button-neumorphic" type="button">Create</button>
                </div>
              </div>

              <!-- Destination folder -->
              <div class="stack gh-section" style="margin-top: .5rem;">
                <h3 class="eyebrow">Export destination folder and file name</h3>
                <label>Destination folder (in repo)</label>
                <button id="ghPickFolderBtn" class="css-button-neumorphic" disabled type="button">Pick a
                  folder…</button>
                <div id="ghFolderDisplay" class="gh-folder-display is-placeholder" aria-live="polite">Folder path…
                </div>
                <input id="ghFolderInput" type="hidden" value="" />
                <label for="ghFilenameInput">Filename</label>
                <input id="ghFilenameInput" type="text" value="tokens.json" autocomplete="off" />
                <div id="ghFilenameError" class="gh-input-error" aria-live="polite" hidden></div>
              </div>



              <!-- Commit -->
              <div class="row">
                <div>
                  <h3 class="eyebrow" style="margin-bottom: .5rem;">Commit/pull request details</h3>
                  <label>Commit message</label>
                  <input id="ghCommitMsgInput" type="text" value="Update tokens from Figma" />
                </div>
              </div>

              <!-- PR toggle -->
              <div class="row">
                <div>
                  <label>Pull request</label>
                  <label style="display:flex; align-items:center; gap:.35rem;">
                    <input type="checkbox" id="ghCreatePrChk" />
                    Create a pull request after committing
                  </label>
                  <div id="ghPrOptions" class="stack" style="margin-top:.5rem; display:none; gap:.5rem;">
                    <input id="ghPrTitleInput" type="text" placeholder="Pull request title" />
                    <textarea id="ghPrBodyInput" rows="3" placeholder="Optional PR description"></textarea>
                  </div>
                </div>
              </div>



              <!-- Actions -->
              <div class="row">
                <div class="row" style="gap:.5rem;">
                  <button id="ghExportAndCommitBtn" class="css-button-neumorphic" disabled>Export &amp; Commit /
                    PR</button>
                </div>
              </div>

              <!-- Import from GitHub -->
              <div class="row" style="margin-top: .5rem;">
                <div>
                  <h3 class="eyebrow" style="padding-bottom: .25rem;">Import from tokens from GitHub</h3>
                  <label>Directory path to tokens in GitHub</label>
                  <!-- <div class="muted" style="margin: .25rem;">(Downloads a JSON file from the selected repo/branch and
                    imports it.)</div> -->
                  <div class="row">
                    <input id="ghFetchPathInput" type="text" placeholder="path/to/tokens-folder/design-token.json" />
                    <div style="flex:0 0 auto;">
                      <button id="ghFetchTokensBtn" class="css-button-neumorphic" disabled>Fetch &amp; Import</button>
                    </div>
                  </div>
                  <div id="ghImportStatus" class="gh-import-status">Select a repository and branch to enable imports.
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Middle: Raw Figma Collections -->
    <div class="col">
      <div class="panel">
        <div class="panel-header">
          <div>
            <div class="eyebrow">Reference</div>
            <h2 class="title">Figma Document</h2>
          </div>
          <div class="actions">
            <button id="copyRawBtn" title="Copy raw collections">Copy</button>
            <button id="refreshBtn">Refresh</button>
          </div>
        </div>
        <div class="panel-body">
          <pre id="raw"></pre>
        </div>
      </div>
    </div>

    <!-- Right: W3C Preview -->
    <div class="col">
      <div class="panel">
        <div class="panel-header">
          <div>
            <div class="eyebrow">Preview</div>
            <h2 class="title">W3C Design Tokens (JSON)</h2>
          </div>
          <button id="copyW3cBtn" title="Copy W3C JSON">Copy</button>
        </div>
        <div class="panel-body">
          <pre id="w3cPreview">{ /* preview will render here */ }</pre>
        </div>
      </div>
    </div>

    <!-- Bottom drawer: tabs span all columns -->
    <div class="drawer">
      <div class="panel-header">
        <div>
          <div class="eyebrow">Diagnostics</div>
          <h2 class="title">Activity Log</h2>
        </div>
        <div class="actions">
          <button id="copyLogBtn" title="Copy log">Copy</button>
          <button id="drawerToggleBtn" class="drawer-toggle" aria-expanded="true" title="Hide log">Hide</button>
        </div>
      </div>

      <div class="drawer-body">
        <div id="log"></div>
      </div>
    </div>

    <div id="importScopeOverlay" class="modal-overlay" hidden aria-hidden="true">
      <div class="folder-picker-modal import-scope-modal" role="dialog" aria-modal="true"
        aria-labelledby="importScopeTitle">
        <h2 id="importScopeTitle" class="folder-picker-title">Select a mode to import</h2>
        <p class="muted" style="margin:0;">Choose which collection and mode to bring into this file.</p>
        <p id="importScopeMissingNotice" class="import-scope-missing" hidden></p>
        <div id="importScopeBody" class="import-scope-body"></div>
        <!-- <div class="import-scope-remember">
          <label><input type="checkbox" id="importScopeRememberChk" /> Remember my choice for next time</label>
          <span class="muted">You can clear this later from the import panel.</span>
        </div> -->
        <div class="import-scope-footer">
          <button id="importScopeConfirmBtn" class="css-button-neumorphic" type="button">Import selected mode</button>
          <button id="importScopeCancelBtn" class="css-button-neumorphic" type="button">Cancel</button>
        </div>
      </div>
    </div>

    <div id="folderPickerOverlay" class="modal-overlay" hidden aria-hidden="true">
      <div class="folder-picker-modal" role="dialog" aria-modal="true" aria-labelledby="folderPickerTitle">
        <div class="folder-picker-header">
          <div class="eyebrow">Pick destination</div>
          <div id="folderPickerTitle" class="folder-picker-title">owner/repo @ branch</div>
        </div>
        <div class="folder-picker-path-row">
          <input id="folderPickerPath" type="text" placeholder="tokens/ (optional)" autocomplete="off" />
          <button id="folderPickerUseBtn" class="tab-btn">Use this folder</button>
        </div>
        <div id="folderPickerList" class="folder-picker-list">
          <button class="folder-picker-row is-muted" type="button" disabled>Loading…</button>
        </div>
        <div class="folder-picker-actions">
          <button id="folderPickerCancelBtn" class="tab-btn">Cancel</button>
        </div>
      </div>
    </div>

    <div class="resize-handle" id="resizeHandle" title="Drag to resize"></div>

    <script>"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };

  // src/app/github/filenames.ts
  var DEFAULT_GITHUB_FILENAME = "tokens.json";
  var INVALID_FILENAME_CHARS = /[<>:"/\\|?*\u0000-\u001F]/;
  var MAX_FILENAME_LENGTH = 128;
  function validateGithubFilename(raw) {
    const initial = typeof raw === "string" ? raw : DEFAULT_GITHUB_FILENAME;
    const trimmed = initial.trim();
    if (!trimmed) {
      return { ok: false, message: "GitHub: Enter a filename (e.g., tokens.json)." };
    }
    if (trimmed === "." || trimmed === "..") {
      return { ok: false, message: 'GitHub: Filename cannot be "." or "..".' };
    }
    if (trimmed.length > MAX_FILENAME_LENGTH) {
      return { ok: false, message: `GitHub: Filename must be ${MAX_FILENAME_LENGTH} characters or fewer.` };
    }
    if (INVALID_FILENAME_CHARS.test(trimmed)) {
      return { ok: false, message: 'GitHub: Filename contains unsupported characters like / \\ : * ? " < > |.' };
    }
    if (!/\.json$/i.test(trimmed)) {
      return { ok: false, message: "GitHub: Filename must end with .json." };
    }
    return { ok: true, filename: trimmed };
  }

  // src/app/github/ui.ts
  var GH_MASK = "\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022";
  var BRANCH_TTL_MS = 6e4;
  function createGithubUi(deps) {
    let doc = null;
    let win = null;
    let ghTokenInput = null;
    let ghRememberChk = null;
    let ghConnectBtn = null;
    let ghVerifyBtn = null;
    let ghRepoSelect = null;
    let ghLogoutBtn = null;
    let ghBranchInput = null;
    let ghBranchToggleBtn = null;
    let ghBranchMenu = null;
    let ghBranchCountEl = null;
    let ghBranchRefreshBtn = null;
    let ghNewBranchBtn = null;
    let ghNewBranchRow = null;
    let ghNewBranchName = null;
    let ghCreateBranchConfirmBtn = null;
    let ghFolderInput = null;
    let ghFolderDisplay = null;
    let ghPickFolderBtn = null;
    let ghFilenameInput = null;
    let ghFilenameErrorEl = null;
    let ghCommitMsgInput = null;
    let ghExportAndCommitBtn = null;
    let ghCreatePrChk = null;
    let ghPrOptionsEl = null;
    let ghPrTitleInput = null;
    let ghPrBodyInput = null;
    let ghFetchPathInput = null;
    let ghFetchTokensBtn = null;
    let ghScopeSelected = null;
    let ghScopeAll = null;
    let ghScopeTypography = null;
    let styleDictionaryCheckbox = null;
    let flatTokensCheckbox = null;
    let ghImportStatusEl = null;
    let ghAuthStatusEl = null;
    let ghTokenMetaEl = null;
    let folderPickerOverlay = null;
    let folderPickerTitleEl = null;
    let folderPickerPathInput = null;
    let folderPickerUseBtn = null;
    let folderPickerListEl = null;
    let folderPickerCancelBtn = null;
    let folderPickerIsOpen = false;
    let folderPickerCurrentPath = "";
    let folderPickerLastFocus = null;
    let folderPickerRefreshNonce = 0;
    const folderListWaiters = [];
    const folderCreateWaiters = [];
    let ghIsAuthed = false;
    let ghTokenExpiresAt = null;
    let ghRememberPref = true;
    let filenameValidation = validateGithubFilename(DEFAULT_GITHUB_FILENAME);
    let currentOwner = "";
    let currentRepo = "";
    let desiredBranch = null;
    let defaultBranchFromApi = void 0;
    let loadedPages = 0;
    let hasMorePages = false;
    let isFetchingBranches = false;
    let lastBranchesFetchedAtMs = 0;
    let allBranches = [];
    let filteredBranches = [];
    let renderCount = 0;
    let branchMenuVisible = false;
    let branchHighlightIndex = -1;
    const RENDER_STEP = 200;
    const BRANCH_INPUT_PLACEHOLDER = "Search branches\u2026 (press Enter to refresh)";
    const GH_FOLDER_PLACEHOLDER = "Path in repository\u2026";
    let branchLastQuery = "";
    let branchInputPristine = true;
    let ghImportInFlight = false;
    let lastImportTarget = null;
    const IMPORT_PROMPT_SELECT = "Select a repository and branch to enable imports.";
    const IMPORT_PROMPT_BRANCH = "Pick a branch to import from.";
    const IMPORT_PROMPT_PATH = "Enter the path to a DTCG token file, then press Import.";
    let currentImportStatus = "idle";
    function setImportStatus(kind, message) {
      if (!ghImportStatusEl) return;
      currentImportStatus = kind;
      ghImportStatusEl.textContent = message;
      ghImportStatusEl.classList.remove(
        "gh-import-status--ready",
        "gh-import-status--progress",
        "gh-import-status--success",
        "gh-import-status--error"
      );
      if (kind === "ready") ghImportStatusEl.classList.add("gh-import-status--ready");
      else if (kind === "progress") ghImportStatusEl.classList.add("gh-import-status--progress");
      else if (kind === "success") ghImportStatusEl.classList.add("gh-import-status--success");
      else if (kind === "error") ghImportStatusEl.classList.add("gh-import-status--error");
    }
    function pickCollectionSelect() {
      return deps.getCollectionSelect();
    }
    function pickModeSelect() {
      return deps.getModeSelect();
    }
    function pickAllowHexCheckbox() {
      return deps.getAllowHexCheckbox();
    }
    function pickStyleDictionaryCheckbox() {
      if (!styleDictionaryCheckbox) styleDictionaryCheckbox = deps.getStyleDictionaryCheckbox();
      return styleDictionaryCheckbox;
    }
    function pickFlatTokensCheckbox() {
      if (!flatTokensCheckbox) flatTokensCheckbox = deps.getFlatTokensCheckbox();
      return flatTokensCheckbox;
    }
    function findTokenInput() {
      if (!doc) return null;
      return doc.getElementById("githubTokenInput") || doc.getElementById("ghTokenInput") || doc.getElementById("githubPatInput") || doc.querySelector('input[name="githubToken"]') || doc.querySelector('input[type="password"]');
    }
    function readPatFromUi() {
      if (!ghTokenInput) ghTokenInput = findTokenInput();
      if (!ghTokenInput) return "";
      if (ghTokenInput.getAttribute("data-filled") === "1") return GH_MASK;
      return (ghTokenInput.value || "").trim();
    }
    function updateRememberPref(pref, persist = false) {
      const next = !!pref;
      ghRememberPref = next;
      if (ghRememberChk) {
        ghRememberChk.checked = ghRememberPref;
      }
      updateGhStatusUi();
      if (persist) {
        deps.postToPlugin({ type: "SAVE_PREFS", payload: { githubRememberToken: ghRememberPref } });
      }
    }
    function ensureGhStatusElements() {
      if (!doc) return;
      if (!ghAuthStatusEl) ghAuthStatusEl = doc.getElementById("ghAuthStatus");
      if (!ghTokenMetaEl) ghTokenMetaEl = doc.getElementById("ghTokenMeta");
      if (!ghLogoutBtn) ghLogoutBtn = doc.getElementById("ghLogoutBtn");
    }
    function formatTimeLeft(expInput) {
      const exp = typeof expInput === "number" ? expInput : Date.parse(expInput);
      if (!isFinite(exp)) return "expiration: unknown";
      const now = Date.now();
      const ms = exp - now;
      if (ms <= 0) return "expired";
      const days = Math.floor(ms / (24 * 60 * 60 * 1e3));
      const hours = Math.floor(ms % (24 * 60 * 60 * 1e3) / (60 * 60 * 1e3));
      if (days > 0) return `${days}d ${hours}h left`;
      const mins = Math.floor(ms % (60 * 60 * 1e3) / (60 * 1e3));
      if (hours > 0) return `${hours}h ${mins}m left`;
      const secs = Math.floor(ms % (60 * 1e3) / 1e3);
      if (mins > 0) return `${mins}m ${secs}s left`;
      return `${secs}s left`;
    }
    function setPatFieldObfuscated(filled) {
      if (!ghTokenInput) ghTokenInput = findTokenInput();
      if (!ghTokenInput) return;
      ghTokenInput.type = "password";
      if (filled) {
        ghTokenInput.value = GH_MASK;
        ghTokenInput.setAttribute("data-filled", "1");
      } else {
        ghTokenInput.value = "";
        ghTokenInput.removeAttribute("data-filled");
      }
    }
    function updateGhStatusUi() {
      ensureGhStatusElements();
      if (ghAuthStatusEl) {
        ghAuthStatusEl.textContent = ghIsAuthed ? "GitHub: authenticated." : "GitHub: not authenticated.";
      }
      if (ghTokenMetaEl) {
        const rememberTxt = ghRememberPref ? "Remember me: on" : "Remember me: off";
        const expTxt = ghTokenExpiresAt ? `Token ${formatTimeLeft(ghTokenExpiresAt)}` : "Token expiration: unknown";
        ghTokenMetaEl.textContent = `${expTxt} \u2022 ${rememberTxt}`;
      }
      if (ghTokenInput) {
        ghTokenInput.oninput = () => {
          if (ghTokenInput && ghTokenInput.getAttribute("data-filled") === "1") {
            ghTokenInput.removeAttribute("data-filled");
          }
          if (ghConnectBtn) ghConnectBtn.disabled = false;
        };
      }
      if (ghConnectBtn && ghTokenInput) {
        const isMasked = ghTokenInput.getAttribute("data-filled") === "1";
        ghConnectBtn.disabled = ghIsAuthed && isMasked;
      }
      if (ghLogoutBtn) {
        ghLogoutBtn.disabled = !ghIsAuthed;
      }
      if (ghRememberChk) {
        ghRememberChk.checked = ghRememberPref;
      }
    }
    function setGitHubDisabledStates() {
      updateGhStatusUi();
    }
    function showNewBranchRow(show) {
      if (!ghNewBranchRow) return;
      ghNewBranchRow.style.display = show ? "flex" : "none";
      if (show && ghNewBranchName) {
        if (!ghNewBranchName.value) {
          ghNewBranchName.value = `tokens/update-${(/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-").slice(0, 19)}`;
        }
        ghNewBranchName.focus();
        ghNewBranchName.select();
      }
    }
    function revalidateBranchesIfStale(forceLog = false) {
      if (!ghRepoSelect || !ghBranchInput) return;
      if (!currentOwner || !currentRepo) return;
      const stale = Date.now() - lastBranchesFetchedAtMs > BRANCH_TTL_MS;
      if (!stale) {
        if (forceLog) deps.log("Branches are up to date (no refresh needed).");
        return;
      }
      desiredBranch = desiredBranch || null;
      defaultBranchFromApi = void 0;
      loadedPages = 0;
      hasMorePages = false;
      isFetchingBranches = true;
      allBranches = [];
      filteredBranches = [];
      renderCount = 0;
      setBranchDisabled(true, "Refreshing branches\u2026");
      updateBranchCount();
      if (ghBranchInput) {
        ghBranchInput.value = "";
        branchLastQuery = "";
        branchInputPristine = true;
      }
      deps.log("Refreshing branches\u2026");
      deps.postToPlugin({
        type: "GITHUB_FETCH_BRANCHES",
        payload: { owner: currentOwner, repo: currentRepo, page: 1 }
      });
    }
    function setBranchDisabled(disabled, placeholder) {
      const nextPlaceholder = placeholder !== void 0 ? placeholder : BRANCH_INPUT_PLACEHOLDER;
      if (ghBranchInput) {
        ghBranchInput.disabled = disabled;
        ghBranchInput.placeholder = nextPlaceholder;
        if (disabled) {
          ghBranchInput.value = "";
          branchLastQuery = "";
          branchInputPristine = true;
        }
      }
      if (ghBranchToggleBtn) {
        ghBranchToggleBtn.disabled = disabled;
        ghBranchToggleBtn.setAttribute("aria-expanded", "false");
      }
      if (disabled) closeBranchMenu();
    }
    function updateBranchCount() {
      if (!ghBranchCountEl) return;
      const total = allBranches.length;
      const showing = filteredBranches.length;
      ghBranchCountEl.textContent = `${showing} / ${total}${hasMorePages ? " +" : ""}`;
    }
    function getBranchMenuItems() {
      if (!ghBranchMenu) return [];
      const items = [];
      let node = ghBranchMenu.firstElementChild;
      while (node) {
        if (node instanceof HTMLLIElement) items.push(node);
        node = node.nextElementSibling;
      }
      return items;
    }
    function setBranchHighlight(index, scrollIntoView) {
      const items = getBranchMenuItems();
      branchHighlightIndex = index;
      for (let i = 0; i < items.length; i++) {
        if (i === branchHighlightIndex) items[i].setAttribute("data-active", "1");
        else items[i].removeAttribute("data-active");
      }
      if (scrollIntoView && branchHighlightIndex >= 0 && branchHighlightIndex < items.length) {
        try {
          items[branchHighlightIndex].scrollIntoView({ block: "nearest" });
        } catch (e) {
        }
      }
    }
    function findNextSelectable(startIndex, delta, items) {
      if (!items.length) return -1;
      let index = startIndex;
      for (let i = 0; i < items.length; i++) {
        index += delta;
        if (index < 0) index = items.length - 1;
        else if (index >= items.length) index = 0;
        const item = items[index];
        if (!item) continue;
        if (item.dataset.selectable === "1" && item.getAttribute("aria-disabled") !== "true") return index;
      }
      return -1;
    }
    function moveBranchHighlight(delta) {
      const items = getBranchMenuItems();
      if (!items.length) {
        setBranchHighlight(-1, false);
        return;
      }
      const next = findNextSelectable(branchHighlightIndex, delta, items);
      if (next >= 0) setBranchHighlight(next, true);
    }
    function syncBranchHighlightAfterRender() {
      const items = getBranchMenuItems();
      if (!branchMenuVisible) {
        setBranchHighlight(-1, false);
        return;
      }
      if (!items.length) {
        setBranchHighlight(-1, false);
        return;
      }
      if (branchHighlightIndex >= 0 && branchHighlightIndex < items.length) {
        const current = items[branchHighlightIndex];
        if (current && current.dataset.selectable === "1" && current.getAttribute("aria-disabled") !== "true") {
          setBranchHighlight(branchHighlightIndex, false);
          return;
        }
      }
      const first = findNextSelectable(-1, 1, items);
      setBranchHighlight(first, false);
    }
    function setBranchMenuVisible(show) {
      if (!ghBranchMenu) {
        branchMenuVisible = false;
        branchHighlightIndex = -1;
        return;
      }
      if (show && ghBranchInput && ghBranchInput.disabled) show = false;
      branchMenuVisible = show;
      if (branchMenuVisible) {
        ghBranchMenu.hidden = false;
        ghBranchMenu.setAttribute("data-open", "1");
        if (ghBranchToggleBtn) ghBranchToggleBtn.setAttribute("aria-expanded", "true");
        if (ghBranchInput) ghBranchInput.setAttribute("aria-expanded", "true");
      } else {
        ghBranchMenu.hidden = true;
        ghBranchMenu.removeAttribute("data-open");
        if (ghBranchToggleBtn) ghBranchToggleBtn.setAttribute("aria-expanded", "false");
        if (ghBranchInput) ghBranchInput.setAttribute("aria-expanded", "false");
        setBranchHighlight(-1, false);
      }
    }
    function openBranchMenu() {
      if (!ghBranchMenu) return;
      if (!branchMenuVisible) {
        if (!ghBranchMenu.childElementCount) renderOptions();
        setBranchMenuVisible(true);
      }
      syncBranchHighlightAfterRender();
    }
    function closeBranchMenu() {
      setBranchMenuVisible(false);
    }
    function renderOptions() {
      if (!ghBranchMenu) return;
      while (ghBranchMenu.firstChild) ghBranchMenu.removeChild(ghBranchMenu.firstChild);
      const slice = filteredBranches.slice(0, renderCount);
      if (slice.length > 0) {
        for (let i = 0; i < slice.length; i++) {
          const name = slice[i];
          const item = doc.createElement("li");
          item.className = "gh-branch-item";
          item.dataset.value = name;
          item.dataset.selectable = "1";
          item.setAttribute("role", "option");
          item.textContent = name;
          if (i === branchHighlightIndex) item.setAttribute("data-active", "1");
          ghBranchMenu.appendChild(item);
        }
      } else {
        const empty = doc.createElement("li");
        empty.className = "gh-branch-item gh-branch-item-empty";
        empty.setAttribute("aria-disabled", "true");
        empty.dataset.selectable = "0";
        empty.textContent = allBranches.length ? "No matching branches" : "No branches loaded yet";
        ghBranchMenu.appendChild(empty);
      }
      if (filteredBranches.length > renderCount) {
        const more = doc.createElement("li");
        more.className = "gh-branch-item gh-branch-item-action";
        more.dataset.value = "__more__";
        more.dataset.selectable = "1";
        more.textContent = `Load more\u2026 (${filteredBranches.length - renderCount} more)`;
        ghBranchMenu.appendChild(more);
      } else if (hasMorePages) {
        const fetch = doc.createElement("li");
        fetch.className = "gh-branch-item gh-branch-item-action";
        fetch.dataset.value = "__fetch__";
        fetch.dataset.selectable = "1";
        fetch.textContent = "Load next page\u2026";
        ghBranchMenu.appendChild(fetch);
      }
      if (ghBranchInput) {
        const want = desiredBranch || defaultBranchFromApi || "";
        if (!ghBranchInput.value && want && branchInputPristine) {
          ghBranchInput.value = want;
          branchLastQuery = want;
        }
      }
      if (branchMenuVisible) {
        syncBranchHighlightAfterRender();
      }
    }
    function applyBranchFilter() {
      const rawInput = ((ghBranchInput == null ? void 0 : ghBranchInput.value) || "").trim();
      const raw = rawInput === "__more__" || rawInput === "__fetch__" ? branchLastQuery.trim() : rawInput;
      const q = raw.toLowerCase();
      const isSelected = !!desiredBranch && raw === desiredBranch;
      const isDefaultShown = !desiredBranch && !!defaultBranchFromApi && raw === defaultBranchFromApi;
      const effectiveQuery = isSelected || isDefaultShown ? "" : q;
      filteredBranches = effectiveQuery ? allBranches.filter((n) => n.toLowerCase().includes(effectiveQuery)) : [...allBranches];
      renderCount = Math.min(RENDER_STEP, filteredBranches.length);
      renderOptions();
      updateBranchCount();
      if (!branchMenuVisible && ghBranchInput && !ghBranchInput.disabled) {
        const isFocused = !!doc && doc.activeElement === ghBranchInput;
        if (isFocused) {
          setBranchMenuVisible(true);
          syncBranchHighlightAfterRender();
        }
      }
    }
    function processBranchSelection(rawValue, fromMenu) {
      const value = (rawValue || "").trim();
      if (!ghBranchInput) return "noop";
      if (value === "__more__") {
        renderCount = Math.min(renderCount + RENDER_STEP, filteredBranches.length);
        renderOptions();
        updateBranchCount();
        ghBranchInput.value = branchLastQuery;
        if (fromMenu && !branchMenuVisible) setBranchMenuVisible(true);
        return "more";
      }
      if (value === "__fetch__") {
        ensureNextPageIfNeeded();
        ghBranchInput.value = branchLastQuery;
        return "fetch";
      }
      if (!value) return "noop";
      desiredBranch = value;
      branchLastQuery = value;
      ghBranchInput.value = value;
      branchInputPristine = false;
      deps.postToPlugin({
        type: "GITHUB_SELECT_BRANCH",
        payload: { owner: currentOwner, repo: currentRepo, branch: value }
      });
      applyBranchFilter();
      updateFolderControlsEnabled();
      updateExportCommitEnabled();
      updateFetchButtonEnabled();
      return "selected";
    }
    function ensureNextPageIfNeeded() {
      if (!ghBranchInput || !ghRepoSelect) return;
      if (!hasMorePages || isFetchingBranches) return;
      if (!currentOwner || !currentRepo) return;
      isFetchingBranches = true;
      deps.postToPlugin({
        type: "GITHUB_FETCH_BRANCHES",
        payload: { owner: currentOwner, repo: currentRepo, page: loadedPages + 1 }
      });
    }
    function onBranchChange() {
      if (!ghBranchInput) return;
      const result = processBranchSelection(ghBranchInput.value, false);
      if (result === "selected") closeBranchMenu();
      else if (result === "more" || result === "fetch") syncBranchHighlightAfterRender();
    }
    function normalizeFolderInput(raw) {
      const trimmed = raw.trim();
      if (!trimmed) return { display: "", payload: "" };
      if (trimmed === "/" || trimmed === "./" || trimmed === ".") {
        return { display: "/", payload: "/" };
      }
      const collapsed = trimmed.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
      const stripped = collapsed.replace(/^\/+/, "").replace(/\/+$/, "");
      if (!stripped) return { display: "/", payload: "/" };
      return { display: stripped + "/", payload: stripped };
    }
    function normalizeFolderPickerPath(raw) {
      const trimmed = (raw || "").trim();
      if (!trimmed || trimmed === "/" || trimmed === "./" || trimmed === ".") return "";
      const collapsed = trimmed.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
      return collapsed.replace(/^\/+/, "").replace(/\/+$/, "");
    }
    function setGhFolderDisplay(display) {
      if (ghFolderInput) ghFolderInput.value = display || "";
      if (!ghFolderDisplay) return;
      if (display) {
        ghFolderDisplay.textContent = display;
        ghFolderDisplay.classList.remove("is-placeholder");
      } else {
        ghFolderDisplay.textContent = GH_FOLDER_PLACEHOLDER;
        ghFolderDisplay.classList.add("is-placeholder");
      }
    }
    function setFilenameError(message) {
      if (!ghFilenameErrorEl) return;
      if (message) {
        ghFilenameErrorEl.textContent = message;
        ghFilenameErrorEl.hidden = false;
      } else {
        ghFilenameErrorEl.textContent = "";
        ghFilenameErrorEl.hidden = true;
      }
    }
    function refreshFilenameValidation() {
      const raw = ghFilenameInput ? ghFilenameInput.value : "";
      const result = validateGithubFilename(raw || DEFAULT_GITHUB_FILENAME);
      filenameValidation = result;
      if (result.ok) setFilenameError(null);
      else setFilenameError(result.message);
    }
    function getCurrentFilename() {
      if (filenameValidation.ok) return filenameValidation.filename;
      const raw = ghFilenameInput ? ghFilenameInput.value : "";
      return raw.trim() || DEFAULT_GITHUB_FILENAME;
    }
    function formatDestinationForLog(folderRaw, filename) {
      const normalized = normalizeFolderInput(folderRaw || "");
      const folderDisplay = normalized.display || "/";
      const base = folderDisplay || "/";
      const name = filename && filename.trim() ? filename.trim() : "(file)";
      const joiner = base.endsWith("/") ? "" : "/";
      return `${base}${joiner}${name}`;
    }
    function listDir(path) {
      return new Promise((resolve) => {
        const req = { path: path.replace(/^\/+|\/+$/g, "") };
        folderListWaiters.push({
          path: req.path,
          resolve: (v) => resolve(v),
          reject: (v) => resolve(v)
        });
        deps.postToPlugin({
          type: "GITHUB_FOLDER_LIST",
          payload: { owner: currentOwner, repo: currentRepo, branch: getCurrentBranch(), path: req.path }
        });
      });
    }
    function openFolderPicker() {
      if (!currentOwner || !currentRepo) {
        deps.log("Pick a repository first.");
        return;
      }
      const ref = getCurrentBranch();
      if (!ref) {
        deps.log("Pick a branch first.");
        return;
      }
      if (!(folderPickerOverlay && folderPickerTitleEl && folderPickerPathInput && folderPickerListEl)) {
        deps.log("Folder picker UI is unavailable.");
        return;
      }
      folderPickerLastFocus = doc && doc.activeElement instanceof HTMLElement ? doc.activeElement : null;
      folderPickerOverlay.hidden = false;
      folderPickerOverlay.classList.add("is-open");
      folderPickerOverlay.setAttribute("aria-hidden", "false");
      folderPickerIsOpen = true;
      updateFolderPickerTitle(ref);
      const startNormalized = normalizeFolderInput((ghFolderInput == null ? void 0 : ghFolderInput.value) || "");
      const startPath = startNormalized.payload === "/" ? "" : startNormalized.payload;
      setFolderPickerPath(startPath, true);
      win == null ? void 0 : win.setTimeout(() => {
        folderPickerPathInput == null ? void 0 : folderPickerPathInput.focus();
        folderPickerPathInput == null ? void 0 : folderPickerPathInput.select();
      }, 0);
    }
    function closeFolderPicker() {
      if (!folderPickerOverlay) return;
      folderPickerOverlay.classList.remove("is-open");
      folderPickerOverlay.setAttribute("aria-hidden", "true");
      folderPickerOverlay.hidden = true;
      folderPickerIsOpen = false;
      folderPickerCurrentPath = "";
      folderPickerRefreshNonce++;
      if (folderPickerListEl) {
        folderPickerListEl.replaceChildren(createFolderPickerRow("Loading\u2026", { muted: true, disabled: true }));
      }
      if (folderPickerLastFocus && (doc == null ? void 0 : doc.contains(folderPickerLastFocus))) {
        folderPickerLastFocus.focus();
      }
      folderPickerLastFocus = null;
    }
    function createFolderPickerRow(label, options) {
      if (!doc) throw new Error("GitHub UI not attached");
      const btn = doc.createElement("button");
      btn.type = "button";
      btn.className = "folder-picker-row";
      btn.textContent = label;
      if (options == null ? void 0 : options.muted) btn.classList.add("is-muted");
      if (options == null ? void 0 : options.disabled) btn.disabled = true;
      if (options == null ? void 0 : options.onClick) {
        btn.addEventListener("click", (event) => {
          var _a;
          event.preventDefault();
          (_a = options.onClick) == null ? void 0 : _a.call(options);
        });
      }
      return btn;
    }
    function updateFolderPickerTitle(branch) {
      if (!folderPickerTitleEl) return;
      if (currentOwner && currentRepo) {
        folderPickerTitleEl.textContent = `${currentOwner}/${currentRepo} @ ${branch}`;
      } else {
        folderPickerTitleEl.textContent = "Select a repository first";
      }
    }
    function setFolderPickerPath(raw, refresh = true, syncInput = true) {
      const normalized = normalizeFolderPickerPath(raw);
      folderPickerCurrentPath = normalized;
      if (syncInput && folderPickerPathInput) folderPickerPathInput.value = normalized;
      if (refresh && folderPickerIsOpen) {
        void refreshFolderPickerList();
      }
    }
    async function refreshFolderPickerList() {
      if (!(folderPickerListEl && folderPickerIsOpen)) return;
      const listEl = folderPickerListEl;
      const requestId = ++folderPickerRefreshNonce;
      listEl.replaceChildren(createFolderPickerRow("Loading\u2026", { muted: true, disabled: true }));
      const path = folderPickerCurrentPath;
      const res = await listDir(path);
      if (requestId !== folderPickerRefreshNonce) return;
      if (!res.ok) {
        const status = typeof res.status === "number" ? res.status : 0;
        if (status === 404) {
          listEl.replaceChildren(
            createFolderPickerRow("Folder not found. It will be created during export.", { muted: true, disabled: true })
          );
          return;
        }
        if (status === 409) {
          listEl.replaceChildren(
            createFolderPickerRow("Cannot open this path: an existing file blocks the folder.", { muted: true, disabled: true })
          );
          return;
        }
        const message = res.message ? res.message : "failed to fetch";
        listEl.replaceChildren(createFolderPickerRow(`Error: ${message}`, { muted: true, disabled: true }));
        return;
      }
      const nodes = [];
      if (path) {
        nodes.push(createFolderPickerRow(".. (up one level)", {
          muted: true,
          onClick: () => {
            const parentParts = folderPickerCurrentPath.split("/").filter(Boolean);
            parentParts.pop();
            setFolderPickerPath(parentParts.join("/"));
          }
        }));
      }
      const entries = Array.isArray(res.entries) ? res.entries : [];
      const dirs = entries.filter((e) => e.type === "dir").sort((a, b) => (a.name || "").localeCompare(b.name || ""));
      if (dirs.length === 0) {
        nodes.push(createFolderPickerRow("(no subfolders)", { muted: true, disabled: true }));
      } else {
        for (const d of dirs) {
          const name = d.name || "";
          nodes.push(createFolderPickerRow(`${name}/`, {
            onClick: () => {
              const next = folderPickerCurrentPath ? `${folderPickerCurrentPath}/${name}` : name;
              setFolderPickerPath(next);
            }
          }));
        }
      }
      listEl.replaceChildren(...nodes);
    }
    function handleFolderPickerKeydown(event) {
      if (!folderPickerIsOpen) return;
      if (event.key === "Escape") {
        event.preventDefault();
        closeFolderPicker();
      }
    }
    function populateGhRepos(list) {
      if (!ghRepoSelect) return;
      while (ghRepoSelect.options.length) ghRepoSelect.remove(0);
      for (const r of list) {
        const opt = doc.createElement("option");
        opt.value = r.full_name;
        opt.textContent = r.full_name;
        ghRepoSelect.appendChild(opt);
      }
      ghRepoSelect.disabled = list.length === 0;
      if (list.length > 0) {
        if (currentOwner && currentRepo) {
          const want = `${currentOwner}/${currentRepo}`;
          let matched = false;
          for (let i = 0; i < ghRepoSelect.options.length; i++) {
            if (ghRepoSelect.options[i].value === want) {
              ghRepoSelect.selectedIndex = i;
              matched = true;
              break;
            }
          }
          if (matched) {
            ghRepoSelect.dispatchEvent(new Event("change", { bubbles: true }));
          }
        } else {
          ghRepoSelect.selectedIndex = 0;
          ghRepoSelect.dispatchEvent(new Event("change", { bubbles: true }));
        }
      }
    }
    function getCurrentBranch() {
      if (desiredBranch) return desiredBranch;
      if (ghBranchInput && !ghBranchInput.disabled) {
        const raw = ghBranchInput.value.trim();
        if (raw && raw !== "__more__" && raw !== "__fetch__") {
          if (allBranches.includes(raw) || raw === defaultBranchFromApi) return raw;
        }
      }
      return defaultBranchFromApi || "";
    }
    function getPrBaseBranch() {
      return defaultBranchFromApi || "";
    }
    function persistGhState(partial) {
      deps.postToPlugin({ type: "GITHUB_SAVE_STATE", payload: partial });
    }
    function updateExportCommitEnabled() {
      const collectionSelect2 = pickCollectionSelect();
      const modeSelect2 = pickModeSelect();
      const hasRepo = !!(currentOwner && currentRepo);
      const br = getCurrentBranch();
      const commitMsg = ((ghCommitMsgInput == null ? void 0 : ghCommitMsgInput.value) || "").trim();
      const scopeAll = !!(ghScopeAll && ghScopeAll.checked);
      const scopeTypography = !!(ghScopeTypography && ghScopeTypography.checked);
      const folderRaw = ghFolderInput ? ghFolderInput.value.trim() : "";
      const hasFolder = normalizeFolderInput(folderRaw).display.length > 0;
      const hasFilename = filenameValidation.ok;
      const hasSelection = scopeAll || scopeTypography ? true : !!(collectionSelect2 && collectionSelect2.value && modeSelect2 && modeSelect2.value);
      let ready = !!(ghIsAuthed && hasRepo && br && commitMsg && hasSelection && hasFolder && hasFilename);
      if (ghCreatePrChk && ghCreatePrChk.checked) {
        const prBase = getPrBaseBranch();
        if (!prBase || prBase === br) {
          ready = false;
        }
      }
      if (ghExportAndCommitBtn) ghExportAndCommitBtn.disabled = !ready;
    }
    function updateFolderControlsEnabled() {
      const br = getCurrentBranch();
      const enable = !!(currentOwner && currentRepo && br);
      if (ghPickFolderBtn) ghPickFolderBtn.disabled = !enable;
      updateExportCommitEnabled();
      updateFetchButtonEnabled();
    }
    function updateFetchButtonEnabled() {
      const hasRepo = !!(ghIsAuthed && currentOwner && currentRepo);
      const branch = getCurrentBranch();
      const path = ((ghFetchPathInput == null ? void 0 : ghFetchPathInput.value) || "").trim();
      if (ghFetchPathInput) ghFetchPathInput.disabled = !(hasRepo && branch) || ghImportInFlight;
      if (ghFetchTokensBtn) ghFetchTokensBtn.disabled = ghImportInFlight || !(hasRepo && branch && path);
      if (ghImportInFlight) return;
      if (!hasRepo) {
        lastImportTarget = null;
        setImportStatus("idle", IMPORT_PROMPT_SELECT);
        return;
      }
      if (!branch) {
        lastImportTarget = null;
        setImportStatus("idle", IMPORT_PROMPT_BRANCH);
        return;
      }
      if (!path) {
        lastImportTarget = null;
        setImportStatus("idle", IMPORT_PROMPT_PATH);
        return;
      }
      if (currentImportStatus === "success" || currentImportStatus === "error") {
        if (!lastImportTarget || lastImportTarget.branch !== branch || lastImportTarget.path !== path) {
          currentImportStatus = "idle";
        }
      }
      if (currentImportStatus !== "success" && currentImportStatus !== "error") {
        setImportStatus("ready", `Ready to import from ${branch}.`);
      }
    }
    function attach(context) {
      doc = context.document;
      win = context.window;
      ghTokenInput = findTokenInput();
      ghRememberChk = doc.getElementById("githubRememberChk") || doc.getElementById("ghRememberChk");
      ghConnectBtn = doc.getElementById("githubConnectBtn") || doc.getElementById("ghConnectBtn");
      ghVerifyBtn = doc.getElementById("githubVerifyBtn") || doc.getElementById("ghVerifyBtn");
      ghLogoutBtn = doc.getElementById("ghLogoutBtn");
      ghRepoSelect = doc.getElementById("ghRepoSelect");
      ghBranchInput = doc.getElementById("ghBranchInput");
      ghBranchToggleBtn = doc.getElementById("ghBranchToggleBtn");
      ghBranchMenu = doc.getElementById("ghBranchMenu");
      ghBranchCountEl = doc.getElementById("ghBranchCount");
      ghBranchRefreshBtn = doc.getElementById("ghBranchRefreshBtn");
      ghNewBranchBtn = doc.getElementById("ghNewBranchBtn");
      ghNewBranchRow = doc.getElementById("ghNewBranchRow");
      ghNewBranchName = doc.getElementById("ghNewBranchName");
      ghCreateBranchConfirmBtn = doc.getElementById("ghCreateBranchConfirmBtn");
      ghFolderInput = doc.getElementById("ghFolderInput");
      ghFolderDisplay = doc.getElementById("ghFolderDisplay");
      setGhFolderDisplay((ghFolderInput == null ? void 0 : ghFolderInput.value) || "");
      ghPickFolderBtn = doc.getElementById("ghPickFolderBtn");
      ghFilenameInput = doc.getElementById("ghFilenameInput");
      ghFilenameErrorEl = doc.getElementById("ghFilenameError");
      if (ghFilenameInput && !ghFilenameInput.value) {
        ghFilenameInput.value = DEFAULT_GITHUB_FILENAME;
      }
      refreshFilenameValidation();
      ghCommitMsgInput = doc.getElementById("ghCommitMsgInput");
      ghExportAndCommitBtn = doc.getElementById("ghExportAndCommitBtn");
      ghCreatePrChk = doc.getElementById("ghCreatePrChk");
      ghPrOptionsEl = doc.getElementById("ghPrOptions");
      ghPrTitleInput = doc.getElementById("ghPrTitleInput");
      ghPrBodyInput = doc.getElementById("ghPrBodyInput");
      ghFetchPathInput = doc.getElementById("ghFetchPathInput");
      ghFetchTokensBtn = doc.getElementById("ghFetchTokensBtn");
      ghScopeSelected = doc.getElementById("ghScopeSelected");
      ghScopeAll = doc.getElementById("ghScopeAll");
      ghScopeTypography = doc.getElementById("ghScopeTypography");
      ghImportStatusEl = doc.getElementById("ghImportStatus");
      if (ghBranchInput) {
        ghBranchInput.setAttribute("role", "combobox");
        ghBranchInput.setAttribute("aria-autocomplete", "list");
        ghBranchInput.setAttribute("aria-expanded", "false");
        ghBranchInput.setAttribute("aria-controls", "ghBranchMenu");
      }
      if (ghBranchToggleBtn) ghBranchToggleBtn.setAttribute("aria-expanded", "false");
      folderPickerOverlay = doc.getElementById("folderPickerOverlay");
      folderPickerTitleEl = doc.getElementById("folderPickerTitle");
      folderPickerPathInput = doc.getElementById("folderPickerPath");
      folderPickerUseBtn = doc.getElementById("folderPickerUseBtn");
      folderPickerListEl = doc.getElementById("folderPickerList");
      folderPickerCancelBtn = doc.getElementById("folderPickerCancelBtn");
      if (ghRememberChk) {
        ghRememberChk.checked = ghRememberPref;
        ghRememberChk.addEventListener("change", () => {
          updateRememberPref(!!ghRememberChk.checked, true);
        });
      }
      ensureGhStatusElements();
      if (ghConnectBtn) ghConnectBtn.addEventListener("click", onGitHubConnectClick);
      if (ghVerifyBtn) ghVerifyBtn.addEventListener("click", onGitHubVerifyClick);
      if (ghLogoutBtn) ghLogoutBtn.addEventListener("click", onGitHubLogoutClick);
      if (ghRepoSelect && ghBranchInput) {
        let lastRepoKey = "";
        ghRepoSelect.addEventListener("change", () => {
          const value = ghRepoSelect.value;
          if (!value) return;
          if (value === lastRepoKey) return;
          lastRepoKey = value;
          const parts = value.split("/");
          currentOwner = parts[0] || "";
          currentRepo = parts[1] || "";
          updateExportCommitEnabled();
          updateFetchButtonEnabled();
          lastBranchesFetchedAtMs = 0;
          deps.postToPlugin({ type: "GITHUB_SELECT_REPO", payload: { owner: currentOwner, repo: currentRepo } });
          desiredBranch = null;
          defaultBranchFromApi = void 0;
          loadedPages = 0;
          hasMorePages = false;
          isFetchingBranches = false;
          allBranches = [];
          filteredBranches = [];
          renderCount = 0;
          if (ghBranchInput) {
            ghBranchInput.value = "";
            branchLastQuery = "";
            branchInputPristine = true;
          }
          if (ghBranchMenu) while (ghBranchMenu.firstChild) ghBranchMenu.removeChild(ghBranchMenu.firstChild);
          closeBranchMenu();
          setBranchDisabled(true, "Loading branches\u2026");
          updateBranchCount();
          updateFolderControlsEnabled();
          setGhFolderDisplay("");
          if (currentOwner && currentRepo) {
            deps.log(`GitHub: loading branches for ${currentOwner}/${currentRepo}\u2026`);
            isFetchingBranches = true;
            deps.postToPlugin({
              type: "GITHUB_FETCH_BRANCHES",
              payload: { owner: currentOwner, repo: currentRepo, page: 1 }
            });
          }
          updateExportCommitEnabled();
        });
      }
      if (ghBranchInput) {
        let timeout;
        ghBranchInput.addEventListener("focus", () => {
          if (ghBranchInput.disabled) return;
          applyBranchFilter();
          openBranchMenu();
        });
        ghBranchInput.addEventListener("input", () => {
          if (timeout) win == null ? void 0 : win.clearTimeout(timeout);
          const value = ghBranchInput.value;
          if (value !== "__more__" && value !== "__fetch__") {
            branchLastQuery = value;
          }
          branchInputPristine = false;
          if (!branchMenuVisible) openBranchMenu();
          timeout = win == null ? void 0 : win.setTimeout(() => {
            applyBranchFilter();
          }, 120);
        });
        ghBranchInput.addEventListener("keydown", (e) => {
          if (e.key === "ArrowDown") {
            openBranchMenu();
            moveBranchHighlight(1);
            e.preventDefault();
            return;
          }
          if (e.key === "ArrowUp") {
            openBranchMenu();
            moveBranchHighlight(-1);
            e.preventDefault();
            return;
          }
          if (e.key === "Enter") {
            if (branchMenuVisible && branchHighlightIndex >= 0) {
              const items = getBranchMenuItems();
              const item = items[branchHighlightIndex];
              if (item && item.dataset.selectable === "1") {
                const value = item.getAttribute("data-value") || "";
                if (value) {
                  const result = processBranchSelection(value, true);
                  if (result === "selected") closeBranchMenu();
                  else if (result === "more" || result === "fetch") {
                    syncBranchHighlightAfterRender();
                    openBranchMenu();
                  }
                }
              }
            } else {
              const result = processBranchSelection(ghBranchInput.value, false);
              if (result === "selected") closeBranchMenu();
              else if (result === "more" || result === "fetch") syncBranchHighlightAfterRender();
            }
            revalidateBranchesIfStale(true);
            e.preventDefault();
            return;
          }
          if (e.key === "Escape") {
            if (branchMenuVisible) {
              closeBranchMenu();
              e.preventDefault();
            }
          }
        });
        ghBranchInput.addEventListener("change", () => {
          const result = processBranchSelection(ghBranchInput.value, false);
          if (result === "selected") closeBranchMenu();
          else if (result === "more" || result === "fetch") syncBranchHighlightAfterRender();
        });
      }
      if (ghBranchToggleBtn) {
        ghBranchToggleBtn.addEventListener("click", () => {
          if (ghBranchToggleBtn.disabled) return;
          if (branchMenuVisible) {
            closeBranchMenu();
            return;
          }
          if (!ghBranchMenu || !ghBranchMenu.childElementCount) renderOptions();
          openBranchMenu();
          if (ghBranchInput && (doc == null ? void 0 : doc.activeElement) !== ghBranchInput) ghBranchInput.focus();
        });
      }
      if (ghBranchMenu) {
        ghBranchMenu.addEventListener("mousedown", (event) => {
          event.preventDefault();
        });
        ghBranchMenu.addEventListener("click", (event) => {
          const target = event.target;
          if (!target) return;
          const item = target.closest("li");
          if (!item || !(item instanceof HTMLLIElement)) return;
          if (item.getAttribute("aria-disabled") === "true") return;
          const value = item.getAttribute("data-value") || "";
          if (!value) return;
          const result = processBranchSelection(value, true);
          if (result === "selected") closeBranchMenu();
          else if (result === "more" || result === "fetch") {
            syncBranchHighlightAfterRender();
            openBranchMenu();
          }
          if (ghBranchInput) ghBranchInput.focus();
        });
      }
      if (doc) {
        doc.addEventListener("mousedown", (event) => {
          if (!branchMenuVisible) return;
          const target = event.target;
          if (!target) return;
          if (ghBranchMenu && ghBranchMenu.contains(target)) return;
          if (ghBranchInput && target === ghBranchInput) return;
          if (ghBranchToggleBtn && ghBranchToggleBtn.contains(target)) return;
          closeBranchMenu();
        });
        doc.addEventListener("focusin", (event) => {
          if (!branchMenuVisible) return;
          const target = event.target;
          if (!target) {
            closeBranchMenu();
            return;
          }
          if (ghBranchMenu && ghBranchMenu.contains(target)) return;
          if (ghBranchInput && target === ghBranchInput) return;
          if (ghBranchToggleBtn && ghBranchToggleBtn.contains(target)) return;
          closeBranchMenu();
        });
      }
      if (ghBranchRefreshBtn) {
        ghBranchRefreshBtn.addEventListener("click", () => {
          lastBranchesFetchedAtMs = 0;
          revalidateBranchesIfStale(true);
        });
      }
      if (ghPickFolderBtn) {
        ghPickFolderBtn.addEventListener("click", openFolderPicker);
      }
      if (folderPickerOverlay) {
        folderPickerOverlay.addEventListener("click", (event) => {
          if (event.target === folderPickerOverlay) closeFolderPicker();
        });
      }
      if (folderPickerCancelBtn) {
        folderPickerCancelBtn.addEventListener("click", () => closeFolderPicker());
      }
      let folderPickerPathDebounce;
      if (folderPickerPathInput) {
        folderPickerPathInput.addEventListener("input", () => {
          if (folderPickerPathDebounce) win == null ? void 0 : win.clearTimeout(folderPickerPathDebounce);
          const value = folderPickerPathInput.value;
          folderPickerPathDebounce = win == null ? void 0 : win.setTimeout(() => {
            setFolderPickerPath(value, true, false);
          }, 120);
        });
        folderPickerPathInput.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            event.preventDefault();
            setFolderPickerPath(folderPickerPathInput.value);
          }
        });
        folderPickerPathInput.addEventListener("blur", () => {
          setFolderPickerPath(folderPickerPathInput.value);
        });
      }
      if (folderPickerUseBtn) {
        folderPickerUseBtn.addEventListener("click", () => {
          if (folderPickerPathInput) {
            setFolderPickerPath(folderPickerPathInput.value, false);
          }
          const selectionRaw = folderPickerCurrentPath ? `${folderPickerCurrentPath}/` : "/";
          const normalized = normalizeFolderInput(selectionRaw);
          setGhFolderDisplay(normalized.display);
          deps.postToPlugin({
            type: "GITHUB_SET_FOLDER",
            payload: { owner: currentOwner, repo: currentRepo, folder: normalized.payload }
          });
          persistGhState({ folder: normalized.payload });
          closeFolderPicker();
          deps.log(`Folder selected: ${normalized.display === "/" ? "(repo root)" : normalized.display}`);
          updateExportCommitEnabled();
          updateFetchButtonEnabled();
        });
      }
      if (ghCommitMsgInput) {
        ghCommitMsgInput.addEventListener("input", () => {
          updateExportCommitEnabled();
          persistGhState({ commitMessage: ghCommitMsgInput.value || "" });
        });
      }
      if (ghFilenameInput) {
        ghFilenameInput.addEventListener("input", () => {
          refreshFilenameValidation();
          persistGhState({ filename: (ghFilenameInput.value || "").trim() });
          updateExportCommitEnabled();
        });
        ghFilenameInput.addEventListener("blur", () => refreshFilenameValidation());
      }
      if (ghScopeSelected) {
        ghScopeSelected.addEventListener("change", () => {
          if ((ghScopeSelected == null ? void 0 : ghScopeSelected.checked) && ghPrOptionsEl) {
            ghPrOptionsEl.style.display = (ghCreatePrChk == null ? void 0 : ghCreatePrChk.checked) ? "flex" : "none";
          }
          if (ghScopeSelected.checked) persistGhState({ scope: "selected" });
          updateExportCommitEnabled();
        });
      }
      if (ghScopeAll) {
        ghScopeAll.addEventListener("change", () => {
          if (ghScopeAll.checked) persistGhState({ scope: "all" });
          updateExportCommitEnabled();
        });
      }
      if (ghScopeTypography) {
        ghScopeTypography.addEventListener("change", () => {
          if (ghScopeTypography.checked) persistGhState({ scope: "typography" });
          if (ghPrOptionsEl) ghPrOptionsEl.style.display = (ghCreatePrChk == null ? void 0 : ghCreatePrChk.checked) ? "flex" : "none";
          updateExportCommitEnabled();
        });
      }
      if (ghCreatePrChk) {
        ghCreatePrChk.addEventListener("change", () => {
          const on = !!ghCreatePrChk.checked;
          if (ghPrOptionsEl) ghPrOptionsEl.style.display = on ? "flex" : "none";
          const save = { createPr: on };
          if (on) save.prBase = getPrBaseBranch();
          persistGhState(save);
          updateExportCommitEnabled();
        });
      }
      if (ghPrTitleInput) {
        ghPrTitleInput.addEventListener("input", () => {
          persistGhState({ prTitle: ghPrTitleInput.value });
        });
      }
      if (ghPrBodyInput) {
        ghPrBodyInput.addEventListener("input", () => {
          persistGhState({ prBody: ghPrBodyInput.value });
        });
      }
      if (ghFetchPathInput) ghFetchPathInput.addEventListener("input", updateFetchButtonEnabled);
      if (ghFetchTokensBtn) {
        ghFetchTokensBtn.addEventListener("click", () => {
          var _a;
          const branch = getCurrentBranch();
          const path = ((ghFetchPathInput == null ? void 0 : ghFetchPathInput.value) || "").trim().replace(/^\/+/, "");
          if (!currentOwner || !currentRepo) {
            deps.log("Pick a repository first.");
            return;
          }
          if (!branch) {
            deps.log("Pick a branch first.");
            return;
          }
          if (!path) {
            deps.log("Enter a path to fetch (e.g., tokens/tokens.json).");
            return;
          }
          ghImportInFlight = true;
          lastImportTarget = { branch, path };
          setImportStatus("progress", `Fetching ${path} from ${branch}\u2026`);
          updateFetchButtonEnabled();
          deps.log(`GitHub: fetching ${path} from ${currentOwner}/${currentRepo}@${branch}\u2026`);
          const allowHex = !!((_a = pickAllowHexCheckbox()) == null ? void 0 : _a.checked);
          const contexts = deps.getImportContexts();
          const payload = {
            type: "GITHUB_FETCH_TOKENS",
            payload: __spreadValues({
              owner: currentOwner,
              repo: currentRepo,
              branch,
              path,
              allowHexStrings: allowHex
            }, contexts.length > 0 ? { contexts } : {})
          };
          deps.postToPlugin(payload);
          if (contexts.length > 0) {
            deps.log(`GitHub: importing ${contexts.length} selected mode(s) based on current scope.`);
          }
        });
      }
      if (ghExportAndCommitBtn) {
        ghExportAndCommitBtn.addEventListener("click", () => {
          var _a, _b;
          const collectionSelect2 = pickCollectionSelect();
          const modeSelect2 = pickModeSelect();
          const scope = ghScopeAll && ghScopeAll.checked ? "all" : ghScopeTypography && ghScopeTypography.checked ? "typography" : "selected";
          const commitMessage = ((ghCommitMsgInput == null ? void 0 : ghCommitMsgInput.value) || "Update tokens from Figma").trim();
          const normalizedFolder = normalizeFolderInput((ghFolderInput == null ? void 0 : ghFolderInput.value) || "");
          refreshFilenameValidation();
          if (!normalizedFolder.display) {
            deps.log("Pick a destination folder (e.g., tokens/).");
            ghPickFolderBtn == null ? void 0 : ghPickFolderBtn.focus();
            updateExportCommitEnabled();
            return;
          }
          if (!filenameValidation.ok) {
            deps.log(filenameValidation.message);
            ghFilenameInput == null ? void 0 : ghFilenameInput.focus();
            updateExportCommitEnabled();
            return;
          }
          const filenameToUse = filenameValidation.filename;
          setGhFolderDisplay(normalizedFolder.display);
          deps.postToPlugin({
            type: "GITHUB_SET_FOLDER",
            payload: { owner: currentOwner, repo: currentRepo, folder: normalizedFolder.payload }
          });
          persistGhState({ folder: normalizedFolder.payload, filename: filenameToUse });
          const createPr = !!(ghCreatePrChk && ghCreatePrChk.checked);
          const payload = {
            type: "GITHUB_EXPORT_AND_COMMIT",
            payload: {
              owner: currentOwner,
              repo: currentRepo,
              branch: getCurrentBranch(),
              folder: normalizedFolder.payload,
              filename: filenameToUse,
              commitMessage,
              scope,
              styleDictionary: !!((_a = pickStyleDictionaryCheckbox()) == null ? void 0 : _a.checked),
              flatTokens: !!((_b = pickFlatTokensCheckbox()) == null ? void 0 : _b.checked),
              createPr
            }
          };
          if (scope === "selected" && collectionSelect2 && modeSelect2) {
            payload.payload.collection = collectionSelect2.value || "";
            payload.payload.mode = modeSelect2.value || "";
          }
          if (createPr) {
            payload.payload.prBase = getPrBaseBranch();
            payload.payload.prTitle = ((ghPrTitleInput == null ? void 0 : ghPrTitleInput.value) || "").trim();
            payload.payload.prBody = (ghPrBodyInput == null ? void 0 : ghPrBodyInput.value) || "";
          }
          const scopeLabel = scope === "all" ? "all collections" : scope === "typography" ? "typography" : "selected mode";
          const summaryTarget = formatDestinationForLog(normalizedFolder.payload, filenameToUse);
          deps.log(`GitHub: Export summary \u2192 ${summaryTarget} (${scopeLabel})`);
          deps.log(createPr ? "Export, Commit & PR requested\u2026" : "Export & Commit requested\u2026");
          deps.postToPlugin(payload);
        });
      }
      doc.addEventListener("keydown", handleFolderPickerKeydown);
      updateGhStatusUi();
      updateFolderControlsEnabled();
      updateExportCommitEnabled();
      updateFetchButtonEnabled();
    }
    function onGitHubConnectClick() {
      const tokenRaw = readPatFromUi();
      const isMasked = (ghTokenInput == null ? void 0 : ghTokenInput.getAttribute("data-filled")) === "1";
      if (ghIsAuthed && isMasked) return;
      if (!tokenRaw) {
        deps.log("GitHub: Paste a Personal Access Token first.");
        return;
      }
      const remember = !!(ghRememberChk && ghRememberChk.checked);
      deps.log("GitHub: Verifying token\u2026");
      deps.postToPlugin({ type: "GITHUB_SET_TOKEN", payload: { token: tokenRaw, remember } });
    }
    function onGitHubVerifyClick() {
      onGitHubConnectClick();
    }
    function onGitHubLogoutClick() {
      deps.postToPlugin({ type: "GITHUB_FORGET_TOKEN" });
      ghIsAuthed = false;
      ghTokenExpiresAt = null;
      setPatFieldObfuscated(false);
      populateGhRepos([]);
      updateGhStatusUi();
      currentOwner = "";
      currentRepo = "";
      allBranches = [];
      filteredBranches = [];
      desiredBranch = null;
      defaultBranchFromApi = void 0;
      loadedPages = 0;
      hasMorePages = false;
      isFetchingBranches = false;
      if (ghBranchInput) {
        ghBranchInput.value = "";
        branchLastQuery = "";
        branchInputPristine = true;
      }
      if (ghBranchMenu) while (ghBranchMenu.firstChild) ghBranchMenu.removeChild(ghBranchMenu.firstChild);
      closeBranchMenu();
      setBranchDisabled(true, "Pick a repository first\u2026");
      updateBranchCount();
      updateFolderControlsEnabled();
      setGhFolderDisplay("");
      deps.log("GitHub: Logged out.");
    }
    function handleMessage(msg) {
      var _a, _b, _c;
      if (msg.type === "GITHUB_AUTH_RESULT") {
        const p = msg.payload || {};
        ghIsAuthed = !!p.ok;
        ghTokenExpiresAt = typeof p.exp !== "undefined" && p.exp !== null ? p.exp : typeof p.tokenExpiration !== "undefined" && p.tokenExpiration !== null ? p.tokenExpiration : null;
        if (typeof p.remember === "boolean") {
          updateRememberPref(p.remember, false);
        }
        if (ghIsAuthed) {
          setPatFieldObfuscated(true);
          const who = p.login || "unknown";
          const name = p.name ? ` (${p.name})` : "";
          deps.log(`GitHub: Authenticated as ${who}${name}.`);
        } else {
          setPatFieldObfuscated(false);
          const why = p.error ? `: ${p.error}` : ".";
          deps.log(`GitHub: Authentication failed${why}`);
        }
        updateGhStatusUi();
        updateExportCommitEnabled();
        updateFetchButtonEnabled();
        return true;
      }
      if (msg.type === "GITHUB_REPOS") {
        const repos = (_b = (_a = msg.payload) == null ? void 0 : _a.repos) != null ? _b : [];
        populateGhRepos(repos);
        deps.log(`GitHub: Repository list updated (${repos.length}).`);
        return true;
      }
      if (msg.type === "GITHUB_RESTORE_SELECTED") {
        const p = msg.payload || {};
        currentOwner = typeof p.owner === "string" ? p.owner : "";
        currentRepo = typeof p.repo === "string" ? p.repo : "";
        desiredBranch = typeof p.branch === "string" ? p.branch : null;
        if (typeof p.folder === "string") {
          const normalized = normalizeFolderInput(p.folder);
          setGhFolderDisplay(normalized.display);
        }
        if (ghFilenameInput) {
          if (typeof p.filename === "string" && p.filename.trim()) {
            ghFilenameInput.value = p.filename;
          } else if (!ghFilenameInput.value) {
            ghFilenameInput.value = DEFAULT_GITHUB_FILENAME;
          }
        }
        refreshFilenameValidation();
        if (typeof p.commitMessage === "string" && ghCommitMsgInput) {
          ghCommitMsgInput.value = p.commitMessage;
        }
        if (typeof p.scope === "string") {
          if (p.scope === "all" && ghScopeAll) ghScopeAll.checked = true;
          if (p.scope === "selected" && ghScopeSelected) ghScopeSelected.checked = true;
          if (p.scope === "typography" && ghScopeTypography) ghScopeTypography.checked = true;
        }
        const styleDictChk = pickStyleDictionaryCheckbox();
        if (styleDictChk && typeof p.styleDictionary === "boolean") {
          styleDictChk.checked = p.styleDictionary;
        }
        const flatChk = pickFlatTokensCheckbox();
        if (flatChk && typeof p.flatTokens === "boolean") {
          flatChk.checked = p.flatTokens;
        }
        if (typeof p.createPr === "boolean" && ghCreatePrChk) {
          ghCreatePrChk.checked = p.createPr;
          if (ghPrOptionsEl) ghPrOptionsEl.style.display = p.createPr ? "flex" : "none";
        }
        if (typeof p.prTitle === "string" && ghPrTitleInput) ghPrTitleInput.value = p.prTitle;
        if (typeof p.prBody === "string" && ghPrBodyInput) ghPrBodyInput.value = p.prBody;
        updateExportCommitEnabled();
        updateFetchButtonEnabled();
        return true;
      }
      if (msg.type === "GITHUB_BRANCHES") {
        const pl = msg.payload || {};
        const owner = String(pl.owner || "");
        const repo = String(pl.repo || "");
        if (owner !== currentOwner || repo !== currentRepo) return true;
        lastBranchesFetchedAtMs = Date.now();
        loadedPages = Number(pl.page || 1);
        hasMorePages = !!pl.hasMore;
        isFetchingBranches = false;
        if (typeof pl.defaultBranch === "string" && !defaultBranchFromApi) {
          defaultBranchFromApi = pl.defaultBranch;
        }
        if (ghNewBranchBtn) ghNewBranchBtn.disabled = false;
        const names = Array.isArray(pl.branches) ? pl.branches.map((b) => b.name) : [];
        const set = new Set(allBranches);
        for (const n of names) if (n) set.add(n);
        allBranches = Array.from(set).sort((a, b) => a.localeCompare(b));
        applyBranchFilter();
        setBranchDisabled(false);
        updateFolderControlsEnabled();
        const rate = pl.rate;
        if (rate && typeof rate.remaining === "number" && rate.remaining <= 3 && typeof rate.resetEpochSec === "number") {
          const t = new Date(rate.resetEpochSec * 1e3).toLocaleTimeString();
          deps.log(`GitHub: near rate limit; resets ~${t}`);
        }
        deps.log(`Loaded ${names.length} branches (page ${loadedPages}) for ${repo}${hasMorePages ? "\u2026" : ""}`);
        return true;
      }
      if (msg.type === "GITHUB_BRANCHES_ERROR") {
        const pl = msg.payload || {};
        const owner = String(pl.owner || "");
        const repo = String(pl.repo || "");
        if (owner !== currentOwner || repo !== currentRepo) return true;
        isFetchingBranches = false;
        setBranchDisabled(false);
        updateFolderControlsEnabled();
        deps.log(`Branch load failed (status ${pl.status}): ${pl.message || "unknown error"}`);
        if (pl.samlRequired) deps.log("This org requires SSO. Open the repo in your browser and authorize SSO for your token.");
        if (pl.rate && typeof pl.rate.resetEpochSec === "number") {
          const t = new Date(pl.rate.resetEpochSec * 1e3).toLocaleTimeString();
          deps.log(`Rate limit issue; resets ~${t}`);
        }
        return true;
      }
      if (msg.type === "GITHUB_CREATE_BRANCH_RESULT") {
        const pl = msg.payload || {};
        if (ghCreateBranchConfirmBtn) ghCreateBranchConfirmBtn.disabled = false;
        if (typeof pl.ok !== "boolean") return true;
        if (pl.ok) {
          const baseBranch = String(pl.baseBranch || "");
          const newBranch = String(pl.newBranch || "");
          const url = String(pl.html_url || "");
          if (newBranch) {
            const s = new Set(allBranches);
            if (!s.has(newBranch)) {
              s.add(newBranch);
              allBranches = Array.from(s).sort((a, b) => a.localeCompare(b));
            }
            desiredBranch = newBranch;
            if (ghBranchInput) {
              ghBranchInput.value = newBranch;
              branchLastQuery = newBranch;
              branchInputPristine = false;
            }
            applyBranchFilter();
          }
          updateFolderControlsEnabled();
          showNewBranchRow(false);
          if (ghNewBranchName) ghNewBranchName.value = "";
          if (url) {
            deps.log(`Branch created: ${newBranch} (from ${baseBranch})`);
            const logEl2 = deps.getLogElement();
            if (logEl2 && doc) {
              const wrap = doc.createElement("div");
              const a = doc.createElement("a");
              a.href = url;
              a.target = "_blank";
              a.textContent = "View on GitHub";
              wrap.appendChild(a);
              logEl2.appendChild(wrap);
              logEl2.scrollTop = logEl2.scrollHeight;
            }
          } else {
            deps.log(`Branch created: ${newBranch} (from ${baseBranch})`);
          }
          return true;
        }
        const status = (_c = pl.status) != null ? _c : 0;
        const message = pl.message || "unknown error";
        deps.log(`Create branch failed (status ${status}): ${message}`);
        if (pl.samlRequired) {
          deps.log("This org requires SSO. Open the repo in your browser and authorize SSO for your token.");
        } else if (status === 403) {
          if (pl.noPushPermission) {
            deps.log("You do not have push permission to this repository. Ask a maintainer for write access.");
          } else {
            deps.log("Likely a token permission issue:");
            deps.log('\u2022 Classic PAT: add the "repo" scope (or "public_repo" for public repos).');
            deps.log('\u2022 Fine-grained PAT: grant this repository and set "Contents: Read and write".');
          }
        }
        if (pl.rate && typeof pl.rate.resetEpochSec === "number") {
          const t = new Date(pl.rate.resetEpochSec * 1e3).toLocaleTimeString();
          deps.log(`Rate limit issue; resets ~${t}`);
        }
        return true;
      }
      if (msg.type === "GITHUB_FOLDER_LIST_RESULT") {
        const pl = msg.payload || {};
        const path = String(pl.path || "").replace(/^\/+|\/+$/g, "");
        const ok = !!pl.ok;
        const entries = Array.isArray(pl.entries) ? pl.entries : [];
        const message = String(pl.message || "");
        for (let i = 0; i < folderListWaiters.length; i++) {
          if (folderListWaiters[i].path === path) {
            const waiter = folderListWaiters.splice(i, 1)[0];
            if (ok) waiter.resolve({ ok: true, entries });
            else waiter.reject({
              ok: false,
              message: message || `HTTP ${pl.status || 0}`,
              status: typeof pl.status === "number" ? pl.status : void 0
            });
            break;
          }
        }
        return true;
      }
      if (msg.type === "GITHUB_CREATE_FOLDER_RESULT") {
        const pl = msg.payload || {};
        const fp = String(pl.folderPath || "").replace(/^\/+|\/+$/g, "");
        const ok = !!pl.ok;
        const message = String(pl.message || "");
        for (let i = 0; i < folderCreateWaiters.length; i++) {
          if (folderCreateWaiters[i].folderPath === fp) {
            const waiter = folderCreateWaiters.splice(i, 1)[0];
            if (ok) waiter.resolve({ ok: true });
            else waiter.reject({ ok: false, message: message || `HTTP ${pl.status || 0}`, status: pl.status });
            break;
          }
        }
        return true;
      }
      if (msg.type === "GITHUB_COMMIT_RESULT") {
        if (msg.payload.ok) {
          const url = String(msg.payload.commitUrl || "");
          const branch = msg.payload.branch || "";
          const destination = formatDestinationForLog(msg.payload.folder, msg.payload.filename);
          const committedPath = msg.payload.fullPath || destination;
          deps.log(`Commit succeeded (${branch}): ${url || "(no URL)"}`);
          deps.log(`Committed ${committedPath}`);
          if (url) {
            const logEl2 = deps.getLogElement();
            if (logEl2 && doc) {
              const wrap = doc.createElement("div");
              const a = doc.createElement("a");
              a.href = url;
              a.target = "_blank";
              a.textContent = "View commit";
              wrap.appendChild(a);
              logEl2.appendChild(wrap);
              logEl2.scrollTop = logEl2.scrollHeight;
            }
          }
          if (msg.payload.createdPr) {
            const pr = msg.payload.createdPr;
            deps.log(`PR prepared (#${pr.number}) from ${pr.head} \u2192 ${pr.base}`);
          }
        } else {
          const status = typeof msg.payload.status === "number" ? msg.payload.status : 0;
          const message = msg.payload.message || "unknown error";
          const destination = formatDestinationForLog(msg.payload.folder, msg.payload.filename);
          const committedPath = msg.payload.fullPath || destination;
          if (status === 304) {
            deps.log(`Commit skipped: ${message} (${committedPath})`);
          } else {
            deps.log(`Commit failed (${status}): ${message} (${committedPath})`);
          }
        }
        return true;
      }
      if (msg.type === "GITHUB_PR_RESULT") {
        if (msg.payload.ok) {
          deps.log(`PR created: #${msg.payload.number} (${msg.payload.head} \u2192 ${msg.payload.base})`);
          const url = msg.payload.url;
          if (url) {
            const logEl2 = deps.getLogElement();
            if (logEl2 && doc) {
              const wrap = doc.createElement("div");
              const a = doc.createElement("a");
              a.href = url;
              a.target = "_blank";
              a.textContent = "View PR";
              wrap.appendChild(a);
              logEl2.appendChild(wrap);
              logEl2.scrollTop = logEl2.scrollHeight;
            }
          }
        } else {
          deps.log(`PR creation failed (${msg.payload.status || 0}): ${msg.payload.message || "unknown error"}`);
        }
        return true;
      }
      if (msg.type === "GITHUB_FETCH_TOKENS_RESULT") {
        ghImportInFlight = false;
        if (msg.payload.ok) {
          deps.log(`Imported tokens from ${msg.payload.path} (${msg.payload.branch})`);
          const branch = String(msg.payload.branch || "");
          const path = String(msg.payload.path || "");
          lastImportTarget = { branch, path };
          setImportStatus("success", `Imported tokens from ${branch}:${path}.`);
        } else {
          deps.log(`GitHub fetch failed (${msg.payload.status || 0}): ${msg.payload.message || "unknown error"}`);
          const status = typeof msg.payload.status === "number" ? msg.payload.status : 0;
          const message = msg.payload.message || "Unknown error";
          const branch = String(msg.payload.branch || "");
          const path = String(msg.payload.path || "");
          lastImportTarget = { branch, path };
          setImportStatus("error", `GitHub import failed (${status}): ${message}`);
        }
        updateFetchButtonEnabled();
        return true;
      }
      return false;
    }
    function onSelectionChange() {
      updateExportCommitEnabled();
    }
    function applyRememberPrefFromPlugin(pref) {
      updateRememberPref(pref, false);
    }
    return {
      attach,
      handleMessage,
      onSelectionChange,
      setRememberPref: applyRememberPrefFromPlugin
    };
  }

  // src/app/ui.ts
  var logEl = null;
  var rawEl = null;
  var exportAllChk = null;
  var collectionSelect = null;
  var modeSelect = null;
  var fileInput = null;
  var importBtn = null;
  var exportBtn = null;
  var exportTypographyBtn = null;
  var exportPickers = null;
  var refreshBtn = null;
  var shellEl = null;
  var drawerToggleBtn = null;
  var resizeHandleEl = null;
  var w3cPreviewEl = null;
  var copyRawBtn = null;
  var copyW3cBtn = null;
  var copyLogBtn = null;
  var allowHexChk = null;
  var styleDictionaryChk = null;
  var flatTokensChk = null;
  var githubRememberChk = null;
  var importScopeOverlay = null;
  var importScopeBody = null;
  var importScopeConfirmBtn = null;
  var importScopeCancelBtn = null;
  var importScopeRememberChk = null;
  var importScopeMissingEl = null;
  var importScopeSummaryEl = null;
  var importScopeSummaryTextEl = null;
  var importScopeClearBtn = null;
  var importSkipLogListEl = null;
  var importSkipLogEmptyEl = null;
  var IMPORT_PREF_KEY = "dtcg.importPreference.v1";
  var IMPORT_LOG_KEY = "dtcg.importLog.v1";
  var importPreference = null;
  var importLogEntries = [];
  var importScopeModalState = null;
  var lastImportSelection = [];
  var systemDarkMode = false;
  function applyTheme() {
    const effective = systemDarkMode ? "dark" : "light";
    if (effective === "light") {
      document.documentElement.setAttribute("data-theme", "light");
    } else {
      document.documentElement.removeAttribute("data-theme");
    }
  }
  function prettyExportName(original) {
    const name = original && typeof original === "string" ? original : "tokens.json";
    const m = name.match(/^(.*)_mode=(.*)\.tokens\.json$/);
    if (m) {
      const collection = m[1].trim();
      const mode = m[2].trim();
      return `${collection} - ${mode}.json`;
    }
    return name.endsWith(".json") ? name : name + ".json";
  }
  var pendingSave = null;
  function supportsFilePicker() {
    return typeof window.showSaveFilePicker === "function";
  }
  async function beginPendingSave(suggestedName) {
    try {
      if (!supportsFilePicker()) return false;
      const handle = await window.showSaveFilePicker({
        suggestedName,
        types: [{ description: "JSON", accept: { "application/json": [".json"] } }]
      });
      const writable = await handle.createWritable();
      pendingSave = { writable, name: suggestedName };
      return true;
    } catch (e) {
      pendingSave = null;
      return false;
    }
  }
  async function finishPendingSave(text) {
    if (!pendingSave) return false;
    try {
      await pendingSave.writable.write(new Blob([text], { type: "application/json" }));
      await pendingSave.writable.close();
      return true;
    } catch (e) {
      try {
        await pendingSave.writable.close();
      } catch (e2) {
      }
      return false;
    } finally {
      pendingSave = null;
    }
  }
  function triggerJsonDownload(filename, text) {
    try {
      const blob = new Blob([text], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.style.position = "absolute";
      a.style.left = "-9999px";
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        URL.revokeObjectURL(url);
        a.remove();
      }, 0);
    } catch (e) {
    }
  }
  function copyElText(el, label) {
    var _a;
    if (!el) return;
    try {
      const text = (_a = el.textContent) != null ? _a : "";
      if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
        navigator.clipboard.writeText(text).then(() => {
          log(`Copied ${label} to clipboard.`);
        }).catch(() => {
          throw new Error("clipboard write failed");
        });
        return;
      }
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.style.position = "fixed";
      ta.style.opacity = "0";
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, ta.value.length);
      const ok = document.execCommand("copy");
      document.body.removeChild(ta);
      if (ok) log(`Copied ${label} to clipboard (${text.length} chars).`);
      else throw new Error("execCommand(copy) returned false");
    } catch (e) {
      log(`Could not copy ${label}.`);
    }
  }
  function normalizeContextList(list) {
    var _a;
    const seen = /* @__PURE__ */ new Set();
    const out = [];
    for (let i = 0; i < list.length; i++) {
      const raw = String((_a = list[i]) != null ? _a : "").trim();
      if (!raw) continue;
      if (seen.has(raw)) continue;
      seen.add(raw);
      out.push(raw);
    }
    out.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    return out;
  }
  function contextsEqual(a, b) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
    return true;
  }
  function saveImportPreference() {
    var _a, _b;
    if (!importPreference || importPreference.contexts.length === 0) {
      try {
        (_a = window.localStorage) == null ? void 0 : _a.removeItem(IMPORT_PREF_KEY);
      } catch (e) {
      }
      return;
    }
    try {
      (_b = window.localStorage) == null ? void 0 : _b.setItem(IMPORT_PREF_KEY, JSON.stringify(importPreference));
    } catch (e) {
    }
  }
  function loadImportPreference() {
    var _a;
    importPreference = null;
    try {
      const raw = (_a = window.localStorage) == null ? void 0 : _a.getItem(IMPORT_PREF_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object") return;
      const ctxs = Array.isArray(parsed.contexts) ? normalizeContextList(parsed.contexts) : [];
      const ts = typeof parsed.updatedAt === "number" ? Number(parsed.updatedAt) : Date.now();
      if (ctxs.length > 0) importPreference = { contexts: ctxs, updatedAt: ts };
    } catch (e) {
      importPreference = null;
    }
  }
  function setImportPreference(contexts) {
    const normalized = normalizeContextList(contexts);
    if (normalized.length === 0) {
      clearImportPreference(false);
      return;
    }
    const same = importPreference && contextsEqual(importPreference.contexts, normalized);
    importPreference = { contexts: normalized, updatedAt: Date.now() };
    saveImportPreference();
    renderImportPreferenceSummary();
    if (!same) log("Remembered import selection for future imports.");
  }
  function clearImportPreference(logChange) {
    var _a;
    if (!importPreference) return;
    importPreference = null;
    try {
      (_a = window.localStorage) == null ? void 0 : _a.removeItem(IMPORT_PREF_KEY);
    } catch (e) {
    }
    renderImportPreferenceSummary();
    if (logChange) log("Cleared remembered import selection. Next import will prompt for modes.");
  }
  function formatContextList(contexts) {
    const normalized = normalizeContextList(contexts);
    if (normalized.length === 0) return "All contexts";
    const grouped = /* @__PURE__ */ new Map();
    for (let i = 0; i < normalized.length; i++) {
      const ctx = normalized[i];
      const slash = ctx.indexOf("/");
      const collection = slash >= 0 ? ctx.slice(0, slash) : ctx;
      const mode = slash >= 0 ? ctx.slice(slash + 1) : "Mode 1";
      const coll = collection ? collection : "Tokens";
      const modes = grouped.get(coll) || [];
      if (!grouped.has(coll)) grouped.set(coll, modes);
      if (!modes.includes(mode)) modes.push(mode);
    }
    const parts = [];
    const collections = Array.from(grouped.keys()).sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    for (let i = 0; i < collections.length; i++) {
      const coll = collections[i];
      const modes = grouped.get(coll) || [];
      modes.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.push(`${coll} (${modes.join(", ")})`);
    }
    return parts.join("; ");
  }
  function renderImportPreferenceSummary() {
    if (!importScopeSummaryEl || !importScopeSummaryTextEl) return;
    const hasPref = !!importPreference && importPreference.contexts.length > 0;
    if (importScopeClearBtn) importScopeClearBtn.disabled = !hasPref;
    if (!hasPref) {
      importScopeSummaryEl.hidden = true;
      return;
    }
    importScopeSummaryEl.hidden = false;
    const when = new Date(importPreference.updatedAt).toLocaleString();
    importScopeSummaryTextEl.textContent = `Remembered import scope (${when}): ${formatContextList(importPreference.contexts)}.`;
  }
  function saveImportLog() {
    var _a;
    try {
      (_a = window.localStorage) == null ? void 0 : _a.setItem(IMPORT_LOG_KEY, JSON.stringify(importLogEntries));
    } catch (e) {
    }
  }
  function loadImportLog() {
    var _a;
    importLogEntries = [];
    try {
      const raw = (_a = window.localStorage) == null ? void 0 : _a.getItem(IMPORT_LOG_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) return;
      for (let i = 0; i < parsed.length; i++) {
        const entry = parsed[i];
        if (!entry || typeof entry !== "object") continue;
        const timestamp = typeof entry.timestamp === "number" ? Number(entry.timestamp) : null;
        const summary = entry.summary;
        const source = entry.source === "github" ? "github" : entry.source === "local" ? "local" : void 0;
        if (!timestamp || !summary || typeof summary !== "object") continue;
        if (!Array.isArray(summary.appliedContexts) || !Array.isArray(summary.availableContexts)) continue;
        if (!Array.isArray(summary.tokensWithRemovedContexts)) {
          summary.tokensWithRemovedContexts = [];
        }
        if (!Array.isArray(summary.skippedContexts)) {
          summary.skippedContexts = [];
        }
        if (!Array.isArray(summary.missingRequestedContexts)) {
          summary.missingRequestedContexts = [];
        }
        if (typeof summary.createdStyles !== "number" || !isFinite(summary.createdStyles)) {
          summary.createdStyles = 0;
        }
        importLogEntries.push({ timestamp, summary, source });
      }
      importLogEntries.sort((a, b) => a.timestamp - b.timestamp);
    } catch (e) {
      importLogEntries = [];
    }
  }
  function renderImportLog() {
    if (!(importSkipLogListEl && importSkipLogEmptyEl)) return;
    importSkipLogListEl.innerHTML = "";
    if (!importLogEntries || importLogEntries.length === 0) {
      importSkipLogEmptyEl.hidden = false;
      return;
    }
    importSkipLogEmptyEl.hidden = true;
    for (let idx = importLogEntries.length - 1; idx >= 0; idx--) {
      const entry = importLogEntries[idx];
      const container = document.createElement("div");
      container.className = "import-skip-log-entry";
      const header = document.createElement("div");
      header.className = "import-skip-log-entry-header";
      const label = entry.source === "github" ? "GitHub import" : "Manual import";
      header.textContent = `${label} \u2022 ${new Date(entry.timestamp).toLocaleString()}`;
      container.appendChild(header);
      const stats = document.createElement("div");
      stats.className = "import-skip-log-entry-stats";
      const tokensText = `Imported ${entry.summary.importedTokens} of ${entry.summary.totalTokens} tokens.`;
      const stylesCreated = typeof entry.summary.createdStyles === "number" ? entry.summary.createdStyles : void 0;
      if (typeof stylesCreated === "number") {
        const stylesLabel = stylesCreated === 1 ? "style" : "styles";
        stats.textContent = `${tokensText} ${stylesCreated} ${stylesLabel} created.`;
      } else {
        stats.textContent = tokensText;
      }
      container.appendChild(stats);
      const contextsLine = document.createElement("div");
      contextsLine.className = "import-skip-log-entry-contexts";
      contextsLine.textContent = "Applied: " + formatContextList(entry.summary.appliedContexts);
      container.appendChild(contextsLine);
      if (entry.summary.skippedContexts.length > 0) {
        const skippedLine = document.createElement("div");
        skippedLine.className = "import-skip-log-entry-contexts";
        skippedLine.textContent = "Skipped modes: " + formatContextList(entry.summary.skippedContexts.map((s) => s.context));
        container.appendChild(skippedLine);
      }
      if (entry.summary.missingRequestedContexts.length > 0) {
        const missingLine = document.createElement("div");
        missingLine.className = "import-skip-log-entry-note";
        missingLine.textContent = "Not found in file: " + formatContextList(entry.summary.missingRequestedContexts);
        container.appendChild(missingLine);
      }
      if (entry.summary.selectionFallbackToAll) {
        const fallbackLine = document.createElement("div");
        fallbackLine.className = "import-skip-log-entry-note";
        fallbackLine.textContent = "Requested modes were missing; imported all contexts instead.";
        container.appendChild(fallbackLine);
      }
      if (entry.summary.tokensWithRemovedContexts.length > 0) {
        const tokenList = document.createElement("ul");
        tokenList.className = "import-skip-log-token-list";
        const maxTokens = Math.min(entry.summary.tokensWithRemovedContexts.length, 10);
        for (let t = 0; t < maxTokens; t++) {
          const tok = entry.summary.tokensWithRemovedContexts[t];
          const li = document.createElement("li");
          const removedLabel = tok.removedContexts.length > 0 ? formatContextList(tok.removedContexts) : "none";
          const keptLabel = tok.keptContexts.length > 0 ? formatContextList(tok.keptContexts) : "";
          li.textContent = `${tok.path} \u2014 skipped ${removedLabel}${keptLabel ? "; kept " + keptLabel : ""}`;
          tokenList.appendChild(li);
        }
        if (entry.summary.tokensWithRemovedContexts.length > maxTokens) {
          const more = document.createElement("li");
          more.textContent = `\u2026and ${entry.summary.tokensWithRemovedContexts.length - maxTokens} more token(s).`;
          tokenList.appendChild(more);
        }
        container.appendChild(tokenList);
      }
      if (entry.summary.skippedContexts.length > 0 && importPreference && importPreference.contexts.length > 0) {
        const tip = document.createElement("div");
        tip.className = "import-skip-log-entry-note";
        tip.textContent = "Tip: Clear the remembered import selection to restore skipped modes.";
        container.appendChild(tip);
      }
      importSkipLogListEl.appendChild(container);
    }
  }
  function addImportLogEntry(entry) {
    importLogEntries.push(entry);
    if (importLogEntries.length > 10) {
      importLogEntries = importLogEntries.slice(importLogEntries.length - 10);
    }
    saveImportLog();
    renderImportLog();
  }
  function collectContextsFromJson(root) {
    const grouped = /* @__PURE__ */ new Map();
    function visit(node, path) {
      if (Array.isArray(node)) {
        for (let i = 0; i < node.length; i++) visit(node[i], path);
        return;
      }
      if (!node || typeof node !== "object") return;
      const obj = node;
      if (Object.prototype.hasOwnProperty.call(obj, "$value")) {
        const rawCollection = path[0] ? String(path[0]).trim() : "Tokens";
        let mode = "Mode 1";
        try {
          const ext = obj["$extensions"];
          if (ext && typeof ext === "object") {
            const cf = ext["com.figma"];
            if (cf && typeof cf === "object" && typeof cf.modeName === "string") {
              const candidate = String(cf.modeName).trim();
              if (candidate) mode = candidate;
            }
          }
        } catch (e) {
        }
        const collection = rawCollection ? rawCollection : "Tokens";
        const set = grouped.get(collection) || /* @__PURE__ */ new Set();
        if (!grouped.has(collection)) grouped.set(collection, set);
        set.add(mode);
        return;
      }
      for (const key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;
        if (key.startsWith("$")) continue;
        visit(obj[key], path.concat(String(key)));
      }
    }
    visit(root, []);
    const options = [];
    const collections = Array.from(grouped.keys()).sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    for (let i = 0; i < collections.length; i++) {
      const collection = collections[i];
      const modes = Array.from(grouped.get(collection) || []).sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      for (let j = 0; j < modes.length; j++) {
        const mode = modes[j];
        options.push({ context: `${collection}/${mode}`, collection, mode });
      }
    }
    return options;
  }
  function updateImportScopeConfirmState() {
    if (!importScopeModalState) return;
    const state = importScopeModalState;
    let allCollectionsSelected = true;
    for (let i = 0; i < state.collections.length; i++) {
      const collection = state.collections[i];
      const inputs = state.inputsByCollection.get(collection) || [];
      if (!inputs.some((input) => input.checked)) {
        allCollectionsSelected = false;
        break;
      }
    }
    if (importScopeConfirmBtn) {
      importScopeConfirmBtn.disabled = !allCollectionsSelected;
      const label = state.collections.length > 1 ? "Import selected modes" : "Import selected mode";
      importScopeConfirmBtn.textContent = label;
    }
  }
  var importScopeKeyListenerAttached = false;
  function handleImportScopeKeydown(ev) {
    if (ev.key === "Escape") {
      ev.preventDefault();
      closeImportScopeModal();
    }
  }
  function openImportScopeModal(opts) {
    var _a;
    if (!importScopeOverlay || !importScopeBody || !importScopeConfirmBtn || !importScopeCancelBtn) {
      opts.onConfirm(opts.initialSelection, opts.rememberInitially);
      return;
    }
    importScopeBody.innerHTML = "";
    const grouped = /* @__PURE__ */ new Map();
    for (let i = 0; i < opts.options.length; i++) {
      const option = opts.options[i];
      const list = grouped.get(option.collection) || [];
      if (!grouped.has(option.collection)) grouped.set(option.collection, list);
      list.push(option);
    }
    const collections = Array.from(grouped.keys()).sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    importScopeModalState = {
      options: opts.options,
      collections,
      inputs: [],
      inputsByCollection: /* @__PURE__ */ new Map(),
      onConfirm: opts.onConfirm
    };
    const initialSelectionsByCollection = /* @__PURE__ */ new Map();
    for (let i = 0; i < opts.initialSelection.length; i++) {
      const ctx = opts.initialSelection[i];
      const match = opts.options.find((opt) => opt.context === ctx);
      if (match) initialSelectionsByCollection.set(match.collection, match.context);
    }
    for (let i = 0; i < collections.length; i++) {
      const collection = collections[i];
      const groupEl = document.createElement("div");
      groupEl.className = "import-scope-group";
      const heading = document.createElement("h3");
      heading.textContent = collection;
      groupEl.appendChild(heading);
      const modes = (grouped.get(collection) || []).sort((a, b) => a.mode < b.mode ? -1 : a.mode > b.mode ? 1 : 0);
      const defaultContext = initialSelectionsByCollection.get(collection) || ((_a = modes[0]) == null ? void 0 : _a.context) || null;
      const radioName = `importScopeMode_${i}`;
      for (let j = 0; j < modes.length; j++) {
        const opt = modes[j];
        const label = document.createElement("label");
        label.className = "import-scope-mode";
        const radio = document.createElement("input");
        radio.type = "radio";
        radio.name = radioName;
        radio.value = opt.context;
        radio.checked = defaultContext === opt.context;
        radio.addEventListener("change", updateImportScopeConfirmState);
        importScopeModalState.inputs.push(radio);
        const list = importScopeModalState.inputsByCollection.get(collection) || [];
        if (!importScopeModalState.inputsByCollection.has(collection)) {
          importScopeModalState.inputsByCollection.set(collection, list);
        }
        list.push(radio);
        const span = document.createElement("span");
        span.textContent = opt.mode;
        label.appendChild(radio);
        label.appendChild(span);
        groupEl.appendChild(label);
      }
      importScopeBody.appendChild(groupEl);
    }
    if (importScopeRememberChk) importScopeRememberChk.checked = opts.rememberInitially;
    if (importScopeMissingEl) {
      if (opts.missingPreferred.length > 0) {
        importScopeMissingEl.hidden = false;
        importScopeMissingEl.textContent = "Previously remembered modes not present in this file: " + formatContextList(opts.missingPreferred);
      } else {
        importScopeMissingEl.hidden = true;
        importScopeMissingEl.textContent = "";
      }
    }
    updateImportScopeConfirmState();
    importScopeOverlay.hidden = false;
    importScopeOverlay.classList.add("is-open");
    importScopeOverlay.setAttribute("aria-hidden", "false");
    if (!importScopeKeyListenerAttached) {
      window.addEventListener("keydown", handleImportScopeKeydown, true);
      importScopeKeyListenerAttached = true;
    }
    if (importScopeConfirmBtn) importScopeConfirmBtn.focus();
  }
  function closeImportScopeModal() {
    if (!importScopeOverlay) return;
    importScopeOverlay.classList.remove("is-open");
    importScopeOverlay.hidden = true;
    importScopeOverlay.setAttribute("aria-hidden", "true");
    if (importScopeKeyListenerAttached) {
      window.removeEventListener("keydown", handleImportScopeKeydown, true);
      importScopeKeyListenerAttached = false;
    }
    importScopeModalState = null;
  }
  function performImport(json, allowHex, contexts) {
    const normalized = normalizeContextList(contexts);
    const payload = normalized.length > 0 ? { type: "IMPORT_DTCG", payload: { json, allowHexStrings: allowHex, contexts: normalized } } : { type: "IMPORT_DTCG", payload: { json, allowHexStrings: allowHex } };
    postToPlugin(payload);
    lastImportSelection = normalized.slice();
    const label = normalized.length > 0 ? formatContextList(normalized) : "all contexts";
    log(`Import requested (${label}).`);
  }
  function startImportFlow(json, allowHex) {
    const options = collectContextsFromJson(json);
    if (options.length === 0) {
      performImport(json, allowHex, []);
      return;
    }
    const grouped = /* @__PURE__ */ new Map();
    for (let i = 0; i < options.length; i++) {
      const option = options[i];
      const list = grouped.get(option.collection) || [];
      if (!grouped.has(option.collection)) grouped.set(option.collection, list);
      list.push(option);
    }
    const availableSet = new Set(options.map((opt) => opt.context));
    const missingPreferred = [];
    let rememberInitially = false;
    const initialSelectionsByCollection = /* @__PURE__ */ new Map();
    if (importPreference && importPreference.contexts.length > 0) {
      for (let i = 0; i < importPreference.contexts.length; i++) {
        const ctx = importPreference.contexts[i];
        if (availableSet.has(ctx)) {
          const match = options.find((opt) => opt.context === ctx);
          if (match) {
            initialSelectionsByCollection.set(match.collection, match.context);
            rememberInitially = true;
          }
        } else {
          missingPreferred.push(ctx);
        }
      }
    }
    const collections = Array.from(grouped.keys()).sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    for (let i = 0; i < collections.length; i++) {
      const collection = collections[i];
      if (!initialSelectionsByCollection.has(collection)) {
        const modes = (grouped.get(collection) || []).sort((a, b) => a.mode < b.mode ? -1 : a.mode > b.mode ? 1 : 0);
        if (modes.length > 0) initialSelectionsByCollection.set(collection, modes[0].context);
      }
    }
    const initialSelection = collections.map((collection) => initialSelectionsByCollection.get(collection)).filter((ctx) => typeof ctx === "string");
    const requiresChoice = collections.some((collection) => {
      const list = grouped.get(collection) || [];
      return list.length > 1;
    });
    if (!requiresChoice) {
      performImport(json, allowHex, initialSelection);
      return;
    }
    openImportScopeModal({
      options,
      initialSelection,
      rememberInitially,
      missingPreferred,
      onConfirm: (selected, remember) => {
        if (remember) setImportPreference(selected);
        else if (importPreference) clearImportPreference(true);
        performImport(json, allowHex, selected);
      }
    });
  }
  function getPreferredImportContexts() {
    if (importPreference && importPreference.contexts.length > 0) return importPreference.contexts.slice();
    if (lastImportSelection.length > 0) return lastImportSelection.slice();
    return [];
  }
  function postResize(width, height) {
    const w = Math.max(720, Math.min(1600, Math.floor(width)));
    const h = Math.max(420, Math.min(1200, Math.floor(height)));
    postToPlugin({ type: "UI_RESIZE", payload: { width: w, height: h } });
  }
  var resizeTracking = null;
  var resizeQueued = null;
  var resizeRaf = 0;
  function queueResize(width, height) {
    resizeQueued = { width, height };
    if (resizeRaf !== 0) return;
    resizeRaf = window.requestAnimationFrame(() => {
      resizeRaf = 0;
      if (!resizeQueued) return;
      postResize(resizeQueued.width, resizeQueued.height);
      resizeQueued = null;
    });
  }
  function applyResizeDelta(ev) {
    if (!resizeTracking || ev.pointerId !== resizeTracking.pointerId) return;
    const dx = ev.clientX - resizeTracking.startX;
    const dy = ev.clientY - resizeTracking.startY;
    const nextW = resizeTracking.startWidth + dx;
    const nextH = resizeTracking.startHeight + dy;
    queueResize(nextW, nextH);
    ev.preventDefault();
  }
  function endResize(ev) {
    if (!resizeTracking || ev.pointerId !== resizeTracking.pointerId) return;
    applyResizeDelta(ev);
    window.removeEventListener("pointermove", handleResizeMove, true);
    window.removeEventListener("pointerup", endResize, true);
    window.removeEventListener("pointercancel", cancelResize, true);
    if (resizeHandleEl) {
      try {
        resizeHandleEl.releasePointerCapture(resizeTracking.pointerId);
      } catch (e) {
      }
    }
    resizeTracking = null;
  }
  function cancelResize(ev) {
    if (!resizeTracking || ev.pointerId !== resizeTracking.pointerId) return;
    window.removeEventListener("pointermove", handleResizeMove, true);
    window.removeEventListener("pointerup", endResize, true);
    window.removeEventListener("pointercancel", cancelResize, true);
    if (resizeHandleEl) {
      try {
        resizeHandleEl.releasePointerCapture(resizeTracking.pointerId);
      } catch (e) {
      }
    }
    resizeTracking = null;
  }
  function handleResizeMove(ev) {
    applyResizeDelta(ev);
  }
  function autoFitOnce() {
    if (typeof document === "undefined") return;
    const contentW = Math.max(
      document.documentElement.scrollWidth,
      document.body ? document.body.scrollWidth : 0
    );
    const contentH = Math.max(
      document.documentElement.scrollHeight,
      document.body ? document.body.scrollHeight : 0
    );
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const needsW = contentW > vw ? contentW : vw;
    const needsH = contentH > vh ? contentH : vh;
    if (needsW > vw || needsH > vh) postResize(needsW, needsH);
  }
  var currentCollections = [];
  function log(msg) {
    const t = (/* @__PURE__ */ new Date()).toLocaleTimeString();
    const line = document.createElement("div");
    line.textContent = "[" + t + "] " + msg;
    if (logEl) {
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
    }
  }
  function postToPlugin(message) {
    parent.postMessage({ pluginMessage: message }, "*");
  }
  var githubUi = createGithubUi({
    postToPlugin: (message) => postToPlugin(message),
    log: (message) => log(message),
    getLogElement: () => logEl,
    getCollectionSelect: () => collectionSelect,
    getModeSelect: () => modeSelect,
    getAllowHexCheckbox: () => allowHexChk,
    getStyleDictionaryCheckbox: () => styleDictionaryChk,
    getFlatTokensCheckbox: () => flatTokensChk,
    getImportContexts: () => getPreferredImportContexts()
  });
  function clearSelect(sel) {
    while (sel.options.length > 0) sel.remove(0);
  }
  function setDisabledStates() {
    if (importBtn && fileInput) {
      const hasFile = !!(fileInput.files && fileInput.files.length > 0);
      importBtn.disabled = !hasFile;
    }
    if (exportBtn && exportAllChk && collectionSelect && modeSelect && exportPickers) {
      const exportAll = !!exportAllChk.checked;
      if (exportAll) {
        exportBtn.disabled = false;
        exportPickers.style.opacity = "0.5";
      } else {
        exportPickers.style.opacity = "1";
        const hasSelection = !!collectionSelect.value && !!modeSelect.value;
        exportBtn.disabled = !hasSelection;
      }
    }
    if (exportTypographyBtn) {
      exportTypographyBtn.disabled = false;
    }
  }
  function populateCollections(data) {
    currentCollections = data.collections;
    if (!(collectionSelect && modeSelect)) return;
    clearSelect(collectionSelect);
    for (let i = 0; i < data.collections.length; i++) {
      const c = data.collections[i];
      const opt = document.createElement("option");
      opt.value = c.name;
      opt.textContent = c.name;
      collectionSelect.appendChild(opt);
    }
    onCollectionChange();
  }
  function onCollectionChange() {
    if (!(collectionSelect && modeSelect)) return;
    const selected = collectionSelect.value;
    clearSelect(modeSelect);
    let firstModeSet = false;
    for (let i = 0; i < currentCollections.length; i++) {
      const c = currentCollections[i];
      if (c.name === selected) {
        for (let j = 0; j < c.modes.length; j++) {
          const m = c.modes[j];
          const opt = document.createElement("option");
          opt.value = m.name;
          opt.textContent = m.name;
          modeSelect.appendChild(opt);
        }
        if (modeSelect.options.length > 0 && modeSelect.selectedIndex === -1) {
          modeSelect.selectedIndex = 0;
          firstModeSet = true;
        }
        break;
      }
    }
    setDisabledStates();
    githubUi.onSelectionChange();
    if (firstModeSet) requestPreviewForCurrent();
  }
  function applyLastSelection(last) {
    if (!last || !(collectionSelect && modeSelect)) return;
    let found = false;
    for (let i = 0; i < collectionSelect.options.length; i++) {
      if (collectionSelect.options[i].value === last.collection) {
        collectionSelect.selectedIndex = i;
        found = true;
        break;
      }
    }
    onCollectionChange();
    if (found) {
      for (let j = 0; j < modeSelect.options.length; j++) {
        if (modeSelect.options[j].value === last.mode) {
          modeSelect.selectedIndex = j;
          break;
        }
      }
    }
    setDisabledStates();
  }
  function prettyJson(obj) {
    try {
      return JSON.stringify(obj, null, 2);
    } catch (e) {
      return String(obj);
    }
  }
  function requestPreviewForCurrent() {
    if (!(collectionSelect && modeSelect)) return;
    const collection = collectionSelect.value || "";
    const mode = modeSelect.value || "";
    if (!collection || !mode) {
      if (w3cPreviewEl) w3cPreviewEl.textContent = "{ /* select a collection & mode to preview */ }";
      return;
    }
    const styleDictionary = !!(styleDictionaryChk && styleDictionaryChk.checked);
    const flatTokens = !!(flatTokensChk && flatTokensChk.checked);
    postToPlugin({
      type: "PREVIEW_REQUEST",
      payload: { collection, mode, styleDictionary, flatTokens }
    });
  }
  window.addEventListener("message", async (event) => {
    var _a, _b, _c, _d, _e;
    const data = event.data;
    if (!data || typeof data !== "object") return;
    let msg = null;
    if (data.pluginMessage && typeof data.pluginMessage === "object") {
      const maybe = data.pluginMessage;
      if (maybe && typeof maybe.type === "string") msg = maybe;
    }
    if (!msg) return;
    if (msg.type === "ERROR") {
      log("ERROR: " + ((_b = (_a = msg.payload) == null ? void 0 : _a.message) != null ? _b : ""));
      return;
    }
    if (msg.type === "INFO") {
      log((_d = (_c = msg.payload) == null ? void 0 : _c.message) != null ? _d : "");
      return;
    }
    if (msg.type === "IMPORT_SUMMARY") {
      const summary = msg.payload.summary;
      if (summary && Array.isArray(summary.appliedContexts)) {
        lastImportSelection = summary.appliedContexts.slice();
      } else {
        lastImportSelection = [];
      }
      addImportLogEntry({ timestamp: msg.payload.timestamp, source: msg.payload.source, summary });
      renderImportPreferenceSummary();
      return;
    }
    if (githubUi.handleMessage(msg)) return;
    if (msg.type === "EXPORT_RESULT") {
      const files = Array.isArray((_e = msg.payload) == null ? void 0 : _e.files) ? msg.payload.files : [];
      if (files.length === 0) {
        log("Nothing to export.");
        return;
      }
      if (pendingSave && files.length === 1) {
        const only = files[0];
        const fname = prettyExportName(only == null ? void 0 : only.name);
        const text = prettyJson(only == null ? void 0 : only.json);
        const ok = await finishPendingSave(text);
        if (ok) {
          log("Saved " + fname + " via file picker.");
          const div = document.createElement("div");
          const link = document.createElement("a");
          link.href = "#";
          link.textContent = "Download " + fname + " again";
          link.addEventListener("click", (e) => {
            e.preventDefault();
            triggerJsonDownload(fname, text);
          });
          if (logEl) {
            div.appendChild(link);
            logEl.appendChild(div);
            logEl.scrollTop = logEl.scrollHeight;
          }
          log("Export ready.");
          return;
        }
        log("Could not write via file picker; falling back to download links.");
      }
      setDrawerOpen(true);
      for (let k = 0; k < files.length; k++) {
        const f = files[k];
        const fname = prettyExportName(f == null ? void 0 : f.name);
        const text = prettyJson(f == null ? void 0 : f.json);
        triggerJsonDownload(fname, text);
        const div = document.createElement("div");
        const link = document.createElement("a");
        link.href = "#";
        link.textContent = "Download " + fname;
        link.addEventListener("click", (e) => {
          e.preventDefault();
          triggerJsonDownload(fname, text);
        });
        if (logEl) {
          div.appendChild(link);
          logEl.appendChild(div);
          logEl.scrollTop = logEl.scrollHeight;
        }
      }
      log("Export ready.");
      return;
    }
    if (msg.type === "W3C_PREVIEW") {
      const displayName = prettyExportName(msg.payload.name);
      const header = `/* ${displayName} */
`;
      if (w3cPreviewEl) w3cPreviewEl.textContent = header + prettyJson(msg.payload.json);
      return;
    }
    if (msg.type === "COLLECTIONS_DATA") {
      populateCollections({ collections: msg.payload.collections });
      if (exportAllChk) exportAllChk.checked = !!msg.payload.exportAllPref;
      if (styleDictionaryChk && typeof msg.payload.styleDictionaryPref === "boolean") {
        styleDictionaryChk.checked = !!msg.payload.styleDictionaryPref;
      }
      if (flatTokensChk && typeof msg.payload.flatTokensPref === "boolean") {
        flatTokensChk.checked = !!msg.payload.flatTokensPref;
      }
      if (allowHexChk && typeof msg.payload.allowHexPref === "boolean") {
        allowHexChk.checked = !!msg.payload.allowHexPref;
      }
      if (typeof msg.payload.githubRememberPref === "boolean") {
        if (githubRememberChk) githubRememberChk.checked = msg.payload.githubRememberPref;
      }
      const last = msg.payload.last;
      applyLastSelection(last);
      setDisabledStates();
      requestPreviewForCurrent();
      return;
    }
    if (msg.type === "RAW_COLLECTIONS_TEXT") {
      if (rawEl) rawEl.textContent = msg.payload.text;
      return;
    }
  });
  document.addEventListener("DOMContentLoaded", () => {
    if (typeof document === "undefined") return;
    logEl = document.getElementById("log");
    rawEl = document.getElementById("raw");
    exportAllChk = document.getElementById("exportAllChk");
    collectionSelect = document.getElementById("collectionSelect");
    modeSelect = document.getElementById("modeSelect");
    fileInput = document.getElementById("file");
    importBtn = document.getElementById("importBtn");
    exportBtn = document.getElementById("exportBtn");
    exportTypographyBtn = document.getElementById("exportTypographyBtn");
    exportPickers = document.getElementById("exportPickers");
    refreshBtn = document.getElementById("refreshBtn");
    shellEl = document.querySelector(".shell");
    drawerToggleBtn = document.getElementById("drawerToggleBtn");
    resizeHandleEl = document.getElementById("resizeHandle");
    w3cPreviewEl = document.getElementById("w3cPreview");
    copyRawBtn = document.getElementById("copyRawBtn");
    copyW3cBtn = document.getElementById("copyW3cBtn");
    copyLogBtn = document.getElementById("copyLogBtn");
    allowHexChk = document.getElementById("allowHexChk");
    styleDictionaryChk = document.getElementById("styleDictionaryChk");
    flatTokensChk = document.getElementById("flatTokensChk");
    githubRememberChk = document.getElementById("githubRememberChk");
    if (allowHexChk) {
      allowHexChk.checked = true;
      allowHexChk.addEventListener("change", () => {
        postToPlugin({ type: "SAVE_PREFS", payload: { allowHexStrings: !!allowHexChk.checked } });
      });
    }
    importScopeOverlay = document.getElementById("importScopeOverlay");
    importScopeBody = document.getElementById("importScopeBody");
    importScopeConfirmBtn = document.getElementById("importScopeConfirmBtn");
    importScopeCancelBtn = document.getElementById("importScopeCancelBtn");
    importScopeRememberChk = document.getElementById("importScopeRememberChk");
    importScopeMissingEl = document.getElementById("importScopeMissingNotice");
    importScopeSummaryEl = document.getElementById("importScopeSummary");
    importScopeSummaryTextEl = document.getElementById("importScopeSummaryText");
    importScopeClearBtn = document.getElementById("importScopeClearBtn");
    importSkipLogListEl = document.getElementById("importSkipLogList");
    importSkipLogEmptyEl = document.getElementById("importSkipLogEmpty");
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    systemDarkMode = mediaQuery.matches;
    mediaQuery.addEventListener("change", (e) => {
      systemDarkMode = e.matches;
      applyTheme();
    });
    applyTheme();
    loadImportPreference();
    loadImportLog();
    renderImportPreferenceSummary();
    renderImportLog();
    if (importScopeClearBtn) {
      importScopeClearBtn.addEventListener("click", () => clearImportPreference(true));
    }
    if (importScopeConfirmBtn) {
      importScopeConfirmBtn.addEventListener("click", () => {
        if (!importScopeModalState) {
          closeImportScopeModal();
          return;
        }
        const state = importScopeModalState;
        const selections = [];
        for (let i = 0; i < state.collections.length; i++) {
          const collection = state.collections[i];
          const inputs = state.inputsByCollection.get(collection) || [];
          const selected = inputs.find((input) => input.checked);
          if (!selected) return;
          selections.push(selected.value);
        }
        const remember = importScopeRememberChk ? !!importScopeRememberChk.checked : false;
        closeImportScopeModal();
        state.onConfirm(selections, remember);
      });
    }
    if (importScopeCancelBtn) {
      importScopeCancelBtn.addEventListener("click", () => closeImportScopeModal());
    }
    if (importScopeOverlay) {
      importScopeOverlay.addEventListener("click", (ev) => {
        if (ev.target === importScopeOverlay) closeImportScopeModal();
      });
    }
    if (resizeHandleEl) {
      resizeHandleEl.addEventListener("pointerdown", (event) => {
        if (event.button !== 0 && event.pointerType === "mouse") return;
        if (resizeTracking) return;
        event.preventDefault();
        resizeTracking = {
          pointerId: event.pointerId,
          startX: event.clientX,
          startY: event.clientY,
          startWidth: window.innerWidth,
          startHeight: window.innerHeight
        };
        try {
          resizeHandleEl.setPointerCapture(event.pointerId);
        } catch (e) {
        }
        window.addEventListener("pointermove", handleResizeMove, true);
        window.addEventListener("pointerup", endResize, true);
        window.addEventListener("pointercancel", cancelResize, true);
      });
    }
    githubUi.attach({ document, window });
    if (fileInput) fileInput.addEventListener("change", setDisabledStates);
    if (exportAllChk) {
      exportAllChk.addEventListener("change", () => {
        setDisabledStates();
        postToPlugin({ type: "SAVE_PREFS", payload: { exportAll: !!exportAllChk.checked } });
        githubUi.onSelectionChange();
      });
    }
    if (styleDictionaryChk) {
      styleDictionaryChk.addEventListener("change", () => {
        postToPlugin({ type: "SAVE_PREFS", payload: { styleDictionary: !!styleDictionaryChk.checked } });
        requestPreviewForCurrent();
        githubUi.onSelectionChange();
      });
    }
    if (flatTokensChk) {
      flatTokensChk.addEventListener("change", () => {
        postToPlugin({ type: "SAVE_PREFS", payload: { flatTokens: !!flatTokensChk.checked } });
        requestPreviewForCurrent();
        githubUi.onSelectionChange();
      });
    }
    if (githubRememberChk) {
      githubRememberChk.addEventListener("change", () => {
        postToPlugin({ type: "SAVE_PREFS", payload: { githubRememberToken: !!githubRememberChk.checked } });
      });
    }
    if (refreshBtn) {
      refreshBtn.addEventListener("click", () => {
        postToPlugin({ type: "FETCH_COLLECTIONS" });
      });
    }
    if (importBtn && fileInput) {
      importBtn.addEventListener("click", () => {
        if (!fileInput.files || fileInput.files.length === 0) {
          log("Select a JSON file first.");
          return;
        }
        const reader = new FileReader();
        reader.onload = function() {
          try {
            const text = String(reader.result);
            const json = JSON.parse(text);
            if (!json || typeof json !== "object" || json instanceof Array) {
              log("Invalid JSON structure for tokens (expected an object).");
              return;
            }
            const allowHex = !!(allowHexChk && allowHexChk.checked);
            startImportFlow(json, allowHex);
          } catch (e) {
            const msg = e instanceof Error ? e.message : String(e);
            log("Failed to parse JSON: " + msg);
          }
        };
        reader.readAsText(fileInput.files[0]);
      });
    }
    if (exportBtn) {
      exportBtn.addEventListener("click", async () => {
        var _a, _b;
        let exportAll = false;
        if (exportAllChk) exportAll = !!exportAllChk.checked;
        const styleDictionary = !!(styleDictionaryChk && styleDictionaryChk.checked);
        const flatTokens = !!(flatTokensChk && flatTokensChk.checked);
        const payload = { exportAll, styleDictionary, flatTokens };
        if (!exportAll && collectionSelect && modeSelect) {
          payload.collection = collectionSelect.value;
          payload.mode = modeSelect.value;
          if (!(payload.collection && payload.mode)) {
            log('Pick collection and mode or use "Export all".');
            return;
          }
        }
        const suggestedName = exportAll ? "tokens.json" : prettyExportName(`${(_a = payload.collection) != null ? _a : "Tokens"}_mode=${(_b = payload.mode) != null ? _b : "Mode 1"}.tokens.json`);
        await beginPendingSave(suggestedName);
        postToPlugin({ type: "EXPORT_DTCG", payload });
        if (exportAll) log("Export all requested.");
        else log(`Export requested for "${payload.collection || ""}" / "${payload.mode || ""}".`);
      });
    }
    if (exportTypographyBtn) {
      exportTypographyBtn.addEventListener("click", async () => {
        await beginPendingSave("typography.json");
        postToPlugin({ type: "EXPORT_TYPOGRAPHY" });
        log("Typography export requested.");
      });
    }
    if (drawerToggleBtn) {
      drawerToggleBtn.addEventListener("click", () => {
        const current = drawerToggleBtn.getAttribute("aria-expanded") === "true";
        setDrawerOpen(!current);
      });
    }
    if (collectionSelect) {
      collectionSelect.addEventListener("change", () => {
        onCollectionChange();
        if (collectionSelect && modeSelect) {
          postToPlugin({ type: "SAVE_LAST", payload: { collection: collectionSelect.value, mode: modeSelect.value } });
          requestPreviewForCurrent();
        }
        githubUi.onSelectionChange();
      });
    }
    if (modeSelect) {
      modeSelect.addEventListener("change", () => {
        if (collectionSelect && modeSelect) {
          postToPlugin({ type: "SAVE_LAST", payload: { collection: collectionSelect.value, mode: modeSelect.value } });
        }
        setDisabledStates();
        requestPreviewForCurrent();
        githubUi.onSelectionChange();
      });
    }
    if (copyRawBtn) copyRawBtn.addEventListener(
      "click",
      () => copyElText(document.getElementById("raw"), "Raw Figma Collections")
    );
    if (copyW3cBtn) copyW3cBtn.addEventListener(
      "click",
      () => copyElText(document.getElementById("w3cPreview"), "W3C Preview")
    );
    if (copyLogBtn) copyLogBtn.addEventListener(
      "click",
      () => copyElText(document.getElementById("log"), "Log")
    );
    githubUi.onSelectionChange();
    autoFitOnce();
    if (rawEl) rawEl.textContent = "Loading variable collections\u2026";
    setDisabledStates();
    setDrawerOpen(getSavedDrawerOpen());
    postToPlugin({ type: "UI_READY" });
  });
  function setDrawerOpen(open) {
    if (shellEl) {
      if (open) shellEl.classList.remove("drawer-collapsed");
      else shellEl.classList.add("drawer-collapsed");
    }
    if (drawerToggleBtn) {
      drawerToggleBtn.setAttribute("aria-expanded", open ? "true" : "false");
      drawerToggleBtn.textContent = open ? "Hide" : "Show";
      drawerToggleBtn.title = open ? "Hide log" : "Show log";
    }
    try {
      window.localStorage.setItem("drawerOpen", open ? "1" : "0");
    } catch (e) {
    }
  }
  function getSavedDrawerOpen() {
    try {
      const v = window.localStorage.getItem("drawerOpen");
      if (v === "0") return false;
      if (v === "1") return true;
    } catch (e) {
    }
    return true;
  }
})();
//# sourceMappingURL=ui.js.map
</script>
    <script>
      // Scope tab behavior PER PANEL so multiple tab groups don't interfere.
      (function () {
        const panels = Array.from(document.querySelectorAll('.panel, .drawer'));
        panels.forEach(container => {
          const tabBtns = Array.from(container.querySelectorAll('.tabs .tab-btn'));
          if (tabBtns.length === 0) return;

          const body = container.querySelector('.panel-body, .drawer-body') || container;
          const tabPanels = Array.from(body.querySelectorAll('.tab-panel'));

          function activate(name) {
            tabBtns.forEach(b => {
              const on = b.getAttribute('data-tab') === name;
              b.classList.toggle('is-active', on);
              b.setAttribute('aria-selected', String(on));
            });
            tabPanels.forEach(p => {
              const on = p.getAttribute('data-tab') === name;
              p.classList.toggle('is-active', on);
              if (on) p.scrollTop = 0;
            });
          }

          tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
              const name = btn.getAttribute('data-tab');
              if (name) activate(name);
            });
          });

          // Initialize to the first .is-active button, or default to the first button
          const initial = tabBtns.find(b => b.classList.contains('is-active')) || tabBtns[0];
          if (initial) {
            const name = initial.getAttribute('data-tab');
            if (name) activate(name);
          }
        });
      })();
    </script>
</body>

</html>
