<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DTCG Import/Export</title>
  <style>/* src/app/ui.css */
:root {
  --bg: #040511;
  --bg-gradient:
    radial-gradient(
      
      120% 140% at 20% 15%,
      #1d2144 0%,
      #080919 55%,
      #020205 100% );
  --surface: rgba(16, 20, 39, 0.9);
  --surface-elevated: rgba(24, 29, 58, 0.95);
  --surface-muted: rgba(255, 255, 255, 0.03);
  --ink: #ffffff;
  --ink-subtle: #f3f5ff;
  --ink-muted: #dfe4ff;
  --accent: #fe8ac9;
  --accent-secondary: #9c8aff;
  --accent-ink: #160919;
  --border: rgba(255, 255, 255, 0.14);
  --border-strong: rgba(255, 255, 255, 0.24);
  --glow-pink: 0 0 18px rgba(254, 138, 201, 0.35);
  --glow-indigo: 0 0 18px rgba(156, 138, 255, 0.3);
  --button-shadow: 0 6px 14px rgba(254, 138, 201, 0.18);
  --button-shadow-hover: 0 8px 18px rgba(254, 138, 201, 0.22);
  --log-surface: rgba(5, 6, 16, 0.92);
  --drawer-h: 260px;
  --drawer-collapsed-h: 2rem;
}
[data-theme=light] {
  --bg: #f5f5f7;
  --bg-gradient:
    radial-gradient(
      
      120% 140% at 20% 15%,
      #ffffff 0%,
      #f0f2f5 55%,
      #e1e4e8 100% );
  --surface: rgba(255, 255, 255, 0.85);
  --surface-elevated: rgba(255, 255, 255, 0.95);
  --surface-muted: rgba(0, 0, 0, 0.03);
  --ink: #1a1a1a;
  --ink-subtle: #4a4a4a;
  --ink-muted: #6a6a6a;
  --accent: #d02c85;
  --accent-secondary: #6344e8;
  --accent-ink: #ffffff;
  --border: rgba(0, 0, 0, 0.1);
  --border-strong: rgba(0, 0, 0, 0.2);
  --glow-pink: 0 2px 8px rgba(208, 44, 133, 0.25);
  --glow-indigo: 0 2px 8px rgba(99, 68, 232, 0.2);
  --button-shadow: 0 4px 12px rgba(208, 44, 133, 0.18);
  --button-shadow-hover: 0 6px 14px rgba(208, 44, 133, 0.22);
  --log-surface: rgba(255, 255, 255, 0.9);
}
html,
body {
  height: 100%;
  margin: 0;
}
body {
  background: var(--bg-gradient);
  background-color: var(--bg);
  color: var(--ink);
  font-family:
    "Inter",
    "SF Pro Display",
    ui-sans-serif,
    system-ui,
    -apple-system,
    Segoe UI,
    Roboto,
    Arial,
    sans-serif;
  line-height: 1.4;
  -webkit-font-smoothing: antialiased;
}
.shell {
  height: 100vh;
  width: 100%;
  display: grid;
  grid-template-columns: minmax(0, 1fr) minmax(0, 1.2fr) minmax(0, 1fr);
  grid-template-rows: 1fr var(--drawer-h);
  gap: 16px;
  padding: 18px;
  box-sizing: border-box;
  grid-auto-flow: row;
  backdrop-filter: blur(22px);
  background: rgba(3, 4, 12, 0.35);
}
.shell.drawer-collapsed {
  grid-template-rows: 1fr var(--drawer-collapsed-h);
}
.shell.drawer-collapsed .drawer .drawer-body {
  display: none;
}
.drawer-toggle {
  padding: 6px 12px;
  border: 1px solid var(--border);
  border-radius: 999px;
  background: var(--surface);
  color: var(--ink);
  font-size: 12px;
  cursor: pointer;
  transition: background 180ms ease, box-shadow 180ms ease;
  box-shadow: var(--glow-indigo);
}
.drawer-toggle:hover {
  background: rgba(255, 255, 255, 0.06);
}
.col {
  display: flex;
  flex-direction: column;
  min-width: 0;
  min-height: 0;
}
.panel {
  display: flex;
  flex-direction: column;
  min-width: 0;
  min-height: 0;
  flex: 1;
  border: 1px solid var(--border);
  background: var(--surface);
  border-radius: 18px;
  padding: 0.75rem;
  overflow: hidden;
  box-shadow: 0 30px 60px rgba(2, 2, 8, 0.55), var(--glow-indigo);
}
.panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 10px 14px 8px 14px;
  border-bottom: 1px solid var(--border);
}
.eyebrow {
  font-size: 11px;
  letter-spacing: 0.18em;
  text-transform: uppercase;
  color: var(--ink-muted);
  margin: 0 0 2px 0;
}
.title {
  font-size: 18px;
  font-weight: 700;
  margin: 0;
  display: inline-flex;
  align-items: center;
  gap: 10px;
  background:
    linear-gradient(
      120deg,
      var(--accent),
      var(--accent-secondary));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
}
.title::before {
  content: "";
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background:
    linear-gradient(
      120deg,
      var(--accent),
      var(--accent-secondary));
  box-shadow: 0 0 12px rgba(254, 138, 201, 0.7);
  flex-shrink: 0;
}
.panel-body {
  padding: 0.5rem;
  display: flex;
  flex-direction: column;
  gap: 14px;
  min-width: 0;
  min-height: 0;
  flex: 1;
  overflow: auto;
  max-height: 100%;
}
.row {
  display: flex;
  gap: 12px;
  align-items: center;
}
.row > * {
  flex: 1;
  min-width: 0;
}
label {
  font-size: 12px;
  color: var(--ink-subtle);
  display: block;
  margin-bottom: 4px;
  letter-spacing: 0.04em;
}
label:has(input[type=checkbox]),
label:has(input[type=radio]) {
  display: flex;
  align-items: center;
  gap: 0.35rem;
}
input[type=text],
input[type=password],
select,
input[type=file],
textarea {
  width: 100%;
  padding: 10px 12px;
  border: 1px solid var(--border);
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.04);
  color: var(--ink);
  font-size: 13px;
  box-sizing: border-box;
  transition: border-color 150ms ease, box-shadow 150ms ease;
  backdrop-filter: blur(6px);
}
input[type=file] {
  padding: 10px;
  color: var(--ink-muted);
}
input[type=file]::-webkit-file-upload-button,
input[type=file]::file-selector-button {
  padding: 8px 14px;
  border: none;
  border-radius: 999px;
  font-size: 12px;
  font-weight: 600;
  color: var(--accent-ink);
  background:
    linear-gradient(
      125deg,
      var(--accent),
      var(--accent-secondary));
  cursor: pointer;
  margin-right: 12px;
  transition: transform 150ms ease, box-shadow 150ms ease;
  box-shadow: var(--button-shadow);
}
input[type=file]::-webkit-file-upload-button:hover,
input[type=file]::file-selector-button:hover {
  transform: translateY(-1px);
  box-shadow: var(--button-shadow-hover);
}
input[type=checkbox],
input[type=radio] {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 4px;
  border: 2px solid var(--accent-secondary);
  background: var(--log-surface);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition:
    border-color 140ms ease,
    box-shadow 140ms ease,
    background 140ms ease;
  position: relative;
  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.45);
}
input[type=radio] {
  border-radius: 50%;
}
input[type=checkbox]::after,
input[type=radio]::after {
  content: "";
  position: absolute;
  top: 50%;
  left: 50%;
  transition: transform 140ms ease;
  transform: translate(-50%, -50%) scale(0);
}
input[type=checkbox]::after {
  width: 6px;
  height: 10px;
  border-right: 2px solid #000;
  border-bottom: 2px solid #000;
  transform-origin: center;
  transform: translate(-50%, -60%) rotate(45deg) scale(0);
}
input[type=radio]::after {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #000;
  transform-origin: center;
}
input[type=checkbox]:checked,
input[type=radio]:checked {
  border-color: transparent;
  background:
    linear-gradient(
      125deg,
      var(--accent),
      var(--accent-secondary));
  box-shadow: var(--glow-pink);
}
input[type=radio]:checked {
  border: 2px solid var(--accent-secondary);
  background: var(--log-surface);
  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.45);
}
input[type=checkbox]:checked::after {
  transform: translate(-50%, -60%) rotate(45deg) scale(1);
}
[data-theme=light] input[type=checkbox]::after {
  border-color: #fff;
}
input[type=radio]:checked::after {
  background:
    linear-gradient(
      125deg,
      var(--accent),
      var(--accent-secondary));
  transform: translate(-50%, -50%) scale(1);
}
input[type=checkbox]:focus-visible,
input[type=radio]:focus-visible {
  outline: 2px solid rgba(255, 255, 255, 0.4);
  outline-offset: 2px;
}
input[type=text]::placeholder,
input[type=password]::placeholder,
textarea::placeholder {
  color: var(--ink-muted);
}
input[type=text]:focus,
input[type=password]:focus,
select:focus,
input[type=file]:focus,
textarea:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 1px rgba(254, 138, 201, 0.4);
}
select {
  background-color: rgba(255, 255, 255, 0.04);
  color: var(--ink);
}
.gh-folder-display {
  width: 100%;
  padding: 10px 12px;
  border: 1px dashed var(--border);
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.04);
  color: var(--ink);
  font-size: 12px;
  min-height: 40px;
  display: flex;
  align-items: center;
  box-sizing: border-box;
}
.gh-folder-display.is-placeholder {
  color: var(--ink-muted);
  font-style: italic;
}
.gh-input-error {
  color: #b91c1c;
  font-size: 11px;
  margin-top: 4px;
}
button {
  padding: 11px 18px;
  border: none;
  border-radius: 999px;
  color: var(--accent-ink);
  font-weight: 600;
  cursor: pointer;
  font-size: 14px;
  background:
    linear-gradient(
      125deg,
      var(--accent),
      var(--accent-secondary));
  box-shadow: var(--button-shadow);
  transition: transform 150ms ease, box-shadow 150ms ease;
}
button:hover:not([disabled]) {
  transform: translateY(-1px);
  box-shadow: var(--button-shadow-hover);
}
button[disabled] {
  opacity: 0.4;
  cursor: not-allowed;
  box-shadow: none;
}
.css-button-neumorphic {
  min-width: 130px;
  height: 44px;
  padding: 0 20px;
  font-weight: 500;
  border: 1px solid rgba(255, 255, 255, 0.18);
  background:
    linear-gradient(
      160deg,
      rgba(255, 255, 255, 0.08),
      rgba(8, 9, 18, 0.9));
  color: var(--ink);
  border-radius: 999px;
  box-shadow:
    inset 0 1px 3px rgba(255, 255, 255, 0.15),
    inset 0 -4px 8px rgba(3, 4, 12, 0.9),
    var(--glow-indigo);
}
.css-button-neumorphic:active {
  box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.6), inset 0 6px 12px rgba(255, 255, 255, 0.05);
}
[data-theme=light] #importBtn,
[data-theme=light] #exportBtn,
[data-theme=light] #exportTypographyBtn,
[data-theme=light] #ghConnectBtn,
[data-theme=light] #ghLogoutBtn,
[data-theme=light] #ghBranchRefreshBtn,
[data-theme=light] #ghNewBranchBtn,
[data-theme=light] #ghCreateBranchConfirmBtn,
[data-theme=light] #ghPickFolderBtn,
[data-theme=light] #ghExportAndCommitBtn,
[data-theme=light] #ghFetchTokensBtn {
  background:
    linear-gradient(
      125deg,
      var(--accent),
      var(--accent-secondary));
  box-shadow: var(--button-shadow);
  color: var(--accent-ink);
  border: none;
}
[data-theme=light] #importBtn:hover:not([disabled]),
[data-theme=light] #exportBtn:hover:not([disabled]),
[data-theme=light] #exportTypographyBtn:hover:not([disabled]),
[data-theme=light] #ghConnectBtn:hover:not([disabled]),
[data-theme=light] #ghLogoutBtn:hover:not([disabled]),
[data-theme=light] #ghBranchRefreshBtn:hover:not([disabled]),
[data-theme=light] #ghNewBranchBtn:hover:not([disabled]),
[data-theme=light] #ghCreateBranchConfirmBtn:hover:not([disabled]),
[data-theme=light] #ghPickFolderBtn:hover:not([disabled]),
[data-theme=light] #ghExportAndCommitBtn:hover:not([disabled]),
[data-theme=light] #ghFetchTokensBtn:hover:not([disabled]) {
  transform: translateY(-1px);
  box-shadow: var(--button-shadow-hover);
}
.muted {
  color: var(--ink-muted);
  font-size: 12px;
}
.gh-import-status {
  font-size: 12px;
  margin-top: 6px;
  color: var(--ink-muted);
}
.gh-import-status--ready {
  color: var(--ink-subtle);
}
.gh-import-status--progress {
  color: var(--accent);
}
.gh-import-status--success {
  color: #047857;
}
.gh-import-status--error {
  color: #b91c1c;
}
.import-scope-summary {
  border: 1px solid var(--border);
  border-radius: 14px;
  background: rgba(255, 255, 255, 0.03);
  padding: 0.75rem;
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
  box-shadow: inset 0 0 30px rgba(255, 255, 255, 0.02);
}
.import-skip-log {
  margin-top: 1rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  flex: 1;
  min-height: 0;
}
.import-skip-log-list {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  flex: 1;
  min-height: 0;
  overflow: auto;
}
.import-skip-log-entry {
  border: 1px solid var(--border);
  border-radius: 14px;
  background: rgba(255, 255, 255, 0.02);
  padding: 0.75rem;
  font-size: 12px;
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
}
.import-skip-log-entry-header {
  font-weight: 600;
  font-size: 12px;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  color: var(--ink-muted);
}
.import-skip-log-entry-note {
  color: var(--ink-muted);
  font-size: 11px;
}
.import-skip-log-token-list {
  margin: 0;
  padding-left: 1.1rem;
}
.import-skip-log-token-list li {
  margin-bottom: 0.2rem;
}
button.link-button {
  background: none;
  border: none;
  padding: 0;
  color: var(--accent);
  font-size: 12px;
  cursor: pointer;
  text-decoration: underline;
}
button.link-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  text-decoration: none;
}
pre {
  margin: 0;
  padding: 0.75rem;
  background: var(--log-surface);
  color: var(--ink);
  border: 1px solid var(--border);
  border-radius: 16px;
  font-family:
    "SFMono-Regular",
    Menlo,
    Consolas,
    "Cascadia Code",
    "Source Code Pro",
    "JetBrains Mono",
    ui-monospace,
    monospace;
  font-size: 11px;
  white-space: pre-wrap;
  overflow-wrap: anywhere;
  word-break: break-word;
  overflow: auto;
  min-width: 0;
  min-height: 0;
  flex: 1;
  height: 100%;
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
}
#log {
  background: var(--log-surface);
  color: var(--ink);
  font-family:
    ui-monospace,
    SFMono-Regular,
    Menlo,
    Consolas,
    "Liberation Mono",
    monospace;
  font-size: 12px;
  line-height: 1.5;
  padding: 16px;
  border-radius: 16px;
  border: 1px solid var(--border);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05), 0 10px 25px rgba(0, 0, 0, 0.55);
  overflow-y: auto;
  min-height: 140px;
  max-height: 100%;
}
#log a {
  color: var(--accent);
  font-weight: 600;
  text-decoration-color: rgba(254, 138, 201, 0.6);
  text-underline-offset: 3px;
}
#log a:hover,
#log a:focus-visible {
  color: var(--ink);
  text-decoration-color: rgba(255, 255, 255, 0.9);
  outline: 2px solid rgba(254, 138, 201, 0.4);
  outline-offset: 2px;
}
#log > div {
  padding: 2px 0;
  white-space: pre-wrap;
}
.stack {
  display: flex;
  flex-direction: column;
  gap: 10px;
  flex: 1;
  min-height: 0;
}
.row-center {
  display: flex;
  gap: 8px;
  align-items: center;
  justify-content: space-between;
}
.drawer {
  grid-column: 1 / -1;
  grid-row: 2;
  display: flex;
  flex-direction: column;
  min-height: 0;
  min-width: 0;
  border: 1px solid var(--border);
  background: var(--surface-elevated);
  border-radius: 22px;
  padding: 0.75rem;
  box-shadow: 0 20px 50px rgba(0, 0, 0, 0.55);
}
.drawer .panel-header {
  border-bottom: 1px solid var(--border);
}
.drawer-body {
  padding: 0.5rem;
  min-height: 0;
  min-width: 0;
  flex: 1;
  display: flex;
  flex-direction: column;
}
#log {
  display: block;
  padding: 16px;
  background: var(--log-surface);
  color: var(--ink);
  border: 1px solid var(--border);
  border-radius: 16px;
  font-family:
    ui-monospace,
    SFMono-Regular,
    Menlo,
    Consolas,
    "Liberation Mono",
    monospace;
  font-size: 12px;
  white-space: pre-wrap;
  overflow-y: auto;
  min-width: 0;
  min-height: 0;
  flex: 1;
  height: 100%;
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05), 0 12px 30px rgba(0, 0, 0, 0.6);
}
.resize-handle {
  position: fixed;
  right: 6px;
  bottom: 6px;
  width: 14px;
  height: 14px;
  border-radius: 3px;
  cursor: nwse-resize;
  display: grid;
  place-items: center;
  z-index: 2147483647;
  touch-action: none;
  user-select: none;
}
.resize-handle::after {
  content: "";
  width: 8px;
  height: 8px;
  border-right: 2px solid rgba(255, 255, 255, 0.4);
  border-bottom: 2px solid rgba(255, 255, 255, 0.4);
  transform: translate(1px, 1px);
  pointer-events: none;
}
#exportBtn {
  margin-top: 0.5rem;
  width: 100%;
}
.shell.drawer-collapsed .drawer {
  padding: 0;
  background: transparent;
  border: 0;
}
.shell.drawer-collapsed .drawer .panel-header {
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 14px;
  background: var(--surface);
  border-bottom: 1px solid var(--border);
}
.shell.drawer-collapsed .drawer .title {
  display: none;
}
.shell.drawer-collapsed .drawer .eyebrow {
  margin: 0;
}
.panel-header .actions {
  display: flex;
  gap: 8px;
  align-items: center;
}
.panel-header button {
  font-size: 11px;
  padding: 6px 12px;
  border: 1px solid var(--border);
  background: rgba(255, 255, 255, 0.08);
  color: var(--ink);
  border-radius: 999px;
  cursor: pointer;
  transition: background 140ms ease;
}
.panel-header button:hover {
  background: rgba(255, 255, 255, 0.18);
}
.tabs {
  display: flex;
  gap: 0.25rem;
  align-items: center;
}
.tab-btn {
  font-size: 1rem;
  padding: 0.45rem 1rem;
  border: 1px solid var(--border);
  background: rgba(255, 255, 255, 0.06);
  color: var(--ink);
  border-radius: 999px;
  cursor: pointer;
  transition:
    background 150ms ease,
    color 150ms ease,
    border-color 150ms ease;
}
.tab-btn:hover {
  color: var(--ink);
  background: rgba(255, 255, 255, 0.12);
}
.tab-btn.is-active:hover {
  background:
    linear-gradient(
      120deg,
      var(--accent),
      var(--accent-secondary));
  color: var(--accent-ink);
  cursor: default;
}
.tab-btn.is-active {
  background:
    linear-gradient(
      120deg,
      var(--accent),
      var(--accent-secondary));
  color: var(--accent-ink);
  border-color: transparent;
  box-shadow: var(--glow-pink);
}
.modal-overlay {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(2, 3, 8, 0.75);
  backdrop-filter: blur(10px);
  padding: 1.5rem;
  z-index: 99999;
}
.modal-overlay.is-open {
  display: flex;
}
.folder-picker-modal {
  width: min(560px, 92vw);
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  gap: 12px;
  background: rgba(7, 9, 22, 0.95);
  border: 1px solid var(--border);
  border-radius: 18px;
  box-shadow: 0 40px 80px rgba(0, 0, 0, 0.6);
  padding: 16px;
}
.import-scope-modal {
  width: min(420px, 92vw);
}
.import-scope-body {
  max-height: 240px;
  overflow: auto;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}
.import-scope-group {
  border: 1px solid var(--border);
  border-radius: 14px;
  background: rgba(255, 255, 255, 0.03);
  padding: 0.75rem;
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
}
.import-scope-group h3 {
  margin: 0 0 0.25rem 0;
  font-size: 13px;
}
.import-scope-mode {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 12px;
}
.import-scope-footer {
  display: flex;
  gap: 0.5rem;
  justify-content: flex-end;
}
.import-scope-remember {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
  font-size: 12px;
}
.import-scope-remember label {
  display: flex;
  align-items: center;
  gap: 0.35rem;
}
.import-scope-missing {
  font-size: 11px;
  color: var(--ink-muted);
  margin: 0;
}
.folder-picker-header {
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.folder-picker-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--ink);
}
.folder-picker-path-row {
  display: flex;
  gap: 8px;
  align-items: center;
}
.folder-picker-path-row input {
  flex: 1;
}
.folder-picker-list {
  border: 1px solid var(--border);
  border-radius: 14px;
  background: rgba(255, 255, 255, 0.02);
  min-height: 160px;
  max-height: 50vh;
  overflow: auto;
  padding: 6px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}
.folder-picker-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 8px;
  border: 0;
  border-radius: 6px;
  background: transparent;
  font-size: 12px;
  color: inherit;
  cursor: pointer;
  text-align: left;
}
.folder-picker-row:not([disabled]):hover {
  background: rgba(255, 255, 255, 0.08);
}
.folder-picker-row.is-muted {
  color: var(--ink-muted);
  cursor: default;
}
.folder-picker-row.is-muted:hover {
  background: transparent;
}
.folder-picker-row[disabled] {
  cursor: default;
}
.folder-picker-actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
}
.tab-panel {
  display: none;
  flex-direction: column;
  gap: 12px;
  min-width: 0;
  min-height: 0;
  flex: 1;
}
.tab-panel.is-active {
  display: flex;
}
.tab-panel--scroll {
  flex: 1 1 auto;
  min-height: 0;
  overflow: auto;
}
.github-panel {
  gap: 12px;
}
#panel-github button {
  font-size: 12px;
  padding: 6px 10px;
  border-width: 1px;
}
#panel-github .css-button-neumorphic {
  min-width: 0;
  height: auto;
  padding: 6px 10px;
}
.gh-section {
  display: flex;
  flex-direction: column;
  gap: 6px;
  flex: 0 0 auto;
  min-height: auto;
}
.gh-auth-actions {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}
.gh-auth-actions button {
  min-width: 0;
}
.gh-auth-status,
.gh-auth-meta {
  font-size: 12px;
}
.gh-remember {
  display: flex;
  align-items: center;
  gap: 6px;
  flex-wrap: wrap;
}
.gh-remember-toggle {
  display: inline-flex;
  align-items: center;
  gap: 4px;
}
.gh-repo-combo {
  position: relative;
  display: flex;
  align-items: center;
}
.gh-repo-combo select {
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  padding-right: 28px;
  border-radius: 12px;
  background-color: var(--surface-elevated);
  cursor: pointer;
}
[data-theme=light] .gh-repo-combo select {
  background-color: var(--surface-elevated);
}
.gh-repo-combo select:disabled {
  cursor: not-allowed;
  color: var(--ink-muted);
  background: rgba(255, 255, 255, 0.02);
}
.gh-repo-combo::after {
  content: "\25be";
  position: absolute;
  right: 10px;
  pointer-events: none;
  color: var(--ink-muted);
  font-size: 20px;
}
.gh-repo-combo:focus-within select:not(:disabled) {
  border-color: var(--accent);
}
.gh-branch-search {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}
.gh-branch-label-row {
  display: flex;
  align-items: baseline;
  justify-content: flex-start;
  gap: 6px;
}
.gh-branch-combo {
  position: relative;
  --branch-toggle-width: 32px;
  flex: 1 1 0;
  min-width: 0;
  display: flex;
  align-items: stretch;
}
.gh-branch-combo input {
  flex: 1 1 0;
  min-width: 0;
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
  padding-right: 24px;
}
.gh-branch-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: var(--branch-toggle-width);
  min-width: var(--branch-toggle-width);
  padding: 0;
  border: 1px solid var(--border);
  border-left: none;
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
  border-top-right-radius: 12px;
  border-bottom-right-radius: 12px;
  background: rgba(255, 255, 255, 0.06);
  color: var(--ink);
  font-size: 12px;
  cursor: pointer;
  box-shadow: none;
}
.gh-branch-toggle:hover:not([disabled]) {
  background: rgba(255, 255, 255, 0.12);
  transform: none;
  box-shadow: none;
}
.gh-branch-toggle[disabled] {
  cursor: not-allowed;
  opacity: 0.5;
}
button.gh-branch-clear {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  margin: 0;
  border: none;
  background: rgba(255, 255, 255, 0.04);
  color: var(--ink-muted);
  font-size: 20px;
  font-weight: normal;
  cursor: pointer;
  position: absolute;
  right: var(--branch-toggle-width);
  top: 50%;
  transform: translateY(-50%);
  line-height: 1;
  width: 24px;
  height: calc(100% - 2px);
  box-shadow: none;
  border-radius: 0;
  z-index: 10;
}
button.gh-branch-clear:hover,
button.gh-branch-clear:active,
button.gh-branch-clear:focus {
  transform: translateY(-50%);
  box-shadow: none;
  background: rgba(255, 255, 255, 0.04);
}
button.gh-branch-clear[hidden] {
  display: none;
}
.gh-branch-menu {
  position: absolute;
  top: calc(100% + 4px);
  left: 0;
  right: 0;
  max-height: 216px;
  margin: 0;
  padding: 4px 0;
  list-style: none;
  border: 1px solid var(--border);
  border-radius: 14px;
  background: var(--surface-elevated);
  box-shadow: 0 25px 45px rgba(0, 0, 0, 0.55);
  overflow-y: auto;
  z-index: 20;
}
.gh-branch-menu[hidden] {
  display: none;
}
.gh-branch-item {
  padding: 6px 10px;
  font-size: 12px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  color: var(--ink);
}
.gh-branch-item[data-active="1"],
.gh-branch-item:hover {
  background: rgba(255, 255, 255, 0.08);
}
.gh-branch-item[aria-disabled=true] {
  cursor: default;
  color: var(--ink-muted);
  background: transparent;
}
.gh-branch-item-action {
  font-weight: 600;
}
.gh-branch-item-empty {
  cursor: default;
  color: var(--ink-muted);
}
.gh-branch-menu::after {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: 14px;
  pointer-events: none;
}
.gh-branch-combo:focus-within .gh-branch-toggle:not([disabled]) {
  border-color: var(--accent);
}
.gh-branch-combo:focus-within input:not(:disabled) {
  border-color: var(--accent);
}
[data-theme=light] .gh-branch-toggle {
  background: var(--surface);
  box-shadow: none;
}
.gh-branch-toggle:active {
  transform: none;
  box-shadow: none;
}
[data-theme=light] .gh-branch-combo input:not(:disabled) {
  background: var(--surface);
}
[data-theme=light] .gh-branch-menu {
  background: var(--surface-elevated);
}
.gh-branch-count {
  flex: 0 0 auto;
  min-width: 7ch;
  white-space: nowrap;
  font-size: 12px;
  text-align: right;
  font-variant-numeric: tabular-nums;
}
.gh-branch-actions {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-self: flex-start;
}
.gh-branch-actions button {
  flex: 0 0 auto;
}
.gh-branch-refresh,
.gh-new-branch-btn,
#ghPickFolderBtn {
  align-self: flex-start;
}
.gh-new-branch-row {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}
.gh-new-branch-row input {
  flex: 1 1 auto;
  min-width: 0;
}
#ghTokenInput.gh-mask {
  -webkit-text-security: disc;
}
/*# sourceMappingURL=ui.css.map */
</style>
</head>

<body>
  <div class="shell">
    <!-- Left: Actions -->
    <div class="col">
      <div class="panel">
        <div class="panel-header">
          <div>
            <div class="eyebrow">Actions</div>
            <h2 class="title">Import, Export &amp; GitHub</h2>
          </div>
          <div class="tabs" role="tablist" aria-label="Actions tabs">
            <button class="tab-btn is-active" data-tab="import" role="tab" aria-selected="true"
              aria-controls="panel-import">Import</button>
            <button class="tab-btn" data-tab="export" role="tab" aria-selected="false"
              aria-controls="panel-export">Export</button>
            <button class="tab-btn" data-tab="github" role="tab" aria-selected="false"
              aria-controls="panel-github">GitHub</button>
          </div>
        </div>

        <div class="panel-body">
          <!-- Import tab -->
          <div class="tab-panel is-active" id="panel-import" data-tab="import" role="tabpanel"
            aria-labelledby="tab-import">
            <div class="stack">
              <div class="eyebrow">Import DTCG</div>
              <div>
                <label>Choose a DTCG JSON file</label>
                <div class="muted" style="padding: .5rem 0">Imports collections/modes as defined in the file.</div>
                <input id="file" type="file" accept=".json,application/json" />
              </div>
              <div class="row">
                <button id="importBtn" class="css-button-neumorphic">Import</button>
              </div>
              <div class="row">
                <div style="display: flex; gap: .25rem;">
                  <input id="allowHexChk" type="checkbox" />
                  <label for="allowHexChk" class="muted" style="padding-top: .35rem;">Accept hex strings as
                    colors</label>
                </div>
              </div>
              <!-- <div id="importScopeSummary" class="import-scope-summary" hidden>
                <div id="importScopeSummaryText" class="muted"></div>
                <button id="importScopeClearBtn" class="link-button" type="button">Clear remembered selection</button>
              </div> -->
              <div class="import-skip-log">
                <div class="eyebrow">Import summaries</div>
                <div id="importSkipLogEmpty" class="muted">No partial import history yet.</div>
                <div id="importSkipLogList" class="import-skip-log-list"></div>
              </div>
            </div>
          </div>

          <!-- Export tab -->
          <div class="tab-panel" id="panel-export" data-tab="export" role="tabpanel" aria-labelledby="tab-export">
            <div class="stack" style="border-top:1px solid var(--border);padding-top:12px;">
              <div class="eyebrow">Export DTCG</div>
              <div class="row-center"></div>
              <div class="stack" id="exportPickers">
                <div>
                  <label>Collection</label>
                  <select id="collectionSelect"></select>
                </div>
                <div>
                  <label>Mode (within collection)</label>
                  <select id="modeSelect"></select>
                </div>
                <div>
                  <div class="muted">Select a collection and mode, or check “Export all”.</div>
                  <label><input type="checkbox" id="exportAllChk" /> Export all collections &amp; modes (creates a
                    single
                    file)</label>
                  <div class="stack" style="gap:6px; margin:8px 0;">
                    <label class="muted" style="display:flex; align-items:center; gap:.35rem;">
                      <input type="checkbox" id="styleDictionaryChk" />
                      <span>Export color tokens as hex values</span>
                    </label>
                    <label class="muted" style="display:flex; align-items:center; gap:.35rem;">
                      <input type="checkbox" id="flatTokensChk" />
                      <span>Flatten collections (omit top-level collection groups)</span>
                    </label>
                  </div>
                  <button id="exportBtn" class="css-button-neumorphic">Export</button>
                </div>
                <div style="border-top:1px solid var(--border); padding-top:12px; margin-top:8px;">
                  <div class="muted" style="margin-bottom:8px;">Typography tokens are exported separately.</div>
                  <button id="exportTypographyBtn" class="css-button-neumorphic">Export typography.json</button>
                  <div class="muted" style="margin-top:6px;">Saves all local text styles as DTCG typography tokens.
                  </div>
                </div>
              </div>
            </div>
          </div>
          <!-- /Export tab -->

          <!-- GitHub tab -->
          <div class="tab-panel" id="panel-github" data-tab="github" role="tabpanel" aria-labelledby="tab-github">
            <div class="stack tab-panel--scroll github-panel">

              <!-- Auth row -->
              <div class="stack gh-section gh-auth">
                <h3 class="eyebrow">GitHub Authentication</h3>
                <label>Personal Access Token (PAT)</label>
                <input id="ghTokenInput" type="password" placeholder="GitHub personal access token"
                  autocomplete="off" />
                <div class="muted gh-remember">
                  <span>Store on this device?</span>
                  <div class="row">
            <label>
              <input type="checkbox" id="githubRememberChk" checked />
              Remember access token
            </label>
          </div>      </div>
                <div class="gh-auth-actions" style="margin-bottom: .5rem;">
                  <button id="ghConnectBtn" class="css-button-neumorphic">Connect</button>
                  <button id="ghLogoutBtn" class="css-button-neumorphic" type="button">Log out</button>
                </div>
                <div id="ghAuthStatus" class="muted gh-auth-status"></div>
                <div id="ghTokenMeta" class="muted gh-auth-meta"></div>
              </div>

              <!-- Export scope -->
              <div class="row">
                <div>
                  <h3 class="eyebrow" style="margin: .5rem;">Export scope</h3>
                  <div class="col" style="gap:.5rem;">
                    <label style="display:flex; align-items:center; gap:.35rem;">
                      <input type="radio" name="ghScope" id="ghScopeSelected" checked />
                      Use export tab selection (collection and mode)
                    </label>
                    <label style="display:flex; align-items:center; gap:.35rem;">
                      <input type="radio" name="ghScope" id="ghScopeAll" />
                      All collections &amp; modes
                    </label>
                    <label style="display:flex; align-items:center; gap:.35rem;">
                      <input type="radio" name="ghScope" id="ghScopeTypography" />
                      Typography (text styles)
                    </label>
                  </div>
                </div>
              </div>

              <!-- Repo picker -->
              <div class="stack gh-section">
                <h3 class="eyebrow">Export repository details</h3>
                <label>Export repository</label>
                <div class="gh-repo-combo">
                  <select id="ghRepoSelect" disabled></select>
                </div>
                <div class="muted">Repos you own or are a member of (populated after Connect).</div>
              </div>

              <!-- Branch controls -->
              <div class="stack gh-section">
                <div class="gh-branch-label-row">
                  <label>Export repository branch:</label>
                  <div id="ghBranchCount" class="muted gh-branch-count"></div>
                </div>
                <div class="gh-branch-search">
                  <div class="gh-branch-combo">
                    <input id="ghBranchInput" type="text" placeholder="Pick a repository first…" autocomplete="off"
                      disabled />
                    <button id="ghBranchClearBtn" class="gh-branch-clear" type="button" aria-label="Clear search" hidden>
                      <span aria-hidden="true">×</span>
                    </button>
                    <button id="ghBranchToggleBtn" class="gh-branch-toggle" type="button" aria-label="Show branches"
                      aria-haspopup="listbox" disabled>
                      <span aria-hidden="true">▾</span>
                    </button>
                    <ul id="ghBranchMenu" class="gh-branch-menu" role="listbox" aria-label="Branches" hidden></ul>
                  </div>
                </div>
                <div class="gh-branch-actions">
                  <button id="ghBranchRefreshBtn" class="css-button-neumorphic gh-branch-refresh"
                    type="button">Refresh</button>
                  <button id="ghNewBranchBtn" class="css-button-neumorphic gh-new-branch-btn" disabled
                    type="button">Create new…</button>
                </div>
                <div id="ghNewBranchRow" class="gh-new-branch-row" style="display:none;">
                  <input id="ghNewBranchName" type="text" placeholder="feature/my-branch" />
                  <button id="ghCreateBranchConfirmBtn" class="css-button-neumorphic" type="button">Create</button>
                  <button id="ghCancelBranchBtn" class="css-button-neumorphic" type="button">Cancel</button>
                </div>
              </div>

              <!-- Destination folder -->
              <div class="stack gh-section" style="margin-top: .5rem;">
                <h3 class="eyebrow">Export destination folder and file name</h3>
                <label>Destination folder (in repo)</label>
                <button id="ghPickFolderBtn" class="css-button-neumorphic" disabled type="button">Pick a
                  folder…</button>
                <div id="ghFolderDisplay" class="gh-folder-display is-placeholder" aria-live="polite">Folder path…
                </div>
                <input id="ghFolderInput" type="hidden" value="" />
                <label for="ghFilenameInput">Filename</label>
                <input id="ghFilenameInput" type="text" value="tokens.json" autocomplete="off" />
                <div id="ghFilenameError" class="gh-input-error" aria-live="polite" hidden></div>
              </div>



              <!-- Commit -->
              <div class="row">
                <div>
                  <h3 class="eyebrow" style="margin-bottom: .5rem;">Commit/pull request details</h3>
                  <label>Commit message</label>
                  <input id="ghCommitMsgInput" type="text" value="Update tokens from Figma" />
                </div>
              </div>

              <!-- PR toggle -->
              <div class="row">
                <div>
                  <label>Pull request</label>
                  <label style="display:flex; align-items:center; gap:.35rem;">
                    <input type="checkbox" id="ghCreatePrChk" />
                    Create a pull request after committing
                  </label>
                  <div id="ghPrOptions" class="stack" style="margin-top:.5rem; display:none; gap:.5rem;">
                    <input id="ghPrTitleInput" type="text" placeholder="Pull request title" />
                    <textarea id="ghPrBodyInput" rows="3" placeholder="Optional PR description"></textarea>
                  </div>
                </div>
              </div>



              <!-- Actions -->
              <div class="row">
                <div class="row" style="gap:.5rem;">
                  <button id="ghExportAndCommitBtn" class="css-button-neumorphic" disabled>Export &amp; Commit /
                    PR</button>
                </div>
              </div>

              <!-- Import from GitHub -->
              <div class="row" style="margin-top: .5rem;">
                <div>
                  <h3 class="eyebrow" style="padding-bottom: .25rem;">Import from tokens from GitHub</h3>
                  <label>Directory path to tokens in GitHub</label>
                  <!-- <div class="muted" style="margin: .25rem;">(Downloads a JSON file from the selected repo/branch and
                    imports it.)</div> -->
                  <div class="row">
                    <input id="ghFetchPathInput" type="text" placeholder="path/to/tokens-folder/design-token.json" />
                    <div style="flex:0 0 auto;">
                      <button id="ghFetchTokensBtn" class="css-button-neumorphic" disabled>Fetch &amp; Import</button>
                    </div>
                  </div>
                  <div id="ghImportStatus" class="gh-import-status">Select a repository and branch to enable imports.
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Middle: Raw Figma Collections -->
    <div class="col">
      <div class="panel">
        <div class="panel-header">
          <div>
            <div class="eyebrow">Reference</div>
            <h2 class="title">Figma Document</h2>
          </div>
          <div class="actions">
            <button id="copyRawBtn" title="Copy raw collections">Copy</button>
            <button id="refreshBtn">Refresh</button>
          </div>
        </div>
        <div class="panel-body">
          <pre id="raw"></pre>
        </div>
      </div>
    </div>

    <!-- Right: W3C Preview -->
    <div class="col">
      <div class="panel">
        <div class="panel-header">
          <div>
            <div class="eyebrow">Preview</div>
            <h2 class="title">W3C Design Tokens (JSON)</h2>
          </div>
          <button id="copyW3cBtn" title="Copy W3C JSON">Copy</button>
        </div>
        <div class="panel-body">
          <pre id="w3cPreview">{ /* preview will render here */ }</pre>
        </div>
      </div>
    </div>

    <!-- Bottom drawer: tabs span all columns -->
    <div class="drawer">
      <div class="panel-header">
        <div>
          <div class="eyebrow">Diagnostics</div>
          <h2 class="title">Activity Log</h2>
        </div>
        <div class="actions">
          <button id="copyLogBtn" title="Copy log">Copy</button>
          <button id="drawerToggleBtn" class="drawer-toggle" aria-expanded="true" title="Hide log">Hide</button>
        </div>
      </div>

      <div class="drawer-body">
        <div id="log"></div>
      </div>
    </div>

    <div id="importScopeOverlay" class="modal-overlay" hidden aria-hidden="true">
      <div class="folder-picker-modal import-scope-modal" role="dialog" aria-modal="true"
        aria-labelledby="importScopeTitle">
        <h2 id="importScopeTitle" class="folder-picker-title">Select a mode to import</h2>
        <p class="muted" style="margin:0;">Choose which collection and mode to bring into this file.</p>
        <p id="importScopeMissingNotice" class="import-scope-missing" hidden></p>
        <div id="importScopeBody" class="import-scope-body"></div>
        <!-- <div class="import-scope-remember">
          <label><input type="checkbox" id="importScopeRememberChk" /> Remember my choice for next time</label>
          <span class="muted">You can clear this later from the import panel.</span>
        </div> -->
        <div class="import-scope-footer">
          <button id="importScopeConfirmBtn" class="css-button-neumorphic" type="button">Import selected mode</button>
          <button id="importScopeCancelBtn" class="css-button-neumorphic" type="button">Cancel</button>
        </div>
      </div>
    </div>

    <div id="folderPickerOverlay" class="modal-overlay" hidden aria-hidden="true">
      <div class="folder-picker-modal" role="dialog" aria-modal="true" aria-labelledby="folderPickerTitle">
        <div class="folder-picker-header">
          <div class="eyebrow">Pick destination</div>
          <div id="folderPickerTitle" class="folder-picker-title">owner/repo @ branch</div>
        </div>
        <div class="folder-picker-path-row">
          <input id="folderPickerPath" type="text" placeholder="tokens/ (optional)" autocomplete="off" />
          <button id="folderPickerUseBtn" class="tab-btn">Use this folder</button>
        </div>
        <div id="folderPickerList" class="folder-picker-list">
          <button class="folder-picker-row is-muted" type="button" disabled>Loading…</button>
        </div>
        <div class="folder-picker-actions">
          <button id="folderPickerCancelBtn" class="tab-btn">Cancel</button>
        </div>
      </div>
    </div>

    <div class="resize-handle" id="resizeHandle" title="Drag to resize"></div>

    <script>"use strict";
(() => {
  // src/app/github/ui/auth.ts
  var GH_MASK = "\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022";
  var GithubAuthUi = class {
    constructor(deps) {
      this.doc = null;
      this.ghTokenInput = null;
      this.ghRememberChk = null;
      this.ghConnectBtn = null;
      this.ghVerifyBtn = null;
      this.ghLogoutBtn = null;
      this.ghAuthStatusEl = null;
      this.ghTokenMetaEl = null;
      this.ghIsAuthed = false;
      this.ghTokenExpiresAt = null;
      this.ghRememberPref = true;
      this.deps = deps;
    }
    attach(context) {
      this.doc = context.document;
      this.ghTokenInput = this.findTokenInput();
      this.ghRememberChk = this.doc.getElementById(
        "githubRememberChk"
      ) || this.doc.getElementById("ghRememberChk");
      this.ghConnectBtn = this.doc.getElementById(
        "githubConnectBtn"
      ) || this.doc.getElementById("ghConnectBtn");
      this.ghVerifyBtn = this.doc.getElementById("githubVerifyBtn") || this.doc.getElementById("ghVerifyBtn");
      this.ghLogoutBtn = this.doc.getElementById(
        "ghLogoutBtn"
      );
      this.ensureGhStatusElements();
      if (this.ghRememberChk) {
        this.ghRememberChk.checked = this.ghRememberPref;
        this.ghRememberChk.addEventListener("change", () => {
          this.updateRememberPref(!!this.ghRememberChk.checked, true);
        });
      }
      if (this.ghConnectBtn) {
        this.ghConnectBtn.addEventListener(
          "click",
          () => this.onGitHubConnectClick()
        );
      }
      if (this.ghVerifyBtn) {
        this.ghVerifyBtn.addEventListener(
          "click",
          () => this.onGitHubVerifyClick()
        );
      }
      if (this.ghLogoutBtn) {
        this.ghLogoutBtn.addEventListener(
          "click",
          () => this.onGitHubLogoutClick()
        );
      }
      this.updateGhStatusUi();
    }
    handleMessage(msg) {
      if (msg.type === "GITHUB_AUTH_RESULT") {
        const p = msg.payload || {};
        this.ghIsAuthed = !!p.ok;
        this.ghTokenExpiresAt = typeof p.exp !== "undefined" && p.exp !== null ? p.exp : typeof p.tokenExpiration !== "undefined" && p.tokenExpiration !== null ? p.tokenExpiration : null;
        if (typeof p.remember === "boolean") {
          this.updateRememberPref(p.remember, false);
        }
        if (this.ghIsAuthed) {
          this.setPatFieldObfuscated(true);
          const who = p.login || "unknown";
          const name = p.name ? ` (${p.name})` : "";
          this.deps.log(`GitHub: Authenticated as ${who}${name}.`);
        } else {
          this.setPatFieldObfuscated(false);
          const why = p.error ? `: ${p.error}` : ".";
          this.deps.log(`GitHub: Authentication failed${why}`);
        }
        this.updateGhStatusUi();
        return true;
      }
      return false;
    }
    isAuthed() {
      return this.ghIsAuthed;
    }
    logout() {
      this.onGitHubLogoutClick();
    }
    findTokenInput() {
      if (!this.doc) return null;
      return this.doc.getElementById("githubTokenInput") || this.doc.getElementById("ghTokenInput") || this.doc.getElementById("githubPatInput") || this.doc.querySelector(
        'input[name="githubToken"]'
      ) || this.doc.querySelector(
        'input[type="password"]'
      );
    }
    readPatFromUi() {
      if (!this.ghTokenInput) this.ghTokenInput = this.findTokenInput();
      if (!this.ghTokenInput) return "";
      if (this.ghTokenInput.getAttribute("data-filled") === "1")
        return GH_MASK;
      return (this.ghTokenInput.value || "").trim();
    }
    updateRememberPref(pref, persist = false) {
      const next = !!pref;
      this.ghRememberPref = next;
      if (this.ghRememberChk) {
        this.ghRememberChk.checked = this.ghRememberPref;
      }
      this.updateGhStatusUi();
      if (persist) {
        this.deps.postToPlugin({
          type: "SAVE_PREFS",
          payload: { githubRememberToken: this.ghRememberPref }
        });
      }
    }
    ensureGhStatusElements() {
      if (!this.doc) return;
      if (!this.ghAuthStatusEl)
        this.ghAuthStatusEl = this.doc.getElementById("ghAuthStatus");
      if (!this.ghTokenMetaEl)
        this.ghTokenMetaEl = this.doc.getElementById("ghTokenMeta");
      if (!this.ghLogoutBtn)
        this.ghLogoutBtn = this.doc.getElementById(
          "ghLogoutBtn"
        );
    }
    formatTimeLeft(expInput) {
      const exp = typeof expInput === "number" ? expInput : Date.parse(expInput);
      if (!isFinite(exp)) return "expiration: unknown";
      const now = Date.now();
      const ms = exp - now;
      if (ms <= 0) return "expired";
      const days = Math.floor(ms / (24 * 60 * 60 * 1e3));
      const hours = Math.floor(
        ms % (24 * 60 * 60 * 1e3) / (60 * 60 * 1e3)
      );
      if (days > 0) return `${days}d ${hours}h left`;
      const mins = Math.floor(ms % (60 * 60 * 1e3) / (60 * 1e3));
      if (hours > 0) return `${hours}h ${mins}m left`;
      const secs = Math.floor(ms % (60 * 1e3) / 1e3);
      if (mins > 0) return `${mins}m ${secs}s left`;
      return `${secs}s left`;
    }
    setPatFieldObfuscated(filled) {
      if (!this.ghTokenInput) this.ghTokenInput = this.findTokenInput();
      if (!this.ghTokenInput) return;
      this.ghTokenInput.type = "password";
      if (filled) {
        this.ghTokenInput.value = GH_MASK;
        this.ghTokenInput.setAttribute("data-filled", "1");
      } else {
        this.ghTokenInput.value = "";
        this.ghTokenInput.removeAttribute("data-filled");
      }
    }
    updateGhStatusUi() {
      this.ensureGhStatusElements();
      if (this.ghAuthStatusEl) {
        this.ghAuthStatusEl.textContent = this.ghIsAuthed ? "GitHub: authenticated." : "GitHub: not authenticated.";
      }
      if (this.ghTokenMetaEl) {
        const rememberTxt = this.ghRememberPref ? "Remember me: on" : "Remember me: off";
        const expTxt = this.ghTokenExpiresAt ? `Token ${this.formatTimeLeft(this.ghTokenExpiresAt)}` : "Token expiration: unknown";
        this.ghTokenMetaEl.textContent = `${expTxt} \u2022 ${rememberTxt}`;
      }
      if (this.ghTokenInput) {
        this.ghTokenInput.oninput = () => {
          if (this.ghTokenInput && this.ghTokenInput.getAttribute("data-filled") === "1") {
            this.ghTokenInput.removeAttribute("data-filled");
          }
          if (this.ghConnectBtn) this.ghConnectBtn.disabled = false;
        };
      }
      if (this.ghConnectBtn && this.ghTokenInput) {
        const isMasked = this.ghTokenInput.getAttribute("data-filled") === "1";
        this.ghConnectBtn.disabled = this.ghIsAuthed && isMasked;
      }
      if (this.ghLogoutBtn) {
        this.ghLogoutBtn.disabled = !this.ghIsAuthed;
      }
      if (this.ghRememberChk) {
        this.ghRememberChk.checked = this.ghRememberPref;
      }
    }
    onGitHubConnectClick() {
      var _a;
      const tokenRaw = this.readPatFromUi();
      const isMasked = ((_a = this.ghTokenInput) == null ? void 0 : _a.getAttribute("data-filled")) === "1";
      if (this.ghIsAuthed && isMasked) return;
      if (!tokenRaw) {
        this.deps.log("GitHub: Paste a Personal Access Token first.");
        return;
      }
      const remember = !!(this.ghRememberChk && this.ghRememberChk.checked);
      this.deps.log("GitHub: Verifying token\u2026");
      this.deps.postToPlugin({
        type: "GITHUB_SET_TOKEN",
        payload: { token: tokenRaw, remember }
      });
    }
    onGitHubVerifyClick() {
      this.onGitHubConnectClick();
    }
    onGitHubLogoutClick() {
      this.deps.postToPlugin({ type: "GITHUB_FORGET_TOKEN" });
      this.ghIsAuthed = false;
      this.ghTokenExpiresAt = null;
      this.setPatFieldObfuscated(false);
      this.updateGhStatusUi();
      this.deps.log("GitHub: Logged out.");
    }
  };

  // src/app/github/ui/repo.ts
  var GithubRepoUi = class {
    constructor(deps) {
      this.doc = null;
      this.ghRepoSelect = null;
      this.currentOwner = "";
      this.currentRepo = "";
      // Callbacks
      this.onRepoChange = null;
      this.deps = deps;
    }
    attach(context) {
      this.doc = context.document;
      this.ghRepoSelect = this.doc.getElementById(
        "ghRepoSelect"
      );
      if (this.ghRepoSelect) {
        let lastRepoKey = "";
        this.ghRepoSelect.addEventListener("change", () => {
          const value = this.ghRepoSelect.value;
          if (!value) return;
          if (value === lastRepoKey) return;
          lastRepoKey = value;
          const parts = value.split("/");
          this.currentOwner = parts[0] || "";
          this.currentRepo = parts[1] || "";
          this.deps.postToPlugin({
            type: "GITHUB_SELECT_REPO",
            payload: {
              owner: this.currentOwner,
              repo: this.currentRepo
            }
          });
          if (this.onRepoChange) {
            this.onRepoChange(this.currentOwner, this.currentRepo);
          }
        });
      }
    }
    handleMessage(msg) {
      var _a, _b;
      if (msg.type === "GITHUB_REPOS") {
        const repos = (_b = (_a = msg.payload) == null ? void 0 : _a.repos) != null ? _b : [];
        this.populateGhRepos(repos);
        this.deps.log(`GitHub: Repository list updated (${repos.length}).`);
        return true;
      }
      if (msg.type === "GITHUB_RESTORE_SELECTED") {
        const p = msg.payload || {};
        const newOwner = typeof p.owner === "string" ? p.owner : "";
        const newRepo = typeof p.repo === "string" ? p.repo : "";
        if (newOwner === this.currentOwner && newRepo === this.currentRepo) {
          return false;
        }
        this.currentOwner = newOwner;
        this.currentRepo = newRepo;
        this.syncSelect();
        if (this.currentOwner && this.currentRepo && this.onRepoChange) {
          this.onRepoChange(this.currentOwner, this.currentRepo);
        }
        return false;
      }
      return false;
    }
    reset() {
      this.populateGhRepos([]);
      this.currentOwner = "";
      this.currentRepo = "";
    }
    getSelected() {
      return { owner: this.currentOwner, repo: this.currentRepo };
    }
    populateGhRepos(list) {
      if (!this.ghRepoSelect || !this.doc) return;
      while (this.ghRepoSelect.options.length) this.ghRepoSelect.remove(0);
      for (const r of list) {
        const opt = this.doc.createElement("option");
        opt.value = r.full_name;
        opt.textContent = r.full_name;
        this.ghRepoSelect.appendChild(opt);
      }
      this.ghRepoSelect.disabled = list.length === 0;
      if (list.length > 0) {
        const prevOwner = this.currentOwner;
        const prevRepo = this.currentRepo;
        this.syncSelect();
        if ((this.currentOwner !== prevOwner || this.currentRepo !== prevRepo) && this.onRepoChange) {
          this.onRepoChange(this.currentOwner, this.currentRepo);
        }
      }
    }
    syncSelect() {
      if (!this.ghRepoSelect) return;
      if (this.currentOwner && this.currentRepo) {
        const want = `${this.currentOwner}/${this.currentRepo}`;
        let matched = false;
        for (let i = 0; i < this.ghRepoSelect.options.length; i++) {
          if (this.ghRepoSelect.options[i].value === want) {
            this.ghRepoSelect.selectedIndex = i;
            matched = true;
            break;
          }
        }
        if (matched) {
        }
      } else {
        if (this.ghRepoSelect.options.length > 0) {
          this.ghRepoSelect.selectedIndex = 0;
          const val = this.ghRepoSelect.options[0].value;
          const parts = val.split("/");
          if (parts.length === 2) {
            this.currentOwner = parts[0];
            this.currentRepo = parts[1];
          }
        }
      }
    }
  };

  // src/app/github/ui/branch.ts
  var BRANCH_TTL_MS = 6e4;
  var RENDER_STEP = 200;
  var BRANCH_INPUT_PLACEHOLDER = "Search branches\u2026";
  var GithubBranchUi = class {
    constructor(deps) {
      this.doc = null;
      this.win = null;
      // Elements
      this.ghBranchInput = null;
      this.ghBranchClearBtn = null;
      this.ghBranchToggleBtn = null;
      this.ghBranchMenu = null;
      this.ghBranchCountEl = null;
      this.ghBranchRefreshBtn = null;
      this.ghNewBranchBtn = null;
      this.ghNewBranchRow = null;
      this.ghNewBranchName = null;
      this.ghCreateBranchConfirmBtn = null;
      this.ghCancelBranchBtn = null;
      // State
      this.currentOwner = "";
      this.currentRepo = "";
      this.desiredBranch = null;
      this.defaultBranchFromApi = void 0;
      this.loadedPages = 0;
      this.hasMorePages = false;
      this.isFetchingBranches = false;
      this.lastBranchesFetchedAtMs = 0;
      this.listState = {
        all: [],
        filtered: [],
        renderCount: 0,
        menuVisible: false,
        highlightIndex: -1,
        lastQuery: "",
        inputPristine: true
      };
      // Callbacks
      this.onBranchChange = null;
      this.deps = deps;
    }
    attach(context) {
      this.doc = context.document;
      this.win = context.window;
      this.ghBranchInput = this.doc.getElementById(
        "ghBranchInput"
      );
      this.ghBranchClearBtn = this.doc.getElementById(
        "ghBranchClearBtn"
      );
      this.ghBranchToggleBtn = this.doc.getElementById(
        "ghBranchToggleBtn"
      );
      this.ghBranchMenu = this.doc.getElementById(
        "ghBranchMenu"
      );
      this.ghBranchCountEl = this.doc.getElementById("ghBranchCount");
      this.ghBranchRefreshBtn = this.doc.getElementById(
        "ghBranchRefreshBtn"
      );
      this.ghNewBranchBtn = this.doc.getElementById(
        "ghNewBranchBtn"
      );
      this.ghNewBranchRow = this.doc.getElementById("ghNewBranchRow");
      this.ghNewBranchName = this.doc.getElementById(
        "ghNewBranchName"
      );
      this.ghCreateBranchConfirmBtn = this.doc.getElementById(
        "ghCreateBranchConfirmBtn"
      );
      this.ghCancelBranchBtn = this.doc.getElementById(
        "ghCancelBranchBtn"
      );
      this.setupEventListeners();
    }
    setRepo(owner, repo) {
      this.currentOwner = owner;
      this.currentRepo = repo;
      this.reset();
      if (owner && repo) {
        this.setBranchDisabled(true, "Loading branches\u2026");
        this.updateBranchCount();
        this.cancelNewBranchFlow(false);
        this.deps.log(`GitHub: loading branches for ${owner}/${repo}\u2026`);
        this.isFetchingBranches = true;
        this.deps.postToPlugin({
          type: "GITHUB_FETCH_BRANCHES",
          payload: { owner, repo, page: 1 }
        });
      } else {
        this.setBranchDisabled(true, "Pick a repository first\u2026");
        this.updateBranchCount();
        this.cancelNewBranchFlow(false);
      }
    }
    getCurrentBranch() {
      if (this.desiredBranch) return this.desiredBranch;
      if (this.ghBranchInput && !this.ghBranchInput.disabled) {
        const raw = this.ghBranchInput.value.trim();
        if (raw && raw !== "__more__" && raw !== "__fetch__") {
          if (this.listState.all.includes(raw) || raw === this.defaultBranchFromApi)
            return raw;
        }
      }
      return this.defaultBranchFromApi || "";
    }
    getPrBaseBranch() {
      return this.defaultBranchFromApi || "";
    }
    handleMessage(msg) {
      if (msg.type === "GITHUB_BRANCHES") {
        const pl = msg.payload || {};
        const owner = String(pl.owner || "");
        const repo = String(pl.repo || "");
        if (owner !== this.currentOwner || repo !== this.currentRepo)
          return true;
        this.lastBranchesFetchedAtMs = Date.now();
        this.loadedPages = Number(pl.page || 1);
        this.hasMorePages = !!pl.hasMore;
        this.isFetchingBranches = false;
        if (typeof pl.defaultBranch === "string" && !this.defaultBranchFromApi) {
          this.defaultBranchFromApi = pl.defaultBranch;
        }
        if (this.ghNewBranchBtn) this.ghNewBranchBtn.disabled = false;
        const names = Array.isArray(pl.branches) ? pl.branches.map((b) => b.name) : [];
        const set = new Set(this.listState.all);
        for (const n of names) if (n) set.add(n);
        this.listState.all = Array.from(set).sort(
          (a, b) => a.localeCompare(b)
        );
        this.applyBranchFilter();
        this.setBranchDisabled(false);
        this.deps.log(
          `Loaded ${names.length} branches (page ${this.loadedPages}) for ${repo}${this.hasMorePages ? "\u2026" : ""}`
        );
        return true;
      }
      if (msg.type === "GITHUB_BRANCHES_ERROR") {
        const pl = msg.payload || {};
        const owner = String(pl.owner || "");
        const repo = String(pl.repo || "");
        if (owner !== this.currentOwner || repo !== this.currentRepo)
          return true;
        this.isFetchingBranches = false;
        this.setBranchDisabled(false);
        this.deps.log(
          `Branch load failed (status ${pl.status}): ${pl.message || "unknown error"}`
        );
        return true;
      }
      if (msg.type === "GITHUB_CREATE_BRANCH_RESULT") {
        this.handleCreateBranchResult(msg.payload);
        return true;
      }
      if (msg.type === "GITHUB_RESTORE_SELECTED") {
        const p = msg.payload || {};
        this.desiredBranch = typeof p.branch === "string" ? p.branch : null;
        if (this.desiredBranch && this.ghBranchInput) {
          this.ghBranchInput.value = this.desiredBranch;
          this.listState.lastQuery = this.desiredBranch;
          this.listState.inputPristine = false;
          this.updateClearButtonVisibility();
          if (this.onBranchChange)
            this.onBranchChange(this.desiredBranch);
        }
        return false;
      }
      return false;
    }
    reset() {
      this.desiredBranch = null;
      this.defaultBranchFromApi = void 0;
      this.loadedPages = 0;
      this.hasMorePages = false;
      this.isFetchingBranches = false;
      this.listState.all = [];
      this.listState.filtered = [];
      this.listState.renderCount = 0;
      if (this.ghBranchInput) {
        this.ghBranchInput.value = "";
        this.listState.lastQuery = "";
        this.listState.inputPristine = true;
        this.updateClearButtonVisibility();
      }
      if (this.ghBranchMenu)
        while (this.ghBranchMenu.firstChild)
          this.ghBranchMenu.removeChild(this.ghBranchMenu.firstChild);
      this.closeBranchMenu();
    }
    setupEventListeners() {
      if (this.ghBranchInput) {
        let timeout;
        this.ghBranchInput.addEventListener("focus", () => {
          if (this.ghBranchInput.disabled) return;
          this.showAllBranches();
          this.openBranchMenu();
        });
        this.ghBranchInput.addEventListener("input", () => {
          var _a, _b;
          if (timeout) (_a = this.win) == null ? void 0 : _a.clearTimeout(timeout);
          const value = this.ghBranchInput.value;
          if (value !== "__more__" && value !== "__fetch__") {
            this.listState.lastQuery = value;
          }
          this.listState.inputPristine = false;
          this.updateClearButtonVisibility();
          if (!this.listState.menuVisible) this.openBranchMenu();
          timeout = (_b = this.win) == null ? void 0 : _b.setTimeout(() => {
            this.applyBranchFilter();
          }, 120);
        });
        this.ghBranchInput.addEventListener(
          "keydown",
          (e) => this.handleInputKeydown(e)
        );
        this.ghBranchInput.addEventListener("change", () => {
          const result = this.processBranchSelection(
            this.ghBranchInput.value,
            false
          );
          if (result === "selected") this.closeBranchMenu();
          else if (result === "more" || result === "fetch")
            this.syncBranchHighlightAfterRender();
        });
      }
      if (this.ghBranchClearBtn) {
        this.ghBranchClearBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (this.ghBranchInput) {
            this.ghBranchInput.value = "";
            this.listState.lastQuery = "";
            this.desiredBranch = null;
            this.listState.inputPristine = false;
            this.updateClearButtonVisibility();
            this.showAllBranches();
            this.ghBranchInput.focus();
          }
        });
      }
      if (this.ghBranchToggleBtn) {
        this.ghBranchToggleBtn.addEventListener("click", () => {
          var _a;
          if (this.ghBranchToggleBtn.disabled) return;
          if (this.listState.menuVisible) {
            this.closeBranchMenu();
            return;
          }
          this.showAllBranches();
          this.openBranchMenu();
          if (this.ghBranchInput && ((_a = this.doc) == null ? void 0 : _a.activeElement) !== this.ghBranchInput)
            this.ghBranchInput.focus();
        });
      }
      if (this.ghBranchMenu) {
        this.ghBranchMenu.addEventListener(
          "mousedown",
          (event) => event.preventDefault()
        );
        this.ghBranchMenu.addEventListener(
          "click",
          (event) => this.handleMenuClick(event)
        );
      }
      if (this.doc) {
        this.doc.addEventListener(
          "mousedown",
          (event) => this.handleOutsideClick(event)
        );
        this.doc.addEventListener(
          "focusin",
          (event) => this.handleOutsideClick(event)
        );
      }
      if (this.ghBranchRefreshBtn) {
        this.ghBranchRefreshBtn.addEventListener("click", () => {
          this.lastBranchesFetchedAtMs = 0;
          this.revalidateBranchesIfStale(true);
        });
      }
      if (this.ghNewBranchBtn) {
        this.ghNewBranchBtn.addEventListener("click", () => {
          if (this.ghNewBranchBtn.disabled) return;
          const next = !this.isNewBranchRowVisible();
          if (next) this.showNewBranchRow(true);
          else this.cancelNewBranchFlow(false);
        });
      }
      if (this.ghNewBranchName) {
        this.ghNewBranchName.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            event.preventDefault();
            this.requestNewBranchCreation();
          } else if (event.key === "Escape") {
            event.preventDefault();
            this.cancelNewBranchFlow(true);
          }
        });
      }
      if (this.ghCreateBranchConfirmBtn) {
        this.ghCreateBranchConfirmBtn.addEventListener(
          "click",
          () => this.requestNewBranchCreation()
        );
      }
      if (this.ghCancelBranchBtn) {
        this.ghCancelBranchBtn.addEventListener(
          "click",
          () => this.cancelNewBranchFlow(true)
        );
      }
    }
    handleInputKeydown(e) {
      if (e.key === "ArrowDown") {
        this.openBranchMenu();
        this.moveBranchHighlight(1);
        e.preventDefault();
        return;
      }
      if (e.key === "ArrowUp") {
        this.openBranchMenu();
        this.moveBranchHighlight(-1);
        e.preventDefault();
        return;
      }
      if (e.key === "Enter") {
        if (this.listState.menuVisible && this.listState.highlightIndex >= 0) {
          const items = this.getBranchMenuItems();
          const item = items[this.listState.highlightIndex];
          if (item && item.dataset.selectable === "1") {
            const value = item.getAttribute("data-value") || "";
            if (value) {
              const result = this.processBranchSelection(value, true);
              if (result === "selected") this.closeBranchMenu();
              else if (result === "more" || result === "fetch") {
                this.syncBranchHighlightAfterRender();
                this.openBranchMenu();
              }
            }
          }
        } else {
          const result = this.processBranchSelection(
            this.ghBranchInput.value,
            false
          );
          if (result === "selected") this.closeBranchMenu();
          else if (result === "more" || result === "fetch")
            this.syncBranchHighlightAfterRender();
        }
        e.preventDefault();
        return;
      }
      if (e.key === "Escape") {
        if (this.listState.menuVisible) {
          this.closeBranchMenu();
          e.preventDefault();
        }
      }
    }
    handleMenuClick(event) {
      const target = event.target;
      if (!target) return;
      const item = target.closest("li");
      if (!item || !(item instanceof HTMLLIElement)) return;
      if (item.getAttribute("aria-disabled") === "true") return;
      const value = item.getAttribute("data-value") || "";
      if (!value) return;
      const result = this.processBranchSelection(value, true);
      if (result === "selected") this.closeBranchMenu();
      else if (result === "more" || result === "fetch") {
        this.syncBranchHighlightAfterRender();
        this.openBranchMenu();
      }
      if (this.ghBranchInput) this.ghBranchInput.focus();
    }
    handleOutsideClick(event) {
      if (!this.listState.menuVisible) return;
      const target = event.target;
      if (!target) {
        this.closeBranchMenu();
        return;
      }
      if (this.ghBranchMenu && this.ghBranchMenu.contains(target)) return;
      if (this.ghBranchInput && target === this.ghBranchInput) return;
      if (this.ghBranchToggleBtn && this.ghBranchToggleBtn.contains(target))
        return;
      this.closeBranchMenu();
    }
    revalidateBranchesIfStale(forceLog = false) {
      if (!this.currentOwner || !this.currentRepo) return;
      const stale = Date.now() - this.lastBranchesFetchedAtMs > BRANCH_TTL_MS;
      if (!stale) {
        if (forceLog)
          this.deps.log("Branches are up to date (no refresh needed).");
        return;
      }
      this.desiredBranch = this.desiredBranch || null;
      this.defaultBranchFromApi = void 0;
      this.loadedPages = 0;
      this.hasMorePages = false;
      this.isFetchingBranches = true;
      this.listState.all = [];
      this.listState.filtered = [];
      this.listState.renderCount = 0;
      this.setBranchDisabled(true, "Refreshing branches\u2026");
      this.updateBranchCount();
      if (this.ghBranchInput) {
        this.ghBranchInput.value = "";
        this.listState.lastQuery = "";
        this.listState.inputPristine = true;
      }
      this.deps.log("Refreshing branches\u2026");
      this.deps.postToPlugin({
        type: "GITHUB_FETCH_BRANCHES",
        payload: {
          owner: this.currentOwner,
          repo: this.currentRepo,
          page: 1
        }
      });
    }
    updateClearButtonVisibility() {
      if (this.ghBranchClearBtn) {
        const hasText = !!(this.ghBranchInput && this.ghBranchInput.value.trim());
        this.ghBranchClearBtn.hidden = !hasText;
      }
    }
    showAllBranches() {
      this.listState.filtered = [...this.listState.all];
      this.listState.renderCount = Math.min(
        RENDER_STEP,
        this.listState.filtered.length
      );
      this.renderOptions();
      this.updateBranchCount();
    }
    setBranchDisabled(disabled, placeholder) {
      const nextPlaceholder = placeholder !== void 0 ? placeholder : BRANCH_INPUT_PLACEHOLDER;
      if (this.ghBranchInput) {
        this.ghBranchInput.disabled = disabled;
        this.ghBranchInput.placeholder = nextPlaceholder;
        if (disabled) {
          this.ghBranchInput.value = "";
          this.listState.lastQuery = "";
          this.listState.inputPristine = true;
        }
      }
      if (this.ghBranchToggleBtn) {
        this.ghBranchToggleBtn.disabled = disabled;
        this.ghBranchToggleBtn.setAttribute("aria-expanded", "false");
      }
      if (disabled) this.closeBranchMenu();
    }
    updateBranchCount() {
      if (!this.ghBranchCountEl) return;
      const total = this.listState.all.length;
      const showing = this.listState.filtered.length;
      this.ghBranchCountEl.textContent = `${showing} / ${total}${this.hasMorePages ? " +" : ""}`;
    }
    getBranchMenuItems() {
      if (!this.ghBranchMenu) return [];
      const items = [];
      let node = this.ghBranchMenu.firstElementChild;
      while (node) {
        if (node instanceof HTMLLIElement) items.push(node);
        node = node.nextElementSibling;
      }
      return items;
    }
    setBranchHighlight(index, scrollIntoView) {
      const items = this.getBranchMenuItems();
      this.listState.highlightIndex = index;
      for (let i = 0; i < items.length; i++) {
        if (i === this.listState.highlightIndex)
          items[i].setAttribute("data-active", "1");
        else items[i].removeAttribute("data-active");
      }
      if (scrollIntoView && this.listState.highlightIndex >= 0 && this.listState.highlightIndex < items.length) {
        try {
          items[this.listState.highlightIndex].scrollIntoView({
            block: "nearest"
          });
        } catch (e) {
        }
      }
    }
    findNextSelectable(startIndex, delta, items) {
      if (!items.length) return -1;
      let index = startIndex;
      for (let i = 0; i < items.length; i++) {
        index += delta;
        if (index < 0) index = items.length - 1;
        else if (index >= items.length) index = 0;
        const item = items[index];
        if (!item) continue;
        if (item.dataset.selectable === "1" && item.getAttribute("aria-disabled") !== "true")
          return index;
      }
      return -1;
    }
    moveBranchHighlight(delta) {
      const items = this.getBranchMenuItems();
      if (!items.length) {
        this.setBranchHighlight(-1, false);
        return;
      }
      const next = this.findNextSelectable(
        this.listState.highlightIndex,
        delta,
        items
      );
      if (next >= 0) this.setBranchHighlight(next, true);
    }
    syncBranchHighlightAfterRender() {
      const items = this.getBranchMenuItems();
      if (!this.listState.menuVisible) {
        this.setBranchHighlight(-1, false);
        return;
      }
      if (!items.length) {
        this.setBranchHighlight(-1, false);
        return;
      }
      if (this.listState.highlightIndex >= 0 && this.listState.highlightIndex < items.length) {
        const current = items[this.listState.highlightIndex];
        if (current && current.dataset.selectable === "1" && current.getAttribute("aria-disabled") !== "true") {
          this.setBranchHighlight(this.listState.highlightIndex, false);
          return;
        }
      }
      const first = this.findNextSelectable(-1, 1, items);
      this.setBranchHighlight(first, false);
    }
    setBranchMenuVisible(show) {
      if (!this.ghBranchMenu) {
        this.listState.menuVisible = false;
        this.listState.highlightIndex = -1;
        return;
      }
      if (show && this.ghBranchInput && this.ghBranchInput.disabled)
        show = false;
      this.listState.menuVisible = show;
      if (this.listState.menuVisible) {
        this.ghBranchMenu.hidden = false;
        this.ghBranchMenu.setAttribute("data-open", "1");
        if (this.ghBranchToggleBtn)
          this.ghBranchToggleBtn.setAttribute("aria-expanded", "true");
        if (this.ghBranchInput)
          this.ghBranchInput.setAttribute("aria-expanded", "true");
      } else {
        this.ghBranchMenu.hidden = true;
        this.ghBranchMenu.removeAttribute("data-open");
        if (this.ghBranchToggleBtn)
          this.ghBranchToggleBtn.setAttribute("aria-expanded", "false");
        if (this.ghBranchInput)
          this.ghBranchInput.setAttribute("aria-expanded", "false");
        this.setBranchHighlight(-1, false);
      }
    }
    openBranchMenu() {
      if (!this.ghBranchMenu) return;
      if (!this.listState.menuVisible) {
        if (!this.ghBranchMenu.childElementCount) this.renderOptions();
        this.setBranchMenuVisible(true);
      }
      this.syncBranchHighlightAfterRender();
    }
    closeBranchMenu() {
      this.setBranchMenuVisible(false);
    }
    renderOptions() {
      if (!this.ghBranchMenu || !this.doc) return;
      while (this.ghBranchMenu.firstChild)
        this.ghBranchMenu.removeChild(this.ghBranchMenu.firstChild);
      const slice = this.listState.filtered.slice(
        0,
        this.listState.renderCount
      );
      if (slice.length > 0) {
        for (let i = 0; i < slice.length; i++) {
          const name = slice[i];
          const item = this.doc.createElement("li");
          item.className = "gh-branch-item";
          item.dataset.value = name;
          item.dataset.selectable = "1";
          item.setAttribute("role", "option");
          item.textContent = name;
          if (i === this.listState.highlightIndex)
            item.setAttribute("data-active", "1");
          this.ghBranchMenu.appendChild(item);
        }
      } else {
        const empty = this.doc.createElement("li");
        empty.className = "gh-branch-item gh-branch-item-empty";
        empty.setAttribute("aria-disabled", "true");
        empty.dataset.selectable = "0";
        empty.textContent = this.listState.all.length ? "No matching branches" : "No branches loaded yet";
        this.ghBranchMenu.appendChild(empty);
      }
      if (this.listState.filtered.length > this.listState.renderCount) {
        const more = this.doc.createElement("li");
        more.className = "gh-branch-item gh-branch-item-action";
        more.dataset.value = "__more__";
        more.dataset.selectable = "1";
        more.textContent = `Load more\u2026 (${this.listState.filtered.length - this.listState.renderCount} more)`;
        this.ghBranchMenu.appendChild(more);
      } else if (this.hasMorePages) {
        const fetch = this.doc.createElement("li");
        fetch.className = "gh-branch-item gh-branch-item-action";
        fetch.dataset.value = "__fetch__";
        fetch.dataset.selectable = "1";
        fetch.textContent = "Load next page\u2026";
        this.ghBranchMenu.appendChild(fetch);
      }
      if (this.ghBranchInput) {
        const want = this.desiredBranch || this.defaultBranchFromApi || "";
        if (!this.ghBranchInput.value && want && this.listState.inputPristine) {
          this.ghBranchInput.value = want;
          this.listState.lastQuery = want;
          this.updateClearButtonVisibility();
        }
      }
      if (this.listState.menuVisible) {
        this.syncBranchHighlightAfterRender();
      }
    }
    applyBranchFilter() {
      var _a;
      const rawInput = (((_a = this.ghBranchInput) == null ? void 0 : _a.value) || "").trim();
      const raw = rawInput === "__more__" || rawInput === "__fetch__" ? this.listState.lastQuery.trim() : rawInput;
      const q = raw.toLowerCase();
      const effectiveQuery = q;
      this.listState.filtered = effectiveQuery ? this.listState.all.filter(
        (n) => n.toLowerCase().includes(effectiveQuery)
      ) : [...this.listState.all];
      this.listState.renderCount = Math.min(
        RENDER_STEP,
        this.listState.filtered.length
      );
      this.renderOptions();
      this.updateBranchCount();
      if (!this.listState.menuVisible && this.ghBranchInput && !this.ghBranchInput.disabled) {
        const isFocused = !!this.doc && this.doc.activeElement === this.ghBranchInput;
        if (isFocused) {
          this.setBranchMenuVisible(true);
          this.syncBranchHighlightAfterRender();
        }
      }
    }
    processBranchSelection(rawValue, fromMenu) {
      const value = (rawValue || "").trim();
      if (!this.ghBranchInput) return "noop";
      if (value === "__more__") {
        this.listState.renderCount = Math.min(
          this.listState.renderCount + RENDER_STEP,
          this.listState.filtered.length
        );
        this.renderOptions();
        this.updateBranchCount();
        this.ghBranchInput.value = this.listState.lastQuery;
        if (fromMenu && !this.listState.menuVisible)
          this.setBranchMenuVisible(true);
        return "more";
      }
      if (value === "__fetch__") {
        this.ensureNextPageIfNeeded();
        this.ghBranchInput.value = this.listState.lastQuery;
        return "fetch";
      }
      if (!value) return "noop";
      this.desiredBranch = value;
      this.listState.lastQuery = value;
      this.ghBranchInput.value = value;
      this.listState.inputPristine = false;
      this.updateClearButtonVisibility();
      this.deps.postToPlugin({
        type: "GITHUB_SELECT_BRANCH",
        payload: {
          owner: this.currentOwner,
          repo: this.currentRepo,
          branch: value
        }
      });
      this.applyBranchFilter();
      if (this.onBranchChange) this.onBranchChange(value);
      return "selected";
    }
    ensureNextPageIfNeeded() {
      if (!this.ghBranchInput) return;
      if (!this.hasMorePages || this.isFetchingBranches) return;
      if (!this.currentOwner || !this.currentRepo) return;
      this.isFetchingBranches = true;
      this.deps.postToPlugin({
        type: "GITHUB_FETCH_BRANCHES",
        payload: {
          owner: this.currentOwner,
          repo: this.currentRepo,
          page: this.loadedPages + 1
        }
      });
    }
    // New Branch Flow
    showNewBranchRow(show) {
      if (!this.ghNewBranchRow) return;
      this.ghNewBranchRow.style.display = show ? "flex" : "none";
      if (show && this.ghNewBranchName) {
        if (!this.ghNewBranchName.value) {
          this.ghNewBranchName.value = `tokens/update-${(/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-").slice(0, 19)}`;
        }
        this.ghNewBranchName.focus();
        this.ghNewBranchName.select();
      }
    }
    isNewBranchRowVisible() {
      if (!this.ghNewBranchRow) return false;
      return this.ghNewBranchRow.style.display !== "none";
    }
    cancelNewBranchFlow(refocusBtn) {
      this.showNewBranchRow(false);
      if (this.ghNewBranchName) this.ghNewBranchName.value = "";
      if (refocusBtn && this.ghNewBranchBtn) this.ghNewBranchBtn.focus();
    }
    requestNewBranchCreation() {
      var _a;
      if (!this.ghCreateBranchConfirmBtn || this.ghCreateBranchConfirmBtn.disabled)
        return;
      if (!this.currentOwner || !this.currentRepo) {
        this.deps.log("Pick a repository before creating a branch.");
        return;
      }
      const baseBranch = this.defaultBranchFromApi || "";
      if (!baseBranch) {
        this.deps.log(
          "GitHub: Unable to determine the repository default branch. Refresh branches first."
        );
        return;
      }
      const newBranch = (((_a = this.ghNewBranchName) == null ? void 0 : _a.value) || "").trim();
      if (!newBranch) {
        this.deps.log("Enter a branch name to create.");
        if (this.ghNewBranchName) this.ghNewBranchName.focus();
        return;
      }
      if (newBranch === baseBranch) {
        this.deps.log(
          "Enter a branch name that differs from the source branch."
        );
        if (this.ghNewBranchName) this.ghNewBranchName.focus();
        return;
      }
      this.ghCreateBranchConfirmBtn.disabled = true;
      this.deps.log(`GitHub: creating ${newBranch} from ${baseBranch}\u2026`);
      this.deps.postToPlugin({
        type: "GITHUB_CREATE_BRANCH",
        payload: {
          owner: this.currentOwner,
          repo: this.currentRepo,
          baseBranch,
          newBranch
        }
      });
    }
    handleCreateBranchResult(payload) {
      var _a;
      const pl = payload || {};
      if (this.ghCreateBranchConfirmBtn)
        this.ghCreateBranchConfirmBtn.disabled = false;
      if (typeof pl.ok !== "boolean") return;
      if (pl.ok) {
        const baseBranch = String(pl.baseBranch || "");
        const newBranch = String(pl.newBranch || "");
        const url = String(pl.html_url || "");
        if (newBranch) {
          const s = new Set(this.listState.all);
          if (!s.has(newBranch)) {
            s.add(newBranch);
            this.listState.all = Array.from(s).sort(
              (a, b) => a.localeCompare(b)
            );
          }
          this.desiredBranch = newBranch;
          if (this.ghBranchInput) {
            this.ghBranchInput.value = newBranch;
            this.listState.lastQuery = newBranch;
            this.listState.inputPristine = false;
          }
          this.applyBranchFilter();
        }
        this.showNewBranchRow(false);
        if (this.ghNewBranchName) this.ghNewBranchName.value = "";
        if (url) {
          this.deps.log(
            `Branch created: ${newBranch} (from ${baseBranch})`
          );
          const logEl = this.deps.getLogElement();
          if (logEl && this.doc) {
            const wrap = this.doc.createElement("div");
            const a = this.doc.createElement("a");
            a.href = url;
            a.target = "_blank";
            a.textContent = "View on GitHub";
            wrap.appendChild(a);
            logEl.appendChild(wrap);
            logEl.scrollTop = logEl.scrollHeight;
          }
        } else {
          this.deps.log(
            `Branch created: ${newBranch} (from ${baseBranch})`
          );
        }
        if (this.onBranchChange && newBranch)
          this.onBranchChange(newBranch);
      } else {
        const status = (_a = pl.status) != null ? _a : 0;
        const message = pl.message || "unknown error";
        this.deps.log(
          `Create branch failed (status ${status}): ${message}`
        );
        if (pl.samlRequired) {
          this.deps.log(
            "This org requires SSO. Open the repo in your browser and authorize SSO for your token."
          );
        } else if (status === 403) {
          if (pl.noPushPermission) {
            this.deps.log(
              "You do not have push permission to this repository. Ask a maintainer for write access."
            );
          } else {
            this.deps.log("Likely a token permission issue:");
            this.deps.log(
              '\u2022 Classic PAT: add the "repo" scope (or "public_repo" for public repos).'
            );
            this.deps.log(
              '\u2022 Fine-grained PAT: grant this repository and set "Contents: Read and write".'
            );
          }
        }
      }
    }
  };

  // src/app/github/ui/folder.ts
  var GH_FOLDER_PLACEHOLDER = "Path in repository\u2026";
  var GithubFolderUi = class {
    constructor(deps) {
      this.doc = null;
      this.win = null;
      // Elements
      this.ghFolderInput = null;
      this.ghFolderDisplay = null;
      this.ghPickFolderBtn = null;
      this.folderPickerOverlay = null;
      this.folderPickerTitleEl = null;
      this.folderPickerPathInput = null;
      this.folderPickerUseBtn = null;
      this.folderPickerListEl = null;
      this.folderPickerCancelBtn = null;
      // State
      this.currentOwner = "";
      this.currentRepo = "";
      this.currentBranch = "";
      this.pickerState = {
        isOpen: false,
        currentPath: "",
        lastFocus: null,
        refreshNonce: 0
      };
      this.folderListWaiters = [];
      this.folderCreateWaiters = [];
      // Callbacks
      this.onFolderChange = null;
      this.deps = deps;
    }
    attach(context) {
      var _a;
      this.doc = context.document;
      this.win = context.window;
      this.ghFolderInput = this.doc.getElementById(
        "ghFolderInput"
      );
      this.ghFolderDisplay = this.doc.getElementById("ghFolderDisplay");
      this.setGhFolderDisplay(((_a = this.ghFolderInput) == null ? void 0 : _a.value) || "");
      this.ghPickFolderBtn = this.doc.getElementById(
        "ghPickFolderBtn"
      );
      this.folderPickerOverlay = this.doc.getElementById(
        "folderPickerOverlay"
      );
      this.folderPickerTitleEl = this.doc.getElementById("folderPickerTitle");
      this.folderPickerPathInput = this.doc.getElementById(
        "folderPickerPath"
      );
      this.folderPickerUseBtn = this.doc.getElementById(
        "folderPickerUseBtn"
      );
      this.folderPickerListEl = this.doc.getElementById("folderPickerList");
      this.folderPickerCancelBtn = this.doc.getElementById(
        "folderPickerCancelBtn"
      );
      this.setupEventListeners();
    }
    setContext(owner, repo, branch) {
      this.currentOwner = owner;
      this.currentRepo = repo;
      this.currentBranch = branch;
      this.updateFolderControlsEnabled();
    }
    reset() {
      this.setGhFolderDisplay("");
      this.pickerState.isOpen = false;
      this.pickerState.currentPath = "";
      this.pickerState.refreshNonce++;
      this.folderListWaiters = [];
      this.folderCreateWaiters = [];
      if (this.folderPickerOverlay) {
        this.folderPickerOverlay.classList.remove("is-open");
        this.folderPickerOverlay.setAttribute("aria-hidden", "true");
        this.folderPickerOverlay.hidden = true;
      }
    }
    getFolder() {
      const raw = this.ghFolderInput ? this.ghFolderInput.value.trim() : "";
      return this.normalizeFolderInput(raw).payload;
    }
    setFolder(path) {
      const normalized = this.normalizeFolderInput(path);
      this.setGhFolderDisplay(normalized.display);
    }
    handleMessage(msg) {
      if (msg.type === "GITHUB_FOLDER_LIST_RESULT") {
        const pl = msg.payload;
        const path = String(pl.path || "").replace(/^\/+|\/+$/g, "");
        const ok = pl.ok;
        let entries = [];
        let message = "";
        let status;
        if (pl.ok) {
          entries = pl.entries;
        } else {
          message = pl.message;
          status = pl.status;
        }
        for (let i = 0; i < this.folderListWaiters.length; i++) {
          if (this.folderListWaiters[i].path === path) {
            const waiter = this.folderListWaiters.splice(i, 1)[0];
            if (ok) waiter.resolve({ ok: true, entries });
            else
              waiter.reject({
                ok: false,
                message: message || `HTTP ${status || 0}`,
                status
              });
            break;
          }
        }
        return true;
      }
      if (msg.type === "GITHUB_CREATE_FOLDER_RESULT") {
        const pl = msg.payload;
        const fp = String(pl.folderPath || "").replace(/^\/+|\/+$/g, "");
        const ok = pl.ok;
        let message = "";
        let status;
        if (!pl.ok) {
          message = pl.message;
          status = pl.status;
        }
        for (let i = 0; i < this.folderCreateWaiters.length; i++) {
          if (this.folderCreateWaiters[i].folderPath === fp) {
            const waiter = this.folderCreateWaiters.splice(i, 1)[0];
            if (ok) waiter.resolve({ ok: true });
            else
              waiter.reject({
                ok: false,
                message: message || `HTTP ${status || 0}`,
                status
              });
            break;
          }
        }
        return true;
      }
      if (msg.type === "GITHUB_RESTORE_SELECTED") {
        const p = msg.payload || {};
        if (typeof p.folder === "string") {
          const normalized = this.normalizeFolderInput(p.folder);
          this.setGhFolderDisplay(normalized.display);
          if (this.onFolderChange)
            this.onFolderChange(normalized.payload);
        }
        return false;
      }
      return false;
    }
    setupEventListeners() {
      if (this.ghPickFolderBtn) {
        this.ghPickFolderBtn.addEventListener(
          "click",
          () => this.openFolderPicker()
        );
      }
      if (this.folderPickerOverlay) {
        this.folderPickerOverlay.addEventListener("click", (event) => {
          if (event.target === this.folderPickerOverlay)
            this.closeFolderPicker();
        });
      }
      if (this.folderPickerCancelBtn) {
        this.folderPickerCancelBtn.addEventListener(
          "click",
          () => this.closeFolderPicker()
        );
      }
      let folderPickerPathDebounce;
      if (this.folderPickerPathInput) {
        this.folderPickerPathInput.addEventListener("input", () => {
          var _a, _b;
          if (folderPickerPathDebounce)
            (_a = this.win) == null ? void 0 : _a.clearTimeout(folderPickerPathDebounce);
          const value = this.folderPickerPathInput.value;
          folderPickerPathDebounce = (_b = this.win) == null ? void 0 : _b.setTimeout(() => {
            this.setFolderPickerPath(value, true, false);
          }, 120);
        });
        this.folderPickerPathInput.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            event.preventDefault();
            this.setFolderPickerPath(this.folderPickerPathInput.value);
          }
        });
        this.folderPickerPathInput.addEventListener(
          "click",
          (e) => e.stopPropagation()
        );
        this.folderPickerPathInput.addEventListener(
          "mousedown",
          (e) => e.stopPropagation()
        );
      }
      if (this.folderPickerUseBtn) {
        this.folderPickerUseBtn.addEventListener("click", () => {
          if (this.folderPickerPathInput) {
            this.setFolderPickerPath(
              this.folderPickerPathInput.value,
              false
            );
          }
          const selectionRaw = this.pickerState.currentPath ? `${this.pickerState.currentPath}/` : "/";
          const normalized = this.normalizeFolderInput(selectionRaw);
          this.setGhFolderDisplay(normalized.display);
          this.deps.postToPlugin({
            type: "GITHUB_SET_FOLDER",
            payload: {
              owner: this.currentOwner,
              repo: this.currentRepo,
              folder: normalized.payload
            }
          });
          this.closeFolderPicker();
          this.deps.log(
            `Folder selected: ${normalized.display === "/" ? "(repo root)" : normalized.display}`
          );
          if (this.onFolderChange)
            this.onFolderChange(normalized.payload);
        });
      }
      if (this.doc) {
        this.doc.addEventListener(
          "keydown",
          (e) => this.handleFolderPickerKeydown(e)
        );
      }
    }
    normalizeFolderInput(raw) {
      const trimmed = raw.trim();
      if (!trimmed) return { display: "", payload: "" };
      if (trimmed === "/" || trimmed === "./" || trimmed === ".") {
        return { display: "/", payload: "/" };
      }
      const collapsed = trimmed.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
      const stripped = collapsed.replace(/^\/+/, "").replace(/\/+$/, "");
      if (!stripped) return { display: "/", payload: "/" };
      return { display: stripped + "/", payload: stripped };
    }
    normalizeFolderPickerPath(raw) {
      const trimmed = (raw || "").trim();
      if (!trimmed || trimmed === "/" || trimmed === "./" || trimmed === ".")
        return "";
      const collapsed = trimmed.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
      return collapsed.replace(/^\/+/, "").replace(/\/+$/, "");
    }
    setGhFolderDisplay(display) {
      if (this.ghFolderInput) this.ghFolderInput.value = display || "";
      if (!this.ghFolderDisplay) return;
      if (display) {
        this.ghFolderDisplay.textContent = display;
        this.ghFolderDisplay.classList.remove("is-placeholder");
      } else {
        this.ghFolderDisplay.textContent = GH_FOLDER_PLACEHOLDER;
        this.ghFolderDisplay.classList.add("is-placeholder");
      }
    }
    updateFolderControlsEnabled() {
      const enable = !!(this.currentOwner && this.currentRepo && this.currentBranch);
      if (this.ghPickFolderBtn) this.ghPickFolderBtn.disabled = !enable;
    }
    listDir(path) {
      return new Promise((resolve) => {
        const req = { path: path.replace(/^\/+|\/+$/g, "") };
        this.folderListWaiters.push({
          path: req.path,
          resolve: (v) => resolve(v),
          reject: (v) => resolve(v)
        });
        this.deps.postToPlugin({
          type: "GITHUB_FOLDER_LIST",
          payload: {
            owner: this.currentOwner,
            repo: this.currentRepo,
            branch: this.currentBranch,
            path: req.path
          }
        });
      });
    }
    openFolderPicker() {
      var _a, _b;
      if (!this.currentOwner || !this.currentRepo) {
        this.deps.log("Pick a repository first.");
        return;
      }
      if (!this.currentBranch) {
        this.deps.log("Pick a branch first.");
        return;
      }
      if (!(this.folderPickerOverlay && this.folderPickerTitleEl && this.folderPickerPathInput && this.folderPickerListEl)) {
        this.deps.log("Folder picker UI is unavailable.");
        return;
      }
      this.pickerState.lastFocus = this.doc && this.doc.activeElement instanceof HTMLElement ? this.doc.activeElement : null;
      this.folderPickerOverlay.hidden = false;
      this.folderPickerOverlay.classList.add("is-open");
      this.folderPickerOverlay.setAttribute("aria-hidden", "false");
      this.pickerState.isOpen = true;
      this.updateFolderPickerTitle(this.currentBranch);
      const startNormalized = this.normalizeFolderInput(
        ((_a = this.ghFolderInput) == null ? void 0 : _a.value) || ""
      );
      const startPath = startNormalized.payload === "/" ? "" : startNormalized.payload;
      this.setFolderPickerPath(startPath, true);
      (_b = this.win) == null ? void 0 : _b.setTimeout(() => {
        var _a2, _b2;
        (_a2 = this.folderPickerPathInput) == null ? void 0 : _a2.focus();
        (_b2 = this.folderPickerPathInput) == null ? void 0 : _b2.select();
      }, 0);
    }
    closeFolderPicker() {
      var _a;
      if (!this.folderPickerOverlay) return;
      this.folderPickerOverlay.classList.remove("is-open");
      this.folderPickerOverlay.setAttribute("aria-hidden", "true");
      this.folderPickerOverlay.hidden = true;
      this.pickerState.isOpen = false;
      this.pickerState.currentPath = "";
      this.pickerState.refreshNonce++;
      if (this.folderPickerListEl) {
        this.folderPickerListEl.replaceChildren(
          this.createFolderPickerRow("Loading\u2026", {
            muted: true,
            disabled: true
          })
        );
      }
      if (this.pickerState.lastFocus && ((_a = this.doc) == null ? void 0 : _a.contains(this.pickerState.lastFocus))) {
        this.pickerState.lastFocus.focus();
      }
      this.pickerState.lastFocus = null;
    }
    createFolderPickerRow(label, options) {
      if (!this.doc) throw new Error("GitHub UI not attached");
      const btn = this.doc.createElement("button");
      btn.type = "button";
      btn.className = "folder-picker-row";
      btn.textContent = label;
      if (options == null ? void 0 : options.muted) btn.classList.add("is-muted");
      if (options == null ? void 0 : options.disabled) btn.disabled = true;
      if (options == null ? void 0 : options.onClick) {
        btn.addEventListener("mousedown", (event) => {
          var _a;
          event.preventDefault();
          event.stopPropagation();
          (_a = options.onClick) == null ? void 0 : _a.call(options);
        });
      }
      return btn;
    }
    updateFolderPickerTitle(branch) {
      if (!this.folderPickerTitleEl) return;
      if (this.currentOwner && this.currentRepo) {
        this.folderPickerTitleEl.textContent = `${this.currentOwner}/${this.currentRepo} @ ${branch}`;
      } else {
        this.folderPickerTitleEl.textContent = "Select a repository first";
      }
    }
    setFolderPickerPath(raw, refresh = true, syncInput = true) {
      const normalized = this.normalizeFolderPickerPath(raw);
      this.pickerState.currentPath = normalized;
      if (syncInput && this.folderPickerPathInput)
        this.folderPickerPathInput.value = normalized;
      if (refresh && this.pickerState.isOpen) {
        void this.refreshFolderPickerList();
      }
    }
    async refreshFolderPickerList() {
      if (!(this.folderPickerListEl && this.pickerState.isOpen)) return;
      const listEl = this.folderPickerListEl;
      const requestId = ++this.pickerState.refreshNonce;
      listEl.replaceChildren(
        this.createFolderPickerRow("Loading\u2026", {
          muted: true,
          disabled: true
        })
      );
      const path = this.pickerState.currentPath;
      const res = await this.listDir(path);
      if (requestId !== this.pickerState.refreshNonce) return;
      if (!res.ok) {
        const status = typeof res.status === "number" ? res.status : 0;
        if (status === 404) {
          listEl.replaceChildren(
            this.createFolderPickerRow(
              "Folder not found. It will be created during export.",
              { muted: true, disabled: true }
            )
          );
          return;
        }
        if (status === 409) {
          listEl.replaceChildren(
            this.createFolderPickerRow(
              "Cannot open this path: an existing file blocks the folder.",
              { muted: true, disabled: true }
            )
          );
          return;
        }
        const message = res.message ? res.message : "failed to fetch";
        listEl.replaceChildren(
          this.createFolderPickerRow(`Error: ${message}`, {
            muted: true,
            disabled: true
          })
        );
        return;
      }
      const nodes = [];
      if (path) {
        nodes.push(
          this.createFolderPickerRow(".. (up one level)", {
            muted: true,
            onClick: () => {
              const parentParts = this.pickerState.currentPath.split("/").filter(Boolean);
              parentParts.pop();
              this.setFolderPickerPath(parentParts.join("/"));
            }
          })
        );
      }
      const entries = Array.isArray(res.entries) ? res.entries : [];
      const dirs = entries.filter((e) => e.type === "dir").sort((a, b) => (a.name || "").localeCompare(b.name || ""));
      if (dirs.length === 0) {
        nodes.push(
          this.createFolderPickerRow("(no subfolders)", {
            muted: true,
            disabled: true
          })
        );
      } else {
        for (const d of dirs) {
          const name = d.name || "";
          nodes.push(
            this.createFolderPickerRow(`${name}/`, {
              onClick: () => {
                const next = this.pickerState.currentPath ? `${this.pickerState.currentPath}/${name}` : name;
                this.setFolderPickerPath(next);
              }
            })
          );
        }
      }
      listEl.replaceChildren(...nodes);
    }
    handleFolderPickerKeydown(event) {
      if (!this.pickerState.isOpen) return;
      if (event.key === "Escape") {
        event.preventDefault();
        this.closeFolderPicker();
      }
    }
  };

  // src/app/github/ui/import.ts
  var GithubImportUi = class {
    constructor(deps) {
      this.doc = null;
      // Elements
      this.ghFetchBtn = null;
      this.ghFetchPathInput = null;
      // State
      this.currentOwner = "";
      this.currentRepo = "";
      this.currentBranch = "";
      this.currentFolder = "";
      // Callbacks
      this.onTokensFetched = null;
      this.deps = deps;
    }
    attach(context) {
      this.doc = context.document;
      this.ghFetchBtn = this.doc.getElementById(
        "ghFetchTokensBtn"
      );
      this.ghFetchPathInput = this.doc.getElementById(
        "ghFetchPathInput"
      );
      if (this.ghFetchBtn) {
        this.ghFetchBtn.addEventListener("click", () => this.fetchTokens());
      }
      if (this.ghFetchPathInput) {
        this.ghFetchPathInput.addEventListener(
          "input",
          () => this.updateEnabled()
        );
      }
    }
    setContext(owner, repo, branch, folder) {
      this.currentOwner = owner;
      this.currentRepo = repo;
      this.currentBranch = branch;
      this.currentFolder = folder;
      this.updateEnabled();
    }
    reset() {
      this.updateEnabled();
    }
    handleMessage(msg) {
      if (msg.type === "GITHUB_FETCH_TOKENS_RESULT") {
        this.handleFetchResult(msg.payload);
        return true;
      }
      return false;
    }
    updateEnabled() {
      if (this.ghFetchBtn) {
        const hasContext = !!(this.currentOwner && this.currentRepo && this.currentBranch);
        const hasPath = !!(this.ghFetchPathInput && this.ghFetchPathInput.value.trim());
        this.ghFetchBtn.disabled = !(hasContext && hasPath);
      }
    }
    fetchTokens() {
      var _a;
      if (!this.currentOwner || !this.currentRepo || !this.currentBranch) {
        this.deps.log("Please select a repository and branch first.");
        return;
      }
      const pathInput = ((_a = this.ghFetchPathInput) == null ? void 0 : _a.value.trim()) || "";
      if (!pathInput) {
        this.deps.log("Please enter a path to the tokens file.");
        return;
      }
      const path = pathInput.replace(/^\/+|\/+$/g, "");
      this.deps.log(
        `Fetching ${path} from ${this.currentOwner}/${this.currentRepo} (${this.currentBranch})\u2026`
      );
      if (this.ghFetchBtn) this.ghFetchBtn.disabled = true;
      const allowHex = !!(this.deps.getAllowHexCheckbox() && this.deps.getAllowHexCheckbox().checked);
      const contexts = this.deps.getImportContexts();
      this.deps.postToPlugin({
        type: "GITHUB_FETCH_TOKENS",
        payload: {
          owner: this.currentOwner,
          repo: this.currentRepo,
          branch: this.currentBranch,
          path,
          allowHexStrings: allowHex,
          contexts
        }
      });
    }
    handleFetchResult(pl) {
      if (this.ghFetchBtn) this.ghFetchBtn.disabled = false;
      if (!pl || typeof pl !== "object") return;
      const payload = pl;
      const status = typeof payload.status === "number" ? payload.status : 0;
      const message = payload.message || "unknown error";
      if (payload.ok) {
        const json = payload.json;
        if (!json) {
          this.deps.log("Fetched file is empty or invalid JSON.");
          return;
        }
        this.deps.log(
          `Successfully fetched tokens file (${JSON.stringify(json).length} bytes).`
        );
        if (this.onTokensFetched) {
          this.onTokensFetched(json);
        }
      } else {
        this.deps.log(`Fetch failed (status ${status}): ${message}`);
        if (status === 404) {
          this.deps.log("File not found. Check if the path is correct.");
        }
      }
    }
  };

  // src/app/github/ui/export.ts
  var GithubExportUi = class {
    constructor(deps) {
      this.doc = null;
      // Elements
      this.ghExportAndCommitBtn = null;
      this.ghCommitMsgInput = null;
      this.ghFilenameInput = null;
      this.ghScopeAll = null;
      this.ghScopeTypography = null;
      this.ghScopeSelected = null;
      this.ghCreatePrChk = null;
      this.ghPrTitleInput = null;
      this.ghPrBodyInput = null;
      // State
      this.currentOwner = "";
      this.currentRepo = "";
      this.currentBranch = "";
      this.currentFolder = "";
      this.prBaseBranch = "";
      this.hasCollections = false;
      this.hasTextStyles = false;
      this.deps = deps;
    }
    attach(context) {
      this.doc = context.document;
      this.ghExportAndCommitBtn = this.doc.getElementById(
        "ghExportAndCommitBtn"
      );
      this.ghCommitMsgInput = this.doc.getElementById(
        "ghCommitMsgInput"
      );
      this.ghFilenameInput = this.doc.getElementById(
        "ghFilenameInput"
      );
      this.ghScopeAll = this.doc.getElementById(
        "ghScopeAll"
      );
      this.ghScopeTypography = this.doc.getElementById(
        "ghScopeTypography"
      );
      this.ghScopeSelected = this.doc.getElementById(
        "ghScopeSelected"
      );
      this.ghCreatePrChk = this.doc.getElementById(
        "ghCreatePrChk"
      );
      this.ghPrTitleInput = this.doc.getElementById(
        "ghPrTitleInput"
      );
      this.ghPrBodyInput = this.doc.getElementById(
        "ghPrBodyInput"
      );
      if (this.ghExportAndCommitBtn) {
        this.ghExportAndCommitBtn.addEventListener(
          "click",
          () => this.handleExportClick()
        );
      }
      [this.ghScopeAll, this.ghScopeTypography, this.ghScopeSelected].forEach(
        (el) => {
          if (el)
            el.addEventListener("change", () => this.updateEnabled());
        }
      );
    }
    setContext(owner, repo, branch, folder, prBaseBranch) {
      this.currentOwner = owner;
      this.currentRepo = repo;
      this.currentBranch = branch;
      this.currentFolder = folder;
      this.prBaseBranch = prBaseBranch;
      this.updateEnabled();
    }
    reset() {
      this.updateEnabled();
    }
    handleMessage(msg) {
      if (msg.type === "GITHUB_COMMIT_RESULT") {
        this.handleCommitResult(msg.payload);
        return true;
      }
      if (msg.type === "GITHUB_PR_RESULT") {
        this.handlePrResult(msg.payload);
        return true;
      }
      return false;
    }
    updateEnabled() {
      if (!this.ghExportAndCommitBtn) return;
      const hasContext = !!(this.currentOwner && this.currentRepo && this.currentBranch);
      let scopeValid = true;
      const scope = this.getSelectedScope();
      if (scope === "selected") {
        const collectionSelect = this.deps.getCollectionSelect();
        const modeSelect = this.deps.getModeSelect();
        const hasCollection = !!(collectionSelect && collectionSelect.value);
        const hasMode = !!(modeSelect && modeSelect.value);
        scopeValid = hasCollection && hasMode;
      } else if (scope === "all") {
        scopeValid = this.hasCollections;
      } else if (scope === "typography") {
        scopeValid = this.hasTextStyles;
      }
      const hasFilename = !!(this.ghFilenameInput && this.ghFilenameInput.value.trim());
      this.ghExportAndCommitBtn.disabled = !(hasContext && scopeValid && hasFilename);
    }
    setCollectionsAvailability(hasCollections, hasTextStyles) {
      this.hasCollections = hasCollections;
      this.hasTextStyles = hasTextStyles;
      this.updateEnabled();
    }
    getSelectedScope() {
      if (this.ghScopeAll && this.ghScopeAll.checked) return "all";
      if (this.ghScopeTypography && this.ghScopeTypography.checked)
        return "typography";
      return "selected";
    }
    handleExportClick() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if (!this.currentOwner || !this.currentRepo || !this.currentBranch) {
        this.deps.log("Pick a repository and branch first.");
        return;
      }
      const collectionSelect = this.deps.getCollectionSelect();
      const modeSelect = this.deps.getModeSelect();
      const scope = this.ghScopeAll && this.ghScopeAll.checked ? "all" : this.ghScopeTypography && this.ghScopeTypography.checked ? "typography" : "selected";
      const selectedCollection = collectionSelect ? collectionSelect.value || "" : "";
      const selectedMode = modeSelect ? modeSelect.value || "" : "";
      const commitMessage = (((_a = this.ghCommitMsgInput) == null ? void 0 : _a.value) || "Update tokens from Figma").trim();
      const folder = this.currentFolder;
      if (!folder || folder === "/") {
      }
      const filenameRaw = ((_b = this.ghFilenameInput) == null ? void 0 : _b.value) || "";
      if (!filenameRaw.trim()) {
        this.deps.log("Enter a filename (e.g. tokens.json).");
        (_c = this.ghFilenameInput) == null ? void 0 : _c.focus();
        return;
      }
      if (!filenameRaw.endsWith(".json")) {
        this.deps.log("Filename must end with .json");
        (_d = this.ghFilenameInput) == null ? void 0 : _d.focus();
        return;
      }
      if (scope === "selected") {
        if (!selectedCollection || !selectedMode) {
          this.deps.log("Pick a collection and a mode before exporting.");
          return;
        }
      }
      const createPr = !!(this.ghCreatePrChk && this.ghCreatePrChk.checked);
      const payload = {
        type: "GITHUB_EXPORT_AND_COMMIT",
        payload: {
          owner: this.currentOwner,
          repo: this.currentRepo,
          branch: this.currentBranch,
          folder,
          filename: filenameRaw,
          commitMessage,
          scope,
          styleDictionary: !!((_e = this.deps.getStyleDictionaryCheckbox()) == null ? void 0 : _e.checked),
          flatTokens: !!((_f = this.deps.getFlatTokensCheckbox()) == null ? void 0 : _f.checked),
          createPr
        }
      };
      if (selectedCollection) payload.payload.collection = selectedCollection;
      if (selectedMode) payload.payload.mode = selectedMode;
      if (createPr) {
        payload.payload.prBase = this.prBaseBranch;
        payload.payload.prTitle = (((_g = this.ghPrTitleInput) == null ? void 0 : _g.value) || "").trim();
        payload.payload.prBody = ((_h = this.ghPrBodyInput) == null ? void 0 : _h.value) || "";
      }
      const scopeLabel = scope === "all" ? "all collections" : scope === "typography" ? "typography" : "selected mode";
      const fullPath = folder ? `${folder}${filenameRaw}` : filenameRaw;
      this.deps.log(`GitHub: Export summary \u2192 ${fullPath} (${scopeLabel})`);
      this.deps.log(
        createPr ? "Export, Commit & PR requested\u2026" : "Export & Commit requested\u2026"
      );
      this.deps.postToPlugin(payload);
    }
    handleCommitResult(pl) {
      if (!pl || typeof pl !== "object") return;
      const payload = pl;
      if (payload.ok) {
        const url = String(payload.commitUrl || "");
        const branch = payload.branch || "";
        const fullPath = payload.fullPath || "file";
        this.deps.log(`Commit succeeded (${branch}): ${url || "(no URL)"}`);
        this.deps.log(`Committed ${fullPath}`);
        if (url) {
          this.addLogLink(url, "View commit");
        }
        if (payload.createdPr) {
          const pr = payload.createdPr;
          this.deps.log(
            `PR prepared (#${pr.number}) from ${pr.head} \u2192 ${pr.base}`
          );
        }
      } else {
        const status = typeof payload.status === "number" ? payload.status : 0;
        const message = payload.message || "unknown error";
        const fullPath = payload.fullPath || "file";
        if (status === 304) {
          this.deps.log(`Commit skipped: ${message} (${fullPath})`);
        } else {
          this.deps.log(
            `Commit failed (${status}): ${message} (${fullPath})`
          );
        }
      }
    }
    handlePrResult(pl) {
      if (!pl || typeof pl !== "object") return;
      const payload = pl;
      if (payload.ok) {
        this.deps.log(
          `PR created: #${payload.number} (${payload.head} \u2192 ${payload.base})`
        );
        const url = payload.url;
        if (url && typeof url === "string") {
          this.addLogLink(url, "View PR");
        }
      } else {
        this.deps.log(
          `PR creation failed (${payload.status || 0}): ${payload.message || "unknown error"}`
        );
      }
    }
    addLogLink(url, text) {
      const logEl = this.deps.getLogElement();
      if (logEl && this.doc) {
        const wrap = this.doc.createElement("div");
        const a = this.doc.createElement("a");
        a.href = url;
        a.target = "_blank";
        a.textContent = text;
        wrap.appendChild(a);
        logEl.appendChild(wrap);
        logEl.scrollTop = logEl.scrollHeight;
      }
    }
  };

  // src/app/github/ui.ts
  function createGithubUi(deps) {
    const authUi = new GithubAuthUi(deps);
    const repoUi = new GithubRepoUi(deps);
    const branchUi = new GithubBranchUi(deps);
    const folderUi = new GithubFolderUi(deps);
    const importUi = new GithubImportUi(deps);
    const exportUi = new GithubExportUi(deps);
    wireDependencies();
    function wireDependencies() {
      repoUi.onRepoChange = () => {
        const { owner, repo } = repoUi.getSelected();
        branchUi.setRepo(owner, repo);
        folderUi.reset();
        importUi.reset();
        exportUi.reset();
      };
      branchUi.onBranchChange = (branch) => {
        const { owner, repo } = repoUi.getSelected();
        folderUi.setContext(owner, repo, branch);
        const folder = folderUi.getFolder();
        const prBase = branchUi.getPrBaseBranch();
        importUi.setContext(owner, repo, branch, folder);
        exportUi.setContext(owner, repo, branch, folder, prBase);
      };
      folderUi.onFolderChange = (folder) => {
        const { owner, repo } = repoUi.getSelected();
        const branch = branchUi.getCurrentBranch();
        const prBase = branchUi.getPrBaseBranch();
        importUi.setContext(owner, repo, branch, folder);
        exportUi.setContext(owner, repo, branch, folder, prBase);
      };
      importUi.onTokensFetched = (tokens) => {
        const contexts = deps.getImportContexts();
        if (!contexts.length) {
          deps.log(
            "No import configuration found. Please set up import settings."
          );
          return;
        }
        deps.log("Importing tokens into Figma\u2026");
        deps.postToPlugin({
          type: "IMPORT_DTCG",
          payload: { json: tokens, contexts }
        });
      };
    }
    function attach(context) {
      authUi.attach(context);
      repoUi.attach(context);
      branchUi.attach(context);
      folderUi.attach(context);
      importUi.attach(context);
      exportUi.attach(context);
    }
    function handleMessage(msg) {
      let handled = false;
      handled = authUi.handleMessage(msg) || handled;
      handled = repoUi.handleMessage(msg) || handled;
      handled = branchUi.handleMessage(msg) || handled;
      handled = folderUi.handleMessage(msg) || handled;
      handled = importUi.handleMessage(msg) || handled;
      handled = exportUi.handleMessage(msg) || handled;
      return handled;
    }
    function onSelectionChange() {
      exportUi.updateEnabled();
    }
    function onCollectionsData(data) {
      const hasCollections = !!(data == null ? void 0 : data.collections) && data.collections.length > 0 && data.collections.some((c) => c.variables && c.variables.length > 0);
      const hasTextStyles = !!((data == null ? void 0 : data.textStyles) && data.textStyles.length);
      exportUi.setCollectionsAvailability(hasCollections, hasTextStyles);
      exportUi.updateEnabled();
    }
    return {
      attach,
      handleMessage,
      onSelectionChange,
      onCollectionsData
    };
  }

  // src/app/ui/dom.ts
  var uiElements = {
    logEl: null,
    rawEl: null,
    exportAllChk: null,
    collectionSelect: null,
    modeSelect: null,
    fileInput: null,
    importBtn: null,
    exportBtn: null,
    exportTypographyBtn: null,
    exportPickers: null,
    refreshBtn: null,
    shellEl: null,
    drawerToggleBtn: null,
    resizeHandleEl: null,
    w3cPreviewEl: null,
    copyRawBtn: null,
    copyW3cBtn: null,
    copyLogBtn: null,
    allowHexChk: null,
    styleDictionaryChk: null,
    flatTokensChk: null,
    githubRememberChk: null,
    importScopeOverlay: null,
    importScopeBody: null,
    importScopeConfirmBtn: null,
    importScopeCancelBtn: null,
    importScopeRememberChk: null,
    importScopeMissingEl: null,
    importScopeSummaryEl: null,
    importScopeSummaryTextEl: null,
    importScopeClearBtn: null,
    importSkipLogListEl: null,
    importSkipLogEmptyEl: null
  };
  function initDomElements() {
    if (typeof document === "undefined") return;
    uiElements.logEl = document.getElementById("log");
    uiElements.rawEl = document.getElementById("raw");
    uiElements.exportAllChk = document.getElementById(
      "exportAllChk"
    );
    uiElements.collectionSelect = document.getElementById(
      "collectionSelect"
    );
    uiElements.modeSelect = document.getElementById(
      "modeSelect"
    );
    uiElements.fileInput = document.getElementById(
      "file"
    );
    uiElements.importBtn = document.getElementById(
      "importBtn"
    );
    uiElements.exportBtn = document.getElementById(
      "exportBtn"
    );
    uiElements.exportTypographyBtn = document.getElementById(
      "exportTypographyBtn"
    );
    uiElements.exportPickers = document.getElementById("exportPickers");
    uiElements.refreshBtn = document.getElementById(
      "refreshBtn"
    );
    uiElements.shellEl = document.querySelector(".shell");
    uiElements.drawerToggleBtn = document.getElementById(
      "drawerToggleBtn"
    );
    uiElements.resizeHandleEl = document.getElementById("resizeHandle");
    uiElements.w3cPreviewEl = document.getElementById(
      "w3cPreview"
    );
    uiElements.copyRawBtn = document.getElementById(
      "copyRawBtn"
    );
    uiElements.copyW3cBtn = document.getElementById(
      "copyW3cBtn"
    );
    uiElements.copyLogBtn = document.getElementById(
      "copyLogBtn"
    );
    uiElements.allowHexChk = document.getElementById(
      "allowHexChk"
    );
    uiElements.styleDictionaryChk = document.getElementById(
      "styleDictionaryChk"
    );
    uiElements.flatTokensChk = document.getElementById(
      "flatTokensChk"
    );
    uiElements.githubRememberChk = document.getElementById(
      "githubRememberChk"
    );
    uiElements.importScopeOverlay = document.getElementById("importScopeOverlay");
    uiElements.importScopeBody = document.getElementById("importScopeBody");
    uiElements.importScopeConfirmBtn = document.getElementById(
      "importScopeConfirmBtn"
    );
    uiElements.importScopeCancelBtn = document.getElementById(
      "importScopeCancelBtn"
    );
    uiElements.importScopeRememberChk = document.getElementById(
      "importScopeRememberChk"
    );
    uiElements.importScopeMissingEl = document.getElementById(
      "importScopeMissingNotice"
    );
    uiElements.importScopeSummaryEl = document.getElementById("importScopeSummary");
    uiElements.importScopeSummaryTextEl = document.getElementById(
      "importScopeSummaryText"
    );
    uiElements.importScopeClearBtn = document.getElementById(
      "importScopeClearBtn"
    );
    uiElements.importSkipLogListEl = document.getElementById("importSkipLogList");
    uiElements.importSkipLogEmptyEl = document.getElementById("importSkipLogEmpty");
  }

  // src/app/ui/utils.ts
  function log(msg) {
    const t = (/* @__PURE__ */ new Date()).toLocaleTimeString();
    const line = document.createElement("div");
    line.textContent = "[" + t + "] " + msg;
    if (uiElements.logEl) {
      uiElements.logEl.appendChild(line);
      uiElements.logEl.scrollTop = uiElements.logEl.scrollHeight;
    }
  }
  function postToPlugin(message) {
    parent.postMessage({ pluginMessage: message }, "*");
  }
  function prettyJson(obj) {
    try {
      return JSON.stringify(obj, null, 2);
    } catch (e) {
      return String(obj);
    }
  }
  function copyElText(el, label) {
    var _a;
    if (!el) return;
    try {
      const text = (_a = el.textContent) != null ? _a : "";
      if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
        navigator.clipboard.writeText(text).then(() => {
          log(`Copied ${label} to clipboard.`);
        }).catch(() => {
          throw new Error("clipboard write failed");
        });
        return;
      }
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.style.position = "fixed";
      ta.style.opacity = "0";
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, ta.value.length);
      const ok = document.execCommand("copy");
      document.body.removeChild(ta);
      if (ok) log(`Copied ${label} to clipboard (${text.length} chars).`);
      else throw new Error("execCommand(copy) returned false");
    } catch (e) {
      log(`Could not copy ${label}.`);
    }
  }

  // src/app/ui/state.ts
  var appState = {
    importPreference: null,
    importLogEntries: [],
    importScopeModalState: null,
    lastImportSelection: [],
    systemDarkMode: false,
    // Export state
    pendingSave: null,
    // Resize state
    resizeTracking: null,
    resizeQueued: null,
    resizeRaf: 0,
    // Collections state
    currentCollections: []
  };

  // src/app/ui/storage.ts
  var IMPORT_PREF_KEY = "dtcg.importPreference.v1";
  var IMPORT_LOG_KEY = "dtcg.importLog.v1";
  function normalizeContextList(list) {
    var _a;
    const seen = /* @__PURE__ */ new Set();
    const out = [];
    for (let i = 0; i < list.length; i++) {
      const raw = String((_a = list[i]) != null ? _a : "").trim();
      if (!raw) continue;
      if (seen.has(raw)) continue;
      seen.add(raw);
      out.push(raw);
    }
    out.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    return out;
  }
  function contextsEqual(a, b) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
    return true;
  }
  function readImportPreference() {
    var _a;
    try {
      const raw = (_a = window.localStorage) == null ? void 0 : _a.getItem(IMPORT_PREF_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object") return null;
      const ctxs = Array.isArray(parsed.contexts) ? normalizeContextList(parsed.contexts) : [];
      const ts = typeof parsed.updatedAt === "number" ? Number(parsed.updatedAt) : Date.now();
      if (ctxs.length > 0) return { contexts: ctxs, updatedAt: ts };
    } catch (e) {
    }
    return null;
  }
  function writeImportPreference(pref) {
    var _a;
    try {
      (_a = window.localStorage) == null ? void 0 : _a.setItem(IMPORT_PREF_KEY, JSON.stringify(pref));
    } catch (e) {
    }
  }
  function removeImportPreference() {
    var _a;
    try {
      (_a = window.localStorage) == null ? void 0 : _a.removeItem(IMPORT_PREF_KEY);
    } catch (e) {
    }
  }
  function readImportLog() {
    var _a;
    try {
      const raw = (_a = window.localStorage) == null ? void 0 : _a.getItem(IMPORT_LOG_KEY);
      if (!raw) return [];
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) return [];
      const entries = [];
      for (let i = 0; i < parsed.length; i++) {
        const entry = parsed[i];
        if (!entry || typeof entry !== "object") continue;
        const timestamp = typeof entry.timestamp === "number" ? Number(entry.timestamp) : null;
        const summary = entry.summary;
        const source = entry.source === "github" ? "github" : entry.source === "local" ? "local" : void 0;
        if (!timestamp || !summary || typeof summary !== "object") continue;
        if (!Array.isArray(summary.appliedContexts) || !Array.isArray(summary.availableContexts))
          continue;
        if (!Array.isArray(summary.tokensWithRemovedContexts)) {
          summary.tokensWithRemovedContexts = [];
        }
        if (!Array.isArray(summary.skippedContexts)) {
          summary.skippedContexts = [];
        }
        if (!Array.isArray(summary.missingRequestedContexts)) {
          summary.missingRequestedContexts = [];
        }
        if (typeof summary.createdStyles !== "number" || !isFinite(summary.createdStyles)) {
          summary.createdStyles = 0;
        }
        entries.push({ timestamp, summary, source });
      }
      entries.sort((a, b) => a.timestamp - b.timestamp);
      return entries;
    } catch (e) {
      return [];
    }
  }
  function writeImportLog(entries) {
    var _a;
    try {
      (_a = window.localStorage) == null ? void 0 : _a.setItem(IMPORT_LOG_KEY, JSON.stringify(entries));
    } catch (e) {
    }
  }

  // src/app/ui/features/import.ts
  function formatContextList(contexts) {
    const normalized = normalizeContextList(contexts);
    if (normalized.length === 0) return "All contexts";
    const grouped = /* @__PURE__ */ new Map();
    for (let i = 0; i < normalized.length; i++) {
      const ctx = normalized[i];
      const slash = ctx.indexOf("/");
      const collection = slash >= 0 ? ctx.slice(0, slash) : ctx;
      const mode = slash >= 0 ? ctx.slice(slash + 1) : "Mode 1";
      const coll = collection ? collection : "Tokens";
      const modes = grouped.get(coll) || [];
      if (!grouped.has(coll)) grouped.set(coll, modes);
      if (!modes.includes(mode)) modes.push(mode);
    }
    const parts = [];
    const collections = Array.from(grouped.keys()).sort(
      (a, b) => a < b ? -1 : a > b ? 1 : 0
    );
    for (let i = 0; i < collections.length; i++) {
      const coll = collections[i];
      const modes = grouped.get(coll) || [];
      modes.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.push(`${coll} (${modes.join(", ")})`);
    }
    return parts.join("; ");
  }
  function renderImportPreferenceSummary() {
    if (!uiElements.importScopeSummaryEl || !uiElements.importScopeSummaryTextEl)
      return;
    const hasPref = !!appState.importPreference && appState.importPreference.contexts.length > 0;
    if (uiElements.importScopeClearBtn)
      uiElements.importScopeClearBtn.disabled = !hasPref;
    if (!hasPref) {
      uiElements.importScopeSummaryEl.hidden = true;
      return;
    }
    uiElements.importScopeSummaryEl.hidden = false;
    const when = new Date(
      appState.importPreference.updatedAt
    ).toLocaleString();
    uiElements.importScopeSummaryTextEl.textContent = `Remembered import scope (${when}): ${formatContextList(
      appState.importPreference.contexts
    )}.`;
  }
  function renderImportLog() {
    if (!(uiElements.importSkipLogListEl && uiElements.importSkipLogEmptyEl))
      return;
    uiElements.importSkipLogListEl.innerHTML = "";
    if (!appState.importLogEntries || appState.importLogEntries.length === 0) {
      uiElements.importSkipLogEmptyEl.hidden = false;
      return;
    }
    uiElements.importSkipLogEmptyEl.hidden = true;
    for (let idx = appState.importLogEntries.length - 1; idx >= 0; idx--) {
      const entry = appState.importLogEntries[idx];
      const container = document.createElement("div");
      container.className = "import-skip-log-entry";
      const header = document.createElement("div");
      header.className = "import-skip-log-entry-header";
      const label = entry.source === "github" ? "GitHub import" : "Manual import";
      header.textContent = `${label} \u2022 ${new Date(
        entry.timestamp
      ).toLocaleString()}`;
      container.appendChild(header);
      const stats = document.createElement("div");
      stats.className = "import-skip-log-entry-stats";
      const tokensText = `Imported ${entry.summary.importedTokens} of ${entry.summary.totalTokens} tokens.`;
      const stylesCreated = typeof entry.summary.createdStyles === "number" ? entry.summary.createdStyles : void 0;
      if (typeof stylesCreated === "number") {
        const stylesLabel = stylesCreated === 1 ? "style" : "styles";
        stats.textContent = `${tokensText} ${stylesCreated} ${stylesLabel} created.`;
      } else {
        stats.textContent = tokensText;
      }
      container.appendChild(stats);
      const contextsLine = document.createElement("div");
      contextsLine.className = "import-skip-log-entry-contexts";
      contextsLine.textContent = "Applied: " + formatContextList(entry.summary.appliedContexts);
      container.appendChild(contextsLine);
      if (entry.summary.skippedContexts.length > 0) {
        const skippedLine = document.createElement("div");
        skippedLine.className = "import-skip-log-entry-contexts";
        skippedLine.textContent = "Skipped modes: " + formatContextList(
          entry.summary.skippedContexts.map((s) => s.context)
        );
        container.appendChild(skippedLine);
      }
      if (entry.summary.missingRequestedContexts.length > 0) {
        const missingLine = document.createElement("div");
        missingLine.className = "import-skip-log-entry-note";
        missingLine.textContent = "Not found in file: " + formatContextList(entry.summary.missingRequestedContexts);
        container.appendChild(missingLine);
      }
      if (entry.summary.selectionFallbackToAll) {
        const fallbackLine = document.createElement("div");
        fallbackLine.className = "import-skip-log-entry-note";
        fallbackLine.textContent = "Requested modes were missing; imported all contexts instead.";
        container.appendChild(fallbackLine);
      }
      if (entry.summary.tokensWithRemovedContexts.length > 0) {
        const tokenList = document.createElement("ul");
        tokenList.className = "import-skip-log-token-list";
        const maxTokens = Math.min(
          entry.summary.tokensWithRemovedContexts.length,
          10
        );
        for (let t = 0; t < maxTokens; t++) {
          const tok = entry.summary.tokensWithRemovedContexts[t];
          const li = document.createElement("li");
          const removedLabel = tok.removedContexts.length > 0 ? formatContextList(tok.removedContexts) : "none";
          const keptLabel = tok.keptContexts.length > 0 ? formatContextList(tok.keptContexts) : "";
          li.textContent = `${tok.path} \u2014 skipped ${removedLabel}${keptLabel ? "; kept " + keptLabel : ""}`;
          tokenList.appendChild(li);
        }
        if (entry.summary.tokensWithRemovedContexts.length > maxTokens) {
          const more = document.createElement("li");
          more.textContent = `\u2026and ${entry.summary.tokensWithRemovedContexts.length - maxTokens} more token(s).`;
          tokenList.appendChild(more);
        }
        container.appendChild(tokenList);
      }
      if (entry.summary.skippedContexts.length > 0 && appState.importPreference && appState.importPreference.contexts.length > 0) {
        const tip = document.createElement("div");
        tip.className = "import-skip-log-entry-note";
        tip.textContent = "Tip: Clear the remembered import selection to restore skipped modes.";
        container.appendChild(tip);
      }
      uiElements.importSkipLogListEl.appendChild(container);
    }
  }
  function addImportLogEntry(entry) {
    appState.importLogEntries.push(entry);
    if (appState.importLogEntries.length > 10) {
      appState.importLogEntries = appState.importLogEntries.slice(
        appState.importLogEntries.length - 10
      );
    }
    writeImportLog(appState.importLogEntries);
    renderImportLog();
  }
  function setImportPreference(contexts) {
    const normalized = normalizeContextList(contexts);
    if (normalized.length === 0) {
      clearImportPreference(false);
      return;
    }
    const same = appState.importPreference && contextsEqual(appState.importPreference.contexts, normalized);
    appState.importPreference = { contexts: normalized, updatedAt: Date.now() };
    writeImportPreference(appState.importPreference);
    renderImportPreferenceSummary();
    if (!same) log("Remembered import selection for future imports.");
  }
  function clearImportPreference(logChange) {
    if (!appState.importPreference) return;
    appState.importPreference = null;
    removeImportPreference();
    renderImportPreferenceSummary();
    if (logChange)
      log(
        "Cleared remembered import selection. Next import will prompt for modes."
      );
  }
  function collectContextsFromJson(root) {
    const grouped = /* @__PURE__ */ new Map();
    function visit(node, path) {
      if (Array.isArray(node)) {
        for (let i = 0; i < node.length; i++) visit(node[i], path);
        return;
      }
      if (!node || typeof node !== "object") return;
      const obj = node;
      if (Object.prototype.hasOwnProperty.call(obj, "$value")) {
        const rawCollection = path[0] ? String(path[0]).trim() : "Tokens";
        let mode = "Mode 1";
        try {
          const ext = obj["$extensions"];
          if (ext && typeof ext === "object") {
            const cf = ext["com.figma"];
            if (cf && typeof cf === "object" && typeof cf.modeName === "string") {
              const candidate = String(cf.modeName).trim();
              if (candidate) mode = candidate;
            }
          }
        } catch (e) {
        }
        const collection = rawCollection ? rawCollection : "Tokens";
        const set = grouped.get(collection) || /* @__PURE__ */ new Set();
        if (!grouped.has(collection)) grouped.set(collection, set);
        set.add(mode);
        return;
      }
      for (const key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;
        if (key.startsWith("$")) continue;
        visit(obj[key], path.concat(String(key)));
      }
    }
    visit(root, []);
    const options = [];
    const collections = Array.from(grouped.keys()).sort(
      (a, b) => a < b ? -1 : a > b ? 1 : 0
    );
    for (let i = 0; i < collections.length; i++) {
      const collection = collections[i];
      const modes = Array.from(grouped.get(collection) || []).sort(
        (a, b) => a < b ? -1 : a > b ? 1 : 0
      );
      for (let j = 0; j < modes.length; j++) {
        const mode = modes[j];
        options.push({
          context: `${collection}/${mode}`,
          collection,
          mode
        });
      }
    }
    return options;
  }
  function updateImportScopeConfirmState() {
    if (!appState.importScopeModalState) return;
    const state = appState.importScopeModalState;
    let allCollectionsSelected = true;
    for (let i = 0; i < state.collections.length; i++) {
      const collection = state.collections[i];
      const inputs = state.inputsByCollection.get(collection) || [];
      if (!inputs.some((input) => input.checked)) {
        allCollectionsSelected = false;
        break;
      }
    }
    if (uiElements.importScopeConfirmBtn) {
      uiElements.importScopeConfirmBtn.disabled = !allCollectionsSelected;
      const label = state.collections.length > 1 ? "Import selected modes" : "Import selected mode";
      uiElements.importScopeConfirmBtn.textContent = label;
    }
  }
  var importScopeKeyListenerAttached = false;
  function handleImportScopeKeydown(ev) {
    if (ev.key === "Escape") {
      ev.preventDefault();
      closeImportScopeModal();
    }
  }
  function openImportScopeModal(opts) {
    var _a;
    if (!uiElements.importScopeOverlay || !uiElements.importScopeBody || !uiElements.importScopeConfirmBtn || !uiElements.importScopeCancelBtn) {
      opts.onConfirm(opts.initialSelection, opts.rememberInitially);
      return;
    }
    uiElements.importScopeBody.innerHTML = "";
    const grouped = /* @__PURE__ */ new Map();
    for (let i = 0; i < opts.options.length; i++) {
      const option = opts.options[i];
      const list = grouped.get(option.collection) || [];
      if (!grouped.has(option.collection))
        grouped.set(option.collection, list);
      list.push(option);
    }
    const collections = Array.from(grouped.keys()).sort(
      (a, b) => a < b ? -1 : a > b ? 1 : 0
    );
    appState.importScopeModalState = {
      options: opts.options,
      collections,
      inputs: [],
      inputsByCollection: /* @__PURE__ */ new Map(),
      onConfirm: opts.onConfirm
    };
    const initialSelectionsByCollection = /* @__PURE__ */ new Map();
    for (let i = 0; i < opts.initialSelection.length; i++) {
      const ctx = opts.initialSelection[i];
      const match = opts.options.find((opt) => opt.context === ctx);
      if (match)
        initialSelectionsByCollection.set(match.collection, match.context);
    }
    for (let i = 0; i < collections.length; i++) {
      const collection = collections[i];
      const groupEl = document.createElement("div");
      groupEl.className = "import-scope-group";
      const heading = document.createElement("h3");
      heading.textContent = collection;
      groupEl.appendChild(heading);
      const modes = (grouped.get(collection) || []).sort(
        (a, b) => a.mode < b.mode ? -1 : a.mode > b.mode ? 1 : 0
      );
      const defaultContext = initialSelectionsByCollection.get(collection) || ((_a = modes[0]) == null ? void 0 : _a.context) || null;
      const radioName = `importScopeMode_${i}`;
      for (let j = 0; j < modes.length; j++) {
        const opt = modes[j];
        const label = document.createElement("label");
        label.className = "import-scope-mode";
        const radio = document.createElement("input");
        radio.type = "radio";
        radio.name = radioName;
        radio.value = opt.context;
        radio.checked = defaultContext === opt.context;
        radio.addEventListener("change", updateImportScopeConfirmState);
        appState.importScopeModalState.inputs.push(radio);
        const list = appState.importScopeModalState.inputsByCollection.get(
          collection
        ) || [];
        if (!appState.importScopeModalState.inputsByCollection.has(
          collection
        )) {
          appState.importScopeModalState.inputsByCollection.set(
            collection,
            list
          );
        }
        list.push(radio);
        const span = document.createElement("span");
        span.textContent = opt.mode;
        label.appendChild(radio);
        label.appendChild(span);
        groupEl.appendChild(label);
      }
      uiElements.importScopeBody.appendChild(groupEl);
    }
    if (uiElements.importScopeRememberChk)
      uiElements.importScopeRememberChk.checked = opts.rememberInitially;
    if (uiElements.importScopeMissingEl) {
      if (opts.missingPreferred.length > 0) {
        uiElements.importScopeMissingEl.hidden = false;
        uiElements.importScopeMissingEl.textContent = "Previously remembered modes not present in this file: " + formatContextList(opts.missingPreferred);
      } else {
        uiElements.importScopeMissingEl.hidden = true;
        uiElements.importScopeMissingEl.textContent = "";
      }
    }
    updateImportScopeConfirmState();
    uiElements.importScopeOverlay.hidden = false;
    uiElements.importScopeOverlay.classList.add("is-open");
    uiElements.importScopeOverlay.setAttribute("aria-hidden", "false");
    if (!importScopeKeyListenerAttached) {
      window.addEventListener("keydown", handleImportScopeKeydown, true);
      importScopeKeyListenerAttached = true;
    }
    if (uiElements.importScopeConfirmBtn)
      uiElements.importScopeConfirmBtn.focus();
  }
  function closeImportScopeModal() {
    if (!uiElements.importScopeOverlay) return;
    uiElements.importScopeOverlay.classList.remove("is-open");
    uiElements.importScopeOverlay.hidden = true;
    uiElements.importScopeOverlay.setAttribute("aria-hidden", "true");
    if (importScopeKeyListenerAttached) {
      window.removeEventListener("keydown", handleImportScopeKeydown, true);
      importScopeKeyListenerAttached = false;
    }
    appState.importScopeModalState = null;
  }
  function performImport(json, allowHex, contexts) {
    const normalized = normalizeContextList(contexts);
    const payload = normalized.length > 0 ? {
      type: "IMPORT_DTCG",
      payload: {
        json,
        allowHexStrings: allowHex,
        contexts: normalized
      }
    } : {
      type: "IMPORT_DTCG",
      payload: { json, allowHexStrings: allowHex }
    };
    postToPlugin(payload);
    appState.lastImportSelection = normalized.slice();
    const label = normalized.length > 0 ? formatContextList(normalized) : "all contexts";
    log(`Import requested (${label}).`);
  }
  function startImportFlow(json, allowHex) {
    const options = collectContextsFromJson(json);
    if (options.length === 0) {
      performImport(json, allowHex, []);
      return;
    }
    const grouped = /* @__PURE__ */ new Map();
    for (let i = 0; i < options.length; i++) {
      const option = options[i];
      const list = grouped.get(option.collection) || [];
      if (!grouped.has(option.collection))
        grouped.set(option.collection, list);
      list.push(option);
    }
    const availableSet = new Set(options.map((opt) => opt.context));
    const missingPreferred = [];
    let rememberInitially = false;
    const initialSelectionsByCollection = /* @__PURE__ */ new Map();
    if (appState.importPreference && appState.importPreference.contexts.length > 0) {
      for (let i = 0; i < appState.importPreference.contexts.length; i++) {
        const ctx = appState.importPreference.contexts[i];
        if (availableSet.has(ctx)) {
          const match = options.find((opt) => opt.context === ctx);
          if (match) {
            initialSelectionsByCollection.set(
              match.collection,
              match.context
            );
            rememberInitially = true;
          }
        } else {
          missingPreferred.push(ctx);
        }
      }
    }
    const collections = Array.from(grouped.keys()).sort(
      (a, b) => a < b ? -1 : a > b ? 1 : 0
    );
    for (let i = 0; i < collections.length; i++) {
      const collection = collections[i];
      if (!initialSelectionsByCollection.has(collection)) {
        const modes = (grouped.get(collection) || []).sort(
          (a, b) => a.mode < b.mode ? -1 : a.mode > b.mode ? 1 : 0
        );
        if (modes.length > 0)
          initialSelectionsByCollection.set(collection, modes[0].context);
      }
    }
    const initialSelection = collections.map((collection) => initialSelectionsByCollection.get(collection)).filter((ctx) => typeof ctx === "string");
    const requiresChoice = collections.some((collection) => {
      const list = grouped.get(collection) || [];
      return list.length > 1;
    });
    if (!requiresChoice) {
      performImport(json, allowHex, initialSelection);
      return;
    }
    openImportScopeModal({
      options,
      initialSelection,
      rememberInitially,
      missingPreferred,
      onConfirm: (selected, remember) => {
        if (remember) setImportPreference(selected);
        else if (appState.importPreference) clearImportPreference(true);
        performImport(json, allowHex, selected);
      }
    });
  }
  function getPreferredImportContexts() {
    if (appState.importPreference && appState.importPreference.contexts.length > 0)
      return appState.importPreference.contexts.slice();
    if (appState.lastImportSelection.length > 0)
      return appState.lastImportSelection.slice();
    return [];
  }

  // src/app/ui/features/export.ts
  function prettyExportName(original) {
    const name = original && typeof original === "string" ? original : "tokens.json";
    const m = name.match(/^(.*)_mode=(.*)\.tokens\.json$/);
    if (m) {
      const collection = m[1].trim();
      const mode = m[2].trim();
      return `${collection} - ${mode}.json`;
    }
    return name.endsWith(".json") ? name : name + ".json";
  }
  function supportsFilePicker() {
    return typeof window.showSaveFilePicker === "function";
  }
  async function beginPendingSave(suggestedName) {
    try {
      if (!supportsFilePicker()) return false;
      const handle = await window.showSaveFilePicker({
        suggestedName,
        types: [
          {
            description: "JSON",
            accept: { "application/json": [".json"] }
          }
        ]
      });
      const writable = await handle.createWritable();
      appState.pendingSave = { writable, name: suggestedName };
      return true;
    } catch (e) {
      appState.pendingSave = null;
      return false;
    }
  }
  async function finishPendingSave(text) {
    if (!appState.pendingSave) return false;
    try {
      await appState.pendingSave.writable.write(
        new Blob([text], { type: "application/json" })
      );
      await appState.pendingSave.writable.close();
      return true;
    } catch (e) {
      try {
        await appState.pendingSave.writable.close();
      } catch (e2) {
      }
      return false;
    } finally {
      appState.pendingSave = null;
    }
  }
  function triggerJsonDownload(filename, text) {
    try {
      const blob = new Blob([text], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.style.position = "absolute";
      a.style.left = "-9999px";
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        URL.revokeObjectURL(url);
        a.remove();
      }, 0);
    } catch (e) {
    }
  }

  // src/app/ui/features/resize.ts
  function postResize(width, height) {
    const w = Math.max(720, Math.min(1600, Math.floor(width)));
    const h = Math.max(420, Math.min(1200, Math.floor(height)));
    postToPlugin({ type: "UI_RESIZE", payload: { width: w, height: h } });
  }
  function queueResize(width, height) {
    appState.resizeQueued = { width, height };
    if (appState.resizeRaf !== 0) return;
    appState.resizeRaf = window.requestAnimationFrame(() => {
      appState.resizeRaf = 0;
      if (!appState.resizeQueued) return;
      postResize(appState.resizeQueued.width, appState.resizeQueued.height);
      appState.resizeQueued = null;
    });
  }
  function applyResizeDelta(ev) {
    if (!appState.resizeTracking || ev.pointerId !== appState.resizeTracking.pointerId)
      return;
    const dx = ev.clientX - appState.resizeTracking.startX;
    const dy = ev.clientY - appState.resizeTracking.startY;
    const nextW = appState.resizeTracking.startWidth + dx;
    const nextH = appState.resizeTracking.startHeight + dy;
    queueResize(nextW, nextH);
    ev.preventDefault();
  }
  function endResize(ev) {
    if (!appState.resizeTracking || ev.pointerId !== appState.resizeTracking.pointerId)
      return;
    applyResizeDelta(ev);
    window.removeEventListener("pointermove", handleResizeMove, true);
    window.removeEventListener("pointerup", endResize, true);
    window.removeEventListener("pointercancel", cancelResize, true);
    if (uiElements.resizeHandleEl) {
      try {
        uiElements.resizeHandleEl.releasePointerCapture(
          appState.resizeTracking.pointerId
        );
      } catch (e) {
      }
    }
    appState.resizeTracking = null;
  }
  function cancelResize(ev) {
    if (!appState.resizeTracking || ev.pointerId !== appState.resizeTracking.pointerId)
      return;
    window.removeEventListener("pointermove", handleResizeMove, true);
    window.removeEventListener("pointerup", endResize, true);
    window.removeEventListener("pointercancel", cancelResize, true);
    if (uiElements.resizeHandleEl) {
      try {
        uiElements.resizeHandleEl.releasePointerCapture(
          appState.resizeTracking.pointerId
        );
      } catch (e) {
      }
    }
    appState.resizeTracking = null;
  }
  function handleResizeMove(ev) {
    applyResizeDelta(ev);
  }
  function autoFitOnce() {
    if (typeof document === "undefined") return;
    const contentW = Math.max(
      document.documentElement.scrollWidth,
      document.body ? document.body.scrollWidth : 0
    );
    const contentH = Math.max(
      document.documentElement.scrollHeight,
      document.body ? document.body.scrollHeight : 0
    );
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const needsW = contentW > vw ? contentW : vw;
    const needsH = contentH > vh ? contentH : vh;
    if (needsW > vw || needsH > vh) postResize(needsW, needsH);
  }

  // src/app/ui.ts
  var prefersDarkQuery = typeof window !== "undefined" && typeof window.matchMedia === "function" ? window.matchMedia("(prefers-color-scheme: dark)") : null;
  function applyTheme() {
    if (typeof document === "undefined") return;
    const effective = appState.systemDarkMode ? "dark" : "light";
    const root = document.documentElement;
    if (effective === "light") {
      root.setAttribute("data-theme", "light");
    } else {
      root.removeAttribute("data-theme");
    }
    root.style.colorScheme = effective;
  }
  function primeTheme() {
    if (!prefersDarkQuery) {
      applyTheme();
      return;
    }
    appState.systemDarkMode = prefersDarkQuery.matches;
    applyTheme();
    prefersDarkQuery.addEventListener("change", (e) => {
      appState.systemDarkMode = e.matches;
      applyTheme();
    });
  }
  primeTheme();
  var githubUi = createGithubUi({
    postToPlugin: (message) => postToPlugin(message),
    log: (message) => log(message),
    getLogElement: () => uiElements.logEl,
    getCollectionSelect: () => uiElements.collectionSelect,
    getModeSelect: () => uiElements.modeSelect,
    getAllowHexCheckbox: () => uiElements.allowHexChk,
    getStyleDictionaryCheckbox: () => uiElements.styleDictionaryChk,
    getFlatTokensCheckbox: () => uiElements.flatTokensChk,
    getImportContexts: () => getPreferredImportContexts()
  });
  function clearSelect(sel) {
    while (sel.options.length > 0) sel.remove(0);
  }
  function setDisabledStates() {
    if (uiElements.importBtn && uiElements.fileInput) {
      const hasFile = !!(uiElements.fileInput.files && uiElements.fileInput.files.length > 0);
      uiElements.importBtn.disabled = !hasFile;
    }
    if (uiElements.exportBtn && uiElements.exportAllChk && uiElements.collectionSelect && uiElements.modeSelect && uiElements.exportPickers) {
      const exportAll = !!uiElements.exportAllChk.checked;
      if (exportAll) {
        uiElements.exportBtn.disabled = false;
        uiElements.exportPickers.style.opacity = "0.5";
      } else {
        uiElements.exportPickers.style.opacity = "1";
        const hasSelection = !!uiElements.collectionSelect.value && !!uiElements.modeSelect.value;
        uiElements.exportBtn.disabled = !hasSelection;
      }
    }
    if (uiElements.exportTypographyBtn) {
      uiElements.exportTypographyBtn.disabled = false;
    }
  }
  function populateCollections(data) {
    appState.currentCollections = data.collections;
    if (!(uiElements.collectionSelect && uiElements.modeSelect)) return;
    clearSelect(uiElements.collectionSelect);
    for (let i = 0; i < data.collections.length; i++) {
      const c = data.collections[i];
      const opt = document.createElement("option");
      opt.value = c.name;
      opt.textContent = c.name;
      uiElements.collectionSelect.appendChild(opt);
    }
    onCollectionChange();
  }
  function onCollectionChange() {
    if (!(uiElements.collectionSelect && uiElements.modeSelect)) return;
    const selected = uiElements.collectionSelect.value;
    clearSelect(uiElements.modeSelect);
    let firstModeSet = false;
    for (let i = 0; i < appState.currentCollections.length; i++) {
      const c = appState.currentCollections[i];
      if (c.name === selected) {
        for (let j = 0; j < c.modes.length; j++) {
          const m = c.modes[j];
          const opt = document.createElement("option");
          opt.value = m.name;
          opt.textContent = m.name;
          uiElements.modeSelect.appendChild(opt);
        }
        if (uiElements.modeSelect.options.length > 0 && uiElements.modeSelect.selectedIndex === -1) {
          uiElements.modeSelect.selectedIndex = 0;
          firstModeSet = true;
        }
        break;
      }
    }
    setDisabledStates();
    githubUi.onSelectionChange();
    if (firstModeSet) requestPreviewForCurrent();
  }
  function applyLastSelection(last) {
    if (!last || !(uiElements.collectionSelect && uiElements.modeSelect))
      return;
    let found = false;
    for (let i = 0; i < uiElements.collectionSelect.options.length; i++) {
      if (uiElements.collectionSelect.options[i].value === last.collection) {
        uiElements.collectionSelect.selectedIndex = i;
        found = true;
        break;
      }
    }
    onCollectionChange();
    if (found) {
      for (let j = 0; j < uiElements.modeSelect.options.length; j++) {
        if (uiElements.modeSelect.options[j].value === last.mode) {
          uiElements.modeSelect.selectedIndex = j;
          break;
        }
      }
    }
    setDisabledStates();
  }
  function requestPreviewForCurrent() {
    if (!(uiElements.collectionSelect && uiElements.modeSelect)) return;
    const collection = uiElements.collectionSelect.value || "";
    const mode = uiElements.modeSelect.value || "";
    if (!collection || !mode) {
      if (uiElements.w3cPreviewEl)
        uiElements.w3cPreviewEl.textContent = "{ /* select a collection & mode to preview */ }";
      return;
    }
    const styleDictionary = !!(uiElements.styleDictionaryChk && uiElements.styleDictionaryChk.checked);
    const flatTokens = !!(uiElements.flatTokensChk && uiElements.flatTokensChk.checked);
    postToPlugin({
      type: "PREVIEW_REQUEST",
      payload: { collection, mode, styleDictionary, flatTokens }
    });
  }
  window.addEventListener("message", async (event) => {
    var _a, _b, _c, _d, _e;
    const data = event.data;
    if (!data || typeof data !== "object") return;
    let msg = null;
    if (data.pluginMessage && typeof data.pluginMessage === "object") {
      const maybe = data.pluginMessage;
      if (maybe && typeof maybe.type === "string") msg = maybe;
    }
    if (!msg) return;
    if (msg.type === "ERROR") {
      log("ERROR: " + ((_b = (_a = msg.payload) == null ? void 0 : _a.message) != null ? _b : ""));
      return;
    }
    if (msg.type === "INFO") {
      log((_d = (_c = msg.payload) == null ? void 0 : _c.message) != null ? _d : "");
      return;
    }
    if (msg.type === "IMPORT_SUMMARY") {
      const summary = msg.payload.summary;
      if (summary && Array.isArray(summary.appliedContexts)) {
        appState.lastImportSelection = summary.appliedContexts.slice();
      } else {
        appState.lastImportSelection = [];
      }
      addImportLogEntry({
        timestamp: msg.payload.timestamp,
        source: msg.payload.source,
        summary
      });
      renderImportPreferenceSummary();
      return;
    }
    if (githubUi.handleMessage(msg)) return;
    if (msg.type === "EXPORT_RESULT") {
      const files = Array.isArray((_e = msg.payload) == null ? void 0 : _e.files) ? msg.payload.files : [];
      if (files.length === 0) {
        log("Nothing to export.");
        return;
      }
      if (appState.pendingSave && files.length === 1) {
        const only = files[0];
        const fname = prettyExportName(only == null ? void 0 : only.name);
        const text = prettyJson(only == null ? void 0 : only.json);
        const ok = await finishPendingSave(text);
        if (ok) {
          log("Saved " + fname + " via file picker.");
          const div = document.createElement("div");
          const link = document.createElement("a");
          link.href = "#";
          link.textContent = "Download " + fname + " again";
          link.addEventListener("click", (e) => {
            e.preventDefault();
            triggerJsonDownload(fname, text);
          });
          if (uiElements.logEl) {
            div.appendChild(link);
            uiElements.logEl.appendChild(div);
            uiElements.logEl.scrollTop = uiElements.logEl.scrollHeight;
          }
          log("Export ready.");
          return;
        }
        log(
          "Could not write via file picker; falling back to download links."
        );
      }
      setDrawerOpen(true);
      for (let k = 0; k < files.length; k++) {
        const f = files[k];
        const fname = prettyExportName(f == null ? void 0 : f.name);
        const text = prettyJson(f == null ? void 0 : f.json);
        triggerJsonDownload(fname, text);
        const div = document.createElement("div");
        const link = document.createElement("a");
        link.href = "#";
        link.textContent = "Download " + fname;
        link.addEventListener("click", (e) => {
          e.preventDefault();
          triggerJsonDownload(fname, text);
        });
        if (uiElements.logEl) {
          div.appendChild(link);
          uiElements.logEl.appendChild(div);
          uiElements.logEl.scrollTop = uiElements.logEl.scrollHeight;
        }
      }
      log("Export ready.");
      return;
    }
    if (msg.type === "W3C_PREVIEW") {
      const displayName = prettyExportName(msg.payload.name);
      const header = `/* ${displayName} */
`;
      if (uiElements.w3cPreviewEl)
        uiElements.w3cPreviewEl.textContent = header + prettyJson(msg.payload.json);
      return;
    }
    if (msg.type === "COLLECTIONS_DATA") {
      githubUi.onCollectionsData({
        collections: msg.payload.collections,
        textStyles: msg.payload.textStylesCount ? new Array(msg.payload.textStylesCount).fill({
          id: "",
          name: ""
        }) : []
      });
      populateCollections({ collections: msg.payload.collections });
      if (uiElements.exportAllChk)
        uiElements.exportAllChk.checked = !!msg.payload.exportAllPref;
      if (uiElements.styleDictionaryChk && typeof msg.payload.styleDictionaryPref === "boolean") {
        uiElements.styleDictionaryChk.checked = !!msg.payload.styleDictionaryPref;
      }
      if (uiElements.flatTokensChk && typeof msg.payload.flatTokensPref === "boolean") {
        uiElements.flatTokensChk.checked = !!msg.payload.flatTokensPref;
      }
      if (uiElements.allowHexChk && typeof msg.payload.allowHexPref === "boolean") {
        uiElements.allowHexChk.checked = !!msg.payload.allowHexPref;
      }
      if (typeof msg.payload.githubRememberPref === "boolean") {
        if (uiElements.githubRememberChk)
          uiElements.githubRememberChk.checked = msg.payload.githubRememberPref;
      }
      const last = msg.payload.last;
      applyLastSelection(last);
      setDisabledStates();
      requestPreviewForCurrent();
      return;
    }
    if (msg.type === "RAW_COLLECTIONS_TEXT") {
      if (uiElements.rawEl) uiElements.rawEl.textContent = msg.payload.text;
      return;
    }
  });
  document.addEventListener("DOMContentLoaded", () => {
    if (typeof document === "undefined") return;
    initDomElements();
    if (!prefersDarkQuery) applyTheme();
    appState.importPreference = readImportPreference();
    appState.importLogEntries = readImportLog();
    renderImportPreferenceSummary();
    renderImportLog();
    if (uiElements.importScopeClearBtn) {
      uiElements.importScopeClearBtn.addEventListener(
        "click",
        () => clearImportPreference(true)
      );
    }
    if (uiElements.importScopeConfirmBtn) {
      uiElements.importScopeConfirmBtn.addEventListener("click", () => {
        if (!appState.importScopeModalState) {
          closeImportScopeModal();
          return;
        }
        const state = appState.importScopeModalState;
        const selections = [];
        for (let i = 0; i < state.collections.length; i++) {
          const collection = state.collections[i];
          const inputs = state.inputsByCollection.get(collection) || [];
          const selected = inputs.find((input) => input.checked);
          if (!selected) return;
          selections.push(selected.value);
        }
        const remember = uiElements.importScopeRememberChk ? !!uiElements.importScopeRememberChk.checked : false;
        closeImportScopeModal();
        state.onConfirm(selections, remember);
      });
    }
    if (uiElements.importScopeCancelBtn) {
      uiElements.importScopeCancelBtn.addEventListener(
        "click",
        () => closeImportScopeModal()
      );
    }
    if (uiElements.importScopeOverlay) {
      uiElements.importScopeOverlay.addEventListener("click", (ev) => {
        if (ev.target === uiElements.importScopeOverlay)
          closeImportScopeModal();
      });
    }
    if (uiElements.resizeHandleEl) {
      uiElements.resizeHandleEl.addEventListener(
        "pointerdown",
        (event) => {
          if (event.button !== 0 && event.pointerType === "mouse") return;
          if (appState.resizeTracking) return;
          event.preventDefault();
          appState.resizeTracking = {
            pointerId: event.pointerId,
            startX: event.clientX,
            startY: event.clientY,
            startWidth: window.innerWidth,
            startHeight: window.innerHeight
          };
          try {
            uiElements.resizeHandleEl.setPointerCapture(
              event.pointerId
            );
          } catch (e) {
          }
          window.addEventListener("pointermove", handleResizeMove, true);
          window.addEventListener("pointerup", endResize, true);
          window.addEventListener("pointercancel", cancelResize, true);
        }
      );
    }
    githubUi.attach({ document, window });
    if (uiElements.fileInput)
      uiElements.fileInput.addEventListener("change", setDisabledStates);
    if (uiElements.exportAllChk) {
      uiElements.exportAllChk.addEventListener("change", () => {
        setDisabledStates();
        postToPlugin({
          type: "SAVE_PREFS",
          payload: { exportAll: !!uiElements.exportAllChk.checked }
        });
        githubUi.onSelectionChange();
      });
    }
    if (uiElements.styleDictionaryChk) {
      uiElements.styleDictionaryChk.addEventListener("change", () => {
        postToPlugin({
          type: "SAVE_PREFS",
          payload: {
            styleDictionary: !!uiElements.styleDictionaryChk.checked
          }
        });
        requestPreviewForCurrent();
        githubUi.onSelectionChange();
      });
    }
    if (uiElements.flatTokensChk) {
      uiElements.flatTokensChk.addEventListener("change", () => {
        postToPlugin({
          type: "SAVE_PREFS",
          payload: { flatTokens: !!uiElements.flatTokensChk.checked }
        });
        requestPreviewForCurrent();
        githubUi.onSelectionChange();
      });
    }
    if (uiElements.githubRememberChk) {
      uiElements.githubRememberChk.addEventListener("change", () => {
        postToPlugin({
          type: "SAVE_PREFS",
          payload: {
            githubRememberToken: !!uiElements.githubRememberChk.checked
          }
        });
      });
    }
    if (uiElements.refreshBtn) {
      uiElements.refreshBtn.addEventListener("click", () => {
        postToPlugin({ type: "FETCH_COLLECTIONS" });
      });
    }
    if (uiElements.importBtn && uiElements.fileInput) {
      uiElements.importBtn.addEventListener("click", () => {
        if (!uiElements.fileInput.files || uiElements.fileInput.files.length === 0) {
          log("Select a JSON file first.");
          return;
        }
        const reader = new FileReader();
        reader.onload = function() {
          try {
            const text = String(reader.result);
            const json = JSON.parse(text);
            if (!json || typeof json !== "object" || json instanceof Array) {
              log(
                "Invalid JSON structure for tokens (expected an object)."
              );
              return;
            }
            const allowHex = !!(uiElements.allowHexChk && uiElements.allowHexChk.checked);
            startImportFlow(json, allowHex);
          } catch (e) {
            const msg = e instanceof Error ? e.message : String(e);
            log("Failed to parse JSON: " + msg);
          }
        };
        reader.readAsText(uiElements.fileInput.files[0]);
      });
    }
    if (uiElements.exportBtn) {
      uiElements.exportBtn.addEventListener("click", async () => {
        var _a, _b;
        let exportAll = false;
        if (uiElements.exportAllChk)
          exportAll = !!uiElements.exportAllChk.checked;
        const styleDictionary = !!(uiElements.styleDictionaryChk && uiElements.styleDictionaryChk.checked);
        const flatTokens = !!(uiElements.flatTokensChk && uiElements.flatTokensChk.checked);
        const payload = { exportAll, styleDictionary, flatTokens };
        if (!exportAll && uiElements.collectionSelect && uiElements.modeSelect) {
          payload.collection = uiElements.collectionSelect.value;
          payload.mode = uiElements.modeSelect.value;
          if (!(payload.collection && payload.mode)) {
            log('Pick collection and mode or use "Export all".');
            return;
          }
        }
        const suggestedName = exportAll ? "tokens.json" : prettyExportName(
          `${(_a = payload.collection) != null ? _a : "Tokens"}_mode=${(_b = payload.mode) != null ? _b : "Mode 1"}.tokens.json`
        );
        await beginPendingSave(suggestedName);
        postToPlugin({ type: "EXPORT_DTCG", payload });
        if (exportAll) log("Export all requested.");
        else
          log(
            `Export requested for "${payload.collection || ""}" / "${payload.mode || ""}".`
          );
      });
    }
    if (uiElements.exportTypographyBtn) {
      uiElements.exportTypographyBtn.addEventListener("click", async () => {
        await beginPendingSave("typography.json");
        postToPlugin({ type: "EXPORT_TYPOGRAPHY" });
        log("Typography export requested.");
      });
    }
    if (uiElements.drawerToggleBtn) {
      uiElements.drawerToggleBtn.addEventListener("click", () => {
        const current = uiElements.drawerToggleBtn.getAttribute("aria-expanded") === "true";
        setDrawerOpen(!current);
      });
    }
    if (uiElements.collectionSelect) {
      uiElements.collectionSelect.addEventListener("change", () => {
        onCollectionChange();
        if (uiElements.collectionSelect && uiElements.modeSelect) {
          postToPlugin({
            type: "SAVE_LAST",
            payload: {
              collection: uiElements.collectionSelect.value,
              mode: uiElements.modeSelect.value
            }
          });
          requestPreviewForCurrent();
        }
        githubUi.onSelectionChange();
      });
    }
    if (uiElements.modeSelect) {
      uiElements.modeSelect.addEventListener("change", () => {
        if (uiElements.collectionSelect && uiElements.modeSelect) {
          postToPlugin({
            type: "SAVE_LAST",
            payload: {
              collection: uiElements.collectionSelect.value,
              mode: uiElements.modeSelect.value
            }
          });
        }
        setDisabledStates();
        requestPreviewForCurrent();
        githubUi.onSelectionChange();
      });
    }
    if (uiElements.copyRawBtn)
      uiElements.copyRawBtn.addEventListener(
        "click",
        () => copyElText(uiElements.rawEl, "Raw Figma Collections")
      );
    if (uiElements.copyW3cBtn)
      uiElements.copyW3cBtn.addEventListener(
        "click",
        () => copyElText(uiElements.w3cPreviewEl, "W3C Preview")
      );
    if (uiElements.copyLogBtn)
      uiElements.copyLogBtn.addEventListener(
        "click",
        () => copyElText(uiElements.logEl, "Log")
      );
    githubUi.onSelectionChange();
    autoFitOnce();
    if (uiElements.rawEl)
      uiElements.rawEl.textContent = "Loading variable collections\u2026";
    setDisabledStates();
    setDrawerOpen(getSavedDrawerOpen());
    postToPlugin({ type: "UI_READY" });
    setInterval(() => {
      postToPlugin({ type: "PING" });
    }, 500);
  });
  function setDrawerOpen(open) {
    if (uiElements.shellEl) {
      if (open) uiElements.shellEl.classList.remove("drawer-collapsed");
      else uiElements.shellEl.classList.add("drawer-collapsed");
    }
    if (uiElements.drawerToggleBtn) {
      uiElements.drawerToggleBtn.setAttribute(
        "aria-expanded",
        open ? "true" : "false"
      );
      uiElements.drawerToggleBtn.textContent = open ? "Hide" : "Show";
      uiElements.drawerToggleBtn.title = open ? "Hide log" : "Show log";
    }
    try {
      window.localStorage.setItem("drawerOpen", open ? "1" : "0");
    } catch (e) {
    }
  }
  function getSavedDrawerOpen() {
    try {
      const v = window.localStorage.getItem("drawerOpen");
      if (v === "0") return false;
      if (v === "1") return true;
    } catch (e) {
    }
    return true;
  }
})();
//# sourceMappingURL=ui.js.map
</script>
    <script>
      // Scope tab behavior PER PANEL so multiple tab groups don't interfere.
      (function () {
        const panels = Array.from(document.querySelectorAll('.panel, .drawer'));
        panels.forEach(container => {
          const tabBtns = Array.from(container.querySelectorAll('.tabs .tab-btn'));
          if (tabBtns.length === 0) return;

          const body = container.querySelector('.panel-body, .drawer-body') || container;
          const tabPanels = Array.from(body.querySelectorAll('.tab-panel'));

          function activate(name) {
            tabBtns.forEach(b => {
              const on = b.getAttribute('data-tab') === name;
              b.classList.toggle('is-active', on);
              b.setAttribute('aria-selected', String(on));
            });
            tabPanels.forEach(p => {
              const on = p.getAttribute('data-tab') === name;
              p.classList.toggle('is-active', on);
              if (on) p.scrollTop = 0;
            });
          }

          tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
              const name = btn.getAttribute('data-tab');
              if (name) activate(name);
            });
          });

          // Initialize to the first .is-active button, or default to the first button
          const initial = tabBtns.find(b => b.classList.contains('is-active')) || tabBtns[0];
          if (initial) {
            const name = initial.getAttribute('data-tab');
            if (name) activate(name);
          }
        });
      })();
    </script>
</body>

</html>
