{
  "version": 3,
  "sources": ["../src/app/collections.ts", "../src/core/normalize.ts", "../src/core/typography.ts", "../src/core/color.ts", "../src/adapters/dtcg-reader.ts", "../src/adapters/dtcg-writer.ts", "../src/core/figma-cache.ts", "../src/core/ir.ts", "../src/adapters/figma-reader.ts", "../src/adapters/figma-writer.ts", "../src/core/pipeline.ts", "../src/core/github/api.ts", "../src/app/github/folders.ts", "../src/app/github/handlers/state.ts", "../src/app/github/handlers/repos.ts", "../src/app/github/handlers/auth.ts", "../src/app/github/handlers/branches.ts", "../src/app/github/handlers/folders.ts", "../src/app/github/filenames.ts", "../src/app/github/handlers/commits.ts", "../src/app/github/handlers/import.ts", "../src/app/github/dispatcher.ts", "../src/app/main.ts"],
  "sourcesContent": ["// src/app/collections.ts\n// Helpers for enumerating variable collections and analyzing selection state.\n\nexport async function snapshotCollectionsForUi(): Promise<{\n    collections: Array<{\n        id: string;\n        name: string;\n        modes: Array<{ id: string; name: string }>;\n        variables: Array<{ id: string; name: string; type: string }>;\n    }>;\n    rawText: string;\n    checksum: string;\n    textStylesCount: number;\n}> {\n    if (typeof figma.editorType !== \"string\" || figma.editorType !== \"figma\") {\n        return {\n            collections: [],\n            rawText:\n                \"Variables API is not available in this editor.\\n\" +\n                \"Open a Figma Design file (not FigJam) and try again.\",\n            checksum: \"\",\n            textStylesCount: 0,\n        };\n    }\n    if (\n        typeof figma.variables === \"undefined\" ||\n        typeof figma.variables.getLocalVariableCollectionsAsync !==\n            \"function\" ||\n        typeof figma.variables.getVariableByIdAsync !== \"function\"\n    ) {\n        return {\n            collections: [],\n            rawText:\n                \"Variables API methods not found. Ensure your Figma version supports Variables and try again.\",\n            checksum: \"\",\n            textStylesCount: 0,\n        };\n    }\n\n    const locals: VariableCollection[] =\n        await figma.variables.getLocalVariableCollectionsAsync();\n    const allVars = await figma.variables.getLocalVariablesAsync();\n    const varsById = new Map<string, Variable>();\n    for (const v of allVars) {\n        varsById.set(v.id, v);\n    }\n\n    const out: Array<{\n        id: string;\n        name: string;\n        modes: Array<{ id: string; name: string }>;\n        variables: Array<{ id: string; name: string; type: string }>;\n    }> = [];\n    const rawLines: string[] = [];\n    const checksumParts: string[] = [];\n\n    for (let i = 0; i < locals.length; i++) {\n        const c = locals[i];\n        if (!c) continue;\n\n        const modes: Array<{ id: string; name: string }> = [];\n        for (let mi = 0; mi < c.modes.length; mi++) {\n            const m = c.modes[mi];\n            modes.push({ id: m.modeId, name: m.name });\n        }\n\n        // Include collection metadata in checksum\n        checksumParts.push(`C:${c.id}:${c.name}`);\n\n        // Include mode metadata in checksum\n        const modeSigs = c.modes.map((m) => `${m.modeId}:${m.name}`);\n        checksumParts.push(`M:${modeSigs.join(\",\")}`);\n\n        const varsList: Array<{ id: string; name: string; type: string }> = [];\n        const varLines: string[] = [];\n\n        for (let vi = 0; vi < c.variableIds.length; vi++) {\n            const varId = c.variableIds[vi];\n            const v = varsById.get(varId);\n            if (!v) continue;\n            varsList.push({ id: v.id, name: v.name, type: v.resolvedType });\n\n            // Capture values for change detection (internal use only, not logged)\n            const values: string[] = [];\n            for (const m of c.modes) {\n                const val = v.valuesByMode[m.modeId];\n                values.push(JSON.stringify(val));\n            }\n            varLines.push(`    - ${v.name} [${v.resolvedType}]`);\n            // Include variable name and type in checksum\n            checksumParts.push(\n                `V:${v.id}:${v.name}:${v.resolvedType}:${values.join(\",\")}`\n            );\n        }\n\n        out.push({ id: c.id, name: c.name, modes: modes, variables: varsList });\n\n        rawLines.push(\"Collection: \" + c.name + \" (\" + c.id + \")\");\n        const modeNames: string[] = modes.map((m) => m.name);\n        rawLines.push(\n            \"  Modes: \" +\n                (modeNames.length > 0 ? modeNames.join(\", \") : \"(none)\")\n        );\n        rawLines.push(\"  Variables (\" + String(varsList.length) + \"):\");\n        rawLines.push(...varLines);\n        rawLines.push(\"\");\n    }\n\n    if (out.length === 0) {\n        rawLines.push(\"No local Variable Collections found.\");\n        rawLines.push(\"Create one in the Variables panel, then press Refresh.\");\n    }\n\n    let textStylesCount = 0;\n    if (typeof figma.getLocalTextStyles === \"function\") {\n        const textStyles = figma.getLocalTextStyles();\n        textStylesCount = textStyles.length;\n        rawLines.push(\"\");\n        rawLines.push(\"Text styles: \" + String(textStyles.length));\n        for (let si = 0; si < textStyles.length; si++) {\n            const style = textStyles[si];\n            rawLines.push(\"  - \" + style.name);\n        }\n        if (textStyles.length === 0) {\n            rawLines.push(\"  (No local text styles found.)\");\n        }\n    }\n\n    return {\n        collections: out,\n        rawText: rawLines.join(\"\\n\"),\n        checksum: checksumParts.join(\"|\"),\n        textStylesCount,\n    };\n}\n\nexport function safeKeyFromCollectionAndMode(\n    collectionName: string,\n    modeName: string\n): string {\n    const base = collectionName + \"/mode=\" + modeName;\n    let out = \"\";\n    for (let i = 0; i < base.length; i++) {\n        const ch = base.charAt(i);\n        out += ch === \"/\" || ch === \"\\\\\" || ch === \":\" ? \"_\" : ch;\n    }\n    return out;\n}\n\nexport async function analyzeSelectionState(\n    collectionName: string,\n    modeName: string\n): Promise<{\n    ok: boolean;\n    message?: string;\n    variableCount?: number;\n    variablesWithValues?: number;\n}> {\n    try {\n        const snap = await snapshotCollectionsForUi();\n        const col = snap.collections.find((c) => c.name === collectionName);\n        if (!col)\n            return {\n                ok: false,\n                message: `Collection \"${collectionName}\" not found in this file.`,\n            };\n        if (!col.variables || col.variables.length === 0) {\n            return {\n                ok: false,\n                message: `Collection \"${collectionName}\" has no local variables.`,\n            };\n        }\n        const mode = col.modes.find((m) => m.name === modeName);\n        if (!mode)\n            return {\n                ok: false,\n                message: `Mode \"${modeName}\" not found in collection \"${collectionName}\".`,\n            };\n\n        let withValues = 0;\n        for (const v of col.variables) {\n            const full = await figma.variables.getVariableByIdAsync(v.id);\n            if (full && full.valuesByMode && mode.id in full.valuesByMode)\n                withValues++;\n        }\n        return {\n            ok: true,\n            variableCount: col.variables.length,\n            variablesWithValues: withValues,\n        };\n    } catch (e) {\n        return {\n            ok: false,\n            message: (e as Error)?.message || \"Analysis failed\",\n        };\n    }\n}\n", "// src/core/normalize.ts\n// Shared helpers for names, paths, alias parsing, and graph checks.\n// - Normalizes paths so adapters stay in sync\n// - Provides alias analysis utilities for validation and exports\n\nimport type { TokenGraph, TokenNode, ValueOrAlias } from \"./ir\";\n\n/* =========================\n   Naming & Path Utilities\n   ========================= */\n/** Slug a single path segment for lookup (never for emission). */\nexport function slugSegment(s: string): string {\n    return String(s)\n        .trim()\n        .replace(/\\s+/g, \"-\") // collapse whitespace to '-'\n        .replace(/-+/g, \"-\") // collapse runs of '-'\n        .toLowerCase();\n}\n\n/**\n * Return a canonical token path using Figma's display names.\n * Always splits variable names on '/', trims segments, and removes empties.\n */\nexport function canonicalPath(\n    collection: string,\n    variableName: string\n): string[] {\n    const segs = String(variableName)\n        .split(\"/\")\n        .map((s) => s.trim())\n        .filter(Boolean);\n    return [collection, ...segs];\n}\n\nexport function toDot(path: string[]): string {\n    let i = 0,\n        s = \"\";\n    for (i = 0; i < path.length; i++) {\n        if (i > 0) s += \".\";\n        s += path[i];\n    }\n    return s;\n}\n\nexport function toAliasString(path: string[]): string {\n    return \"{\" + toDot(path) + \"}\";\n}\n\nexport function parseAliasString(s: string): string[] | null {\n    if (typeof s !== \"string\") return null;\n    if (s.length < 3) return null;\n    if (s.charAt(0) !== \"{\" || s.charAt(s.length - 1) !== \"}\") return null;\n    const inner = s.substring(1, s.length - 1);\n    if (!inner) return null;\n    return inner.split(\".\");\n}\n\n/* =========================\n   Graph Utilities\n   ========================= */\n\n/**\n * Deduplicate tokens by slash path and sort them for stable comparisons.\n * Keeps adapters from reordering content across reads/writes.\n */\nexport function normalize(graph: TokenGraph): TokenGraph {\n    const seen: { [k: string]: 1 } = {};\n    const copy: TokenNode[] = [];\n    let i = 0;\n    for (i = 0; i < graph.tokens.length; i++) {\n        const t = graph.tokens[i];\n        const key = slashPath(t.path);\n        if (!seen[key]) {\n            seen[key] = 1;\n            copy.push(t);\n        }\n    }\n    copy.sort(function (a, b) {\n        const da = toDot(a.path);\n        const db = toDot(b.path);\n        if (da < db) return -1;\n        if (da > db) return 1;\n        return 0;\n    });\n    return { tokens: copy };\n}\n\nfunction slashPath(path: string[]): string {\n    let i = 0,\n        s = \"\";\n    for (i = 0; i < path.length; i++) {\n        if (i > 0) s += \"/\";\n        s += path[i];\n    }\n    return s;\n}\n\n/** Build a dot-path index for quick alias resolution. */\nexport function indexByDotPath(graph: TokenGraph): {\n    [dot: string]: TokenNode;\n} {\n    const idx: { [dot: string]: TokenNode } = {};\n    let i = 0;\n    for (i = 0; i < graph.tokens.length; i++) {\n        const t = graph.tokens[i];\n        idx[toDot(t.path)] = t;\n    }\n    return idx;\n}\n\n/** Type guard: true if the value is an alias entry. */\nexport function isAlias(\n    v: ValueOrAlias\n): v is { kind: \"alias\"; path: string[] } {\n    return !!v && v.kind === \"alias\";\n}\n\n/**\n * Walk alias edges to find missing references and cycles.\n * Useful for validation before exporting or writing to Figma.\n */\nexport function analyzeAliases(graph: TokenGraph): {\n    missing: string[];\n    cycles: string[][];\n} {\n    const idx = indexByDotPath(graph);\n    const edges: { [from: string]: string[] } = {};\n    const nodes: string[] = [];\n\n    let i = 0;\n    for (i = 0; i < graph.tokens.length; i++) {\n        const t = graph.tokens[i];\n        const from = toDot(t.path);\n        nodes.push(from);\n        edges[from] = [];\n        const ctxKeys = keysOf(t.byContext);\n        let k = 0;\n        for (k = 0; k < ctxKeys.length; k++) {\n            const ctx = ctxKeys[k];\n            const val = t.byContext[ctx];\n            if (isAlias(val)) {\n                const to = toDot(val.path);\n                edges[from].push(to);\n            }\n        }\n    }\n\n    const missing: string[] = [];\n    let u = 0;\n    for (u = 0; u < nodes.length; u++) {\n        const n = nodes[u];\n        const outs = edges[n];\n        let j = 0;\n        for (j = 0; j < outs.length; j++) {\n            const target = outs[j];\n            if (!idx[target]) {\n                let seen = false;\n                let m = 0;\n                for (m = 0; m < missing.length; m++)\n                    if (missing[m] === target) {\n                        seen = true;\n                        break;\n                    }\n                if (!seen) missing.push(target);\n            }\n        }\n    }\n\n    const WHITE = 0,\n        GRAY = 1,\n        BLACK = 2;\n    const color: { [node: string]: number } = {};\n    for (u = 0; u < nodes.length; u++) color[nodes[u]] = WHITE;\n\n    const cycles: string[][] = [];\n\n    function dfs(start: string, stack: string[]): boolean {\n        color[start] = GRAY;\n        stack.push(start);\n        const arr = edges[start];\n        let p = 0;\n        for (p = 0; p < arr.length; p++) {\n            const v = arr[p];\n            if (color[v] === WHITE) {\n                if (dfs(v, stack)) return true;\n            } else if (color[v] === GRAY) {\n                let ci = stack.length - 1;\n                const cyc: string[] = [];\n                while (ci >= 0 && stack[ci] !== v) {\n                    ci--;\n                }\n                if (ci >= 0) {\n                    let w = ci;\n                    for (w = ci; w < stack.length; w++) cyc.push(stack[w]);\n                    cyc.push(v);\n                }\n                cycles.push(cyc);\n                return true;\n            }\n        }\n        stack.pop();\n        color[start] = BLACK;\n        return false;\n    }\n\n    for (u = 0; u < nodes.length; u++) {\n        const node = nodes[u];\n        if (color[node] === WHITE) {\n            const stack: string[] = [];\n            dfs(node, stack);\n        }\n    }\n\n    return { missing: missing, cycles: cycles };\n}\n\nfunction keysOf<T>(obj: { [k: string]: T }): string[] {\n    const keys: string[] = [];\n    let k: string;\n    for (k in obj)\n        if (Object.prototype.hasOwnProperty.call(obj, k)) keys.push(k);\n    return keys;\n}\n", "// src/core/typography.ts\n// Shared helpers for representing typography tokens and converting Figma text styles.\n\nexport type DimensionUnit = \"pixel\" | \"percent\";\n\nexport interface DimensionValue {\n    value: number;\n    unit: DimensionUnit;\n}\n\ntype SerializedDimensionUnit = \"px\" | \"percent\";\n\ninterface SerializedDimensionValue {\n    value: number;\n    unit: SerializedDimensionUnit;\n}\n\nexport type LineHeightValue = DimensionValue | \"auto\";\n\nexport type FigmaDimensionUnit = \"PIXELS\" | \"PERCENT\";\n\nexport interface FigmaDimensionValue {\n    value: number;\n    unit: FigmaDimensionUnit;\n}\n\nexport type FigmaLineHeightValue =\n    | { unit: \"AUTO\" }\n    | { unit: FigmaDimensionUnit; value: number };\n\nexport interface TypographyFigmaExtension {\n    fontStyle?: string;\n    fontVariant?: string;\n    letterSpacing?: FigmaDimensionValue;\n    lineHeight?: FigmaLineHeightValue;\n    paragraphSpacing?: number;\n    paragraphIndent?: number;\n    listSpacing?: number;\n    hangingPunctuation?: boolean;\n    hangingList?: boolean;\n    leadingTrim?: unknown;\n    textCase?: string;\n    textDecoration?: string;\n    textAlignHorizontal?: string;\n    textAlignVertical?: string;\n    textAutoResize?: string;\n    fills?: unknown;\n    strokes?: unknown;\n    [key: string]: unknown;\n}\n\nexport interface TypographyValue {\n    fontFamily?: string;\n    fontStyle?: string;\n    fontWeight?: string;\n    fontSize?: DimensionValue;\n    lineHeight?: LineHeightValue;\n    letterSpacing?: DimensionValue;\n    paragraphSpacing?: DimensionValue;\n    paragraphIndent?: DimensionValue;\n    textCase?: string;\n    textDecoration?: string;\n    textAlignHorizontal?: string;\n    textAlignVertical?: string;\n    fontVariant?: string;\n    [key: string]: unknown;\n}\n\nexport interface TypographyFromTextStyleResult {\n    value: TypographyValue;\n    figma: TypographyFigmaExtension;\n}\n\nconst KNOWN_KEYS: { [k: string]: true } = {\n    fontFamily: true,\n    fontStyle: true,\n    fontWeight: true,\n    fontSize: true,\n    lineHeight: true,\n    letterSpacing: true,\n    paragraphSpacing: true,\n    paragraphIndent: true,\n    textCase: true,\n    textDecoration: true,\n    textAlignHorizontal: true,\n    textAlignVertical: true,\n    fontVariant: true,\n};\n\nfunction isFiniteNumber(v: unknown): v is number {\n    return typeof v === \"number\" && isFinite(v);\n}\n\nfunction normalizeUnit(raw: unknown): DimensionUnit | null {\n    if (typeof raw !== \"string\") return null;\n    const lower = raw.trim().toLowerCase();\n    if (lower === \"pixel\" || lower === \"pixels\" || lower === \"px\")\n        return \"pixel\";\n    if (lower === \"percent\" || lower === \"percentage\" || lower === \"%\")\n        return \"percent\";\n    return null;\n}\n\nfunction parseDimension(raw: unknown): DimensionValue | null {\n    if (!raw || typeof raw !== \"object\") return null;\n    const obj = raw as Record<string, unknown>;\n    const value = obj.value;\n    const unit = normalizeUnit(obj.unit);\n    if (!isFiniteNumber(value) || !unit) return null;\n    return { value, unit };\n}\n\nfunction parsePixelDimension(raw: unknown): DimensionValue | null {\n    if (raw && typeof raw === \"object\" && !Array.isArray(raw)) {\n        return parseDimension(raw);\n    }\n    if (isFiniteNumber(raw)) {\n        return { value: raw, unit: \"pixel\" };\n    }\n    return null;\n}\n\n// Parse a JSON-friendly payload into the normalized typography value shape expected by the pipeline.\nexport function parseTypographyValue(raw: unknown): TypographyValue | null {\n    if (!raw || typeof raw !== \"object\" || Array.isArray(raw)) return null;\n    const obj = raw as Record<string, unknown>;\n    const value: TypographyValue = {};\n    let recognized = false;\n\n    if (\n        typeof obj.fontFamily === \"string\" &&\n        obj.fontFamily.trim().length > 0\n    ) {\n        value.fontFamily = obj.fontFamily;\n        recognized = true;\n    }\n    if (typeof obj.fontStyle === \"string\" && obj.fontStyle.trim().length > 0) {\n        value.fontStyle = obj.fontStyle;\n        recognized = true;\n    }\n    if (\n        typeof obj.fontWeight === \"string\" &&\n        obj.fontWeight.trim().length > 0\n    ) {\n        value.fontWeight = obj.fontWeight;\n        recognized = true;\n    }\n    if (\n        typeof obj.fontVariant === \"string\" &&\n        obj.fontVariant.trim().length > 0\n    ) {\n        value.fontVariant = obj.fontVariant;\n        recognized = true;\n    }\n\n    const fontSize = parseDimension(obj.fontSize);\n    if (fontSize) {\n        value.fontSize = fontSize;\n        recognized = true;\n    }\n\n    const rawLineHeight = obj.lineHeight;\n    if (typeof rawLineHeight === \"number\") {\n        if (isFiniteNumber(rawLineHeight)) {\n            value.lineHeight = { value: rawLineHeight * 100, unit: \"percent\" };\n            recognized = true;\n        }\n    } else if (typeof rawLineHeight === \"string\") {\n        if (rawLineHeight.trim().toLowerCase() === \"auto\") {\n            value.lineHeight = \"auto\";\n            recognized = true;\n        }\n    } else {\n        const lineHeight = parseDimension(rawLineHeight);\n        if (lineHeight) {\n            value.lineHeight = lineHeight;\n            recognized = true;\n        }\n    }\n\n    const letterSpacing = parseDimension(obj.letterSpacing);\n    if (letterSpacing) {\n        value.letterSpacing = letterSpacing;\n        recognized = true;\n    }\n\n    const paragraphSpacing = parsePixelDimension(obj.paragraphSpacing);\n    if (paragraphSpacing) {\n        value.paragraphSpacing = paragraphSpacing;\n        recognized = true;\n    }\n\n    const paragraphIndent = parsePixelDimension(obj.paragraphIndent);\n    if (paragraphIndent) {\n        value.paragraphIndent = paragraphIndent;\n        recognized = true;\n    }\n\n    if (typeof obj.textCase === \"string\" && obj.textCase.trim().length > 0) {\n        value.textCase = obj.textCase;\n        recognized = true;\n    }\n\n    if (\n        typeof obj.textDecoration === \"string\" &&\n        obj.textDecoration.trim().length > 0\n    ) {\n        value.textDecoration = obj.textDecoration;\n        recognized = true;\n    }\n\n    if (\n        typeof obj.textAlignHorizontal === \"string\" &&\n        obj.textAlignHorizontal.trim().length > 0\n    ) {\n        value.textAlignHorizontal = obj.textAlignHorizontal;\n        recognized = true;\n    }\n\n    if (\n        typeof obj.textAlignVertical === \"string\" &&\n        obj.textAlignVertical.trim().length > 0\n    ) {\n        value.textAlignVertical = obj.textAlignVertical;\n        recognized = true;\n    }\n\n    // Preserve additional custom fields to avoid data loss.\n    for (const key of Object.keys(obj)) {\n        if (KNOWN_KEYS[key]) continue;\n        const v = obj[key];\n        if (typeof v === \"undefined\") continue;\n        (value as Record<string, unknown>)[key] = v;\n    }\n\n    return recognized ? value : null;\n}\n\nfunction normalizeLetterSpacingForSerialization(\n    letterSpacing: DimensionValue | undefined,\n    fontSizePx: number | undefined\n): SerializedDimensionValue | undefined {\n    if (!letterSpacing) return undefined;\n    if (letterSpacing.unit === \"pixel\") {\n        return { value: letterSpacing.value, unit: \"px\" };\n    }\n    if (letterSpacing.unit === \"percent\" && typeof fontSizePx === \"number\") {\n        return { value: (letterSpacing.value / 100) * fontSizePx, unit: \"px\" };\n    }\n    return undefined;\n}\n\nfunction normalizeLineHeightForSerialization(\n    lineHeight: LineHeightValue | undefined,\n    fontSizePx: number | undefined\n): number | \"auto\" | undefined {\n    if (!lineHeight) return undefined;\n    if (lineHeight === \"auto\") return \"auto\";\n    if (lineHeight.unit === \"percent\") {\n        return lineHeight.value / 100;\n    }\n    if (\n        lineHeight.unit === \"pixel\" &&\n        typeof fontSizePx === \"number\" &&\n        fontSizePx !== 0\n    ) {\n        return lineHeight.value / fontSizePx;\n    }\n    return undefined;\n}\n\n// Convert a normalized typography value into a DTCG-compliant fragment for export.\nexport function serializeTypographyValue(\n    value: TypographyValue\n): Record<string, unknown> {\n    const out: Record<string, unknown> = {};\n\n    if (typeof value.fontFamily === \"string\") out.fontFamily = value.fontFamily;\n    if (typeof value.fontWeight === \"string\") out.fontWeight = value.fontWeight;\n\n    const fontSizePx = ((): number | undefined => {\n        if (!value.fontSize) return undefined;\n        if (value.fontSize.unit === \"pixel\") {\n            const serialized: SerializedDimensionValue = {\n                value: value.fontSize.value,\n                unit: \"px\",\n            };\n            out.fontSize = serialized;\n            return value.fontSize.value;\n        }\n        return undefined;\n    })();\n\n    const normalizedLetterSpacing = normalizeLetterSpacingForSerialization(\n        value.letterSpacing,\n        fontSizePx\n    );\n    if (normalizedLetterSpacing) {\n        out.letterSpacing = normalizedLetterSpacing;\n    }\n\n    const normalizedLineHeight = normalizeLineHeightForSerialization(\n        value.lineHeight,\n        fontSizePx\n    );\n    if (typeof normalizedLineHeight !== \"undefined\") {\n        out.lineHeight = normalizedLineHeight;\n    }\n\n    return out;\n}\n\nfunction cloneDimensionIfFinite(\n    num: number | undefined\n): DimensionValue | undefined {\n    if (!isFiniteNumber(num)) return undefined;\n    return { value: num, unit: \"pixel\" };\n}\n\nconst TEXT_CASE_MAP: { [key: string]: string } = {\n    ORIGINAL: \"none\",\n    UPPER: \"uppercase\",\n    LOWER: \"lowercase\",\n    TITLE: \"capitalize\",\n    SMALL_CAPS: \"smallCaps\",\n    SMALL_CAPS_FORCED: \"smallCapsForced\",\n};\n\nconst TEXT_DECORATION_MAP: { [key: string]: string } = {\n    NONE: \"none\",\n    UNDERLINE: \"underline\",\n    STRIKETHROUGH: \"lineThrough\",\n};\n\nconst TEXT_ALIGN_HORIZONTAL_MAP: { [key: string]: string } = {\n    LEFT: \"left\",\n    RIGHT: \"right\",\n    CENTER: \"center\",\n    JUSTIFIED: \"justify\",\n};\n\nconst TEXT_ALIGN_VERTICAL_MAP: { [key: string]: string } = {\n    TOP: \"top\",\n    CENTER: \"center\",\n    BOTTOM: \"bottom\",\n};\n\nfunction inferFontStyle(style: string | undefined): string | undefined {\n    if (!style) return undefined;\n    const lower = style.trim().toLowerCase();\n    if (lower.includes(\"italic\") || lower.includes(\"oblique\")) return \"italic\";\n    return \"normal\";\n}\n\n// Read a Figma text style and produce the token value plus the Figma-specific extension metadata.\nexport function typographyValueFromTextStyle(\n    style: TextStyle\n): TypographyFromTextStyleResult {\n    const value: TypographyValue = {};\n    const figma: TypographyFigmaExtension = {};\n\n    const assignFigma = <K extends keyof TypographyFigmaExtension>(\n        key: K,\n        val: TypographyFigmaExtension[K]\n    ): void => {\n        if (typeof val === \"undefined\") return;\n        figma[key] = val;\n    };\n\n    const fontName = style.fontName as\n        | { family?: string; style?: string }\n        | undefined;\n    if (fontName && typeof fontName.family === \"string\") {\n        value.fontFamily = fontName.family;\n    }\n    if (fontName && typeof fontName.style === \"string\") {\n        value.fontWeight = fontName.style;\n        value.fontVariant = fontName.style;\n        value.fontStyle = inferFontStyle(fontName.style);\n        assignFigma(\"fontVariant\", fontName.style);\n        assignFigma(\"fontStyle\", fontName.style);\n    }\n\n    if (isFiniteNumber(style.fontSize)) {\n        value.fontSize = { value: style.fontSize, unit: \"pixel\" };\n    }\n\n    const lineHeight = style.lineHeight as\n        | { unit?: string; value?: number }\n        | undefined;\n    if (lineHeight && typeof lineHeight.unit === \"string\") {\n        const unit = lineHeight.unit;\n        if (unit === \"AUTO\") {\n            value.lineHeight = \"auto\";\n            assignFigma(\"lineHeight\", { unit: \"AUTO\" });\n        } else if (unit === \"PIXELS\" && isFiniteNumber(lineHeight.value)) {\n            value.lineHeight = { value: lineHeight.value, unit: \"pixel\" };\n            assignFigma(\"lineHeight\", {\n                unit: \"PIXELS\",\n                value: lineHeight.value,\n            });\n        } else if (unit === \"PERCENT\" && isFiniteNumber(lineHeight.value)) {\n            value.lineHeight = { value: lineHeight.value, unit: \"percent\" };\n            assignFigma(\"lineHeight\", {\n                unit: \"PERCENT\",\n                value: lineHeight.value,\n            });\n        }\n    }\n\n    const letterSpacing = style.letterSpacing as\n        | { unit?: string; value?: number }\n        | undefined;\n    if (\n        letterSpacing &&\n        typeof letterSpacing.unit === \"string\" &&\n        isFiniteNumber(letterSpacing.value)\n    ) {\n        if (letterSpacing.unit === \"PIXELS\") {\n            value.letterSpacing = { value: letterSpacing.value, unit: \"pixel\" };\n            assignFigma(\"letterSpacing\", {\n                unit: \"PIXELS\",\n                value: letterSpacing.value,\n            });\n        } else if (letterSpacing.unit === \"PERCENT\") {\n            value.letterSpacing = {\n                value: letterSpacing.value,\n                unit: \"percent\",\n            };\n            assignFigma(\"letterSpacing\", {\n                unit: \"PERCENT\",\n                value: letterSpacing.value,\n            });\n        }\n    }\n\n    const paragraphSpacing = cloneDimensionIfFinite(style.paragraphSpacing);\n    if (paragraphSpacing) {\n        value.paragraphSpacing = paragraphSpacing;\n        assignFigma(\"paragraphSpacing\", paragraphSpacing.value);\n    }\n\n    const paragraphIndent = cloneDimensionIfFinite(style.paragraphIndent);\n    if (paragraphIndent) {\n        value.paragraphIndent = paragraphIndent;\n        assignFigma(\"paragraphIndent\", paragraphIndent.value);\n    }\n\n    const textCase = (style as { textCase?: string }).textCase;\n    if (textCase && typeof textCase === \"string\") {\n        value.textCase = TEXT_CASE_MAP[textCase] || textCase.toLowerCase();\n        assignFigma(\"textCase\", textCase);\n    }\n\n    const textDecoration = (style as { textDecoration?: string })\n        .textDecoration;\n    if (textDecoration && typeof textDecoration === \"string\") {\n        value.textDecoration =\n            TEXT_DECORATION_MAP[textDecoration] || textDecoration.toLowerCase();\n        assignFigma(\"textDecoration\", textDecoration);\n    }\n\n    const textAlignHorizontal = (style as { textAlignHorizontal?: string })\n        .textAlignHorizontal;\n    if (textAlignHorizontal && typeof textAlignHorizontal === \"string\") {\n        value.textAlignHorizontal =\n            TEXT_ALIGN_HORIZONTAL_MAP[textAlignHorizontal] ||\n            textAlignHorizontal.toLowerCase();\n        assignFigma(\"textAlignHorizontal\", textAlignHorizontal);\n    }\n\n    const textAlignVertical = (style as { textAlignVertical?: string })\n        .textAlignVertical;\n    if (textAlignVertical && typeof textAlignVertical === \"string\") {\n        value.textAlignVertical =\n            TEXT_ALIGN_VERTICAL_MAP[textAlignVertical] ||\n            textAlignVertical.toLowerCase();\n        assignFigma(\"textAlignVertical\", textAlignVertical);\n    }\n\n    const leadingTrim = (style as { leadingTrim?: unknown }).leadingTrim;\n    if (typeof leadingTrim !== \"undefined\")\n        assignFigma(\"leadingTrim\", leadingTrim);\n\n    const listSpacing = (style as { listSpacing?: number }).listSpacing;\n    if (isFiniteNumber(listSpacing)) assignFigma(\"listSpacing\", listSpacing);\n\n    const hangingPunctuation = (style as { hangingPunctuation?: boolean })\n        .hangingPunctuation;\n    if (typeof hangingPunctuation === \"boolean\")\n        assignFigma(\"hangingPunctuation\", hangingPunctuation);\n\n    const hangingList = (style as { hangingList?: boolean }).hangingList;\n    if (typeof hangingList === \"boolean\")\n        assignFigma(\"hangingList\", hangingList);\n\n    const textAutoResize = (style as { textAutoResize?: string })\n        .textAutoResize;\n    if (typeof textAutoResize === \"string\")\n        assignFigma(\"textAutoResize\", textAutoResize);\n\n    const fills = (style as { fills?: unknown }).fills;\n    if (typeof fills !== \"undefined\") assignFigma(\"fills\", fills);\n\n    const strokes = (style as { strokes?: unknown }).strokes;\n    if (typeof strokes !== \"undefined\") assignFigma(\"strokes\", strokes);\n\n    // Drop undefined entries to keep payload compact.\n    const cleaned: TypographyValue = {};\n    for (const key of Object.keys(value)) {\n        const v = (value as Record<string, unknown>)[key];\n        if (typeof v === \"undefined\") continue;\n        cleaned[key] = v;\n    }\n\n    return { value: cleaned, figma };\n}\n\nfunction normalizeFontVariantName(style: string | undefined): string | null {\n    if (typeof style !== \"string\") return null;\n    const trimmed = style.trim();\n    if (!trimmed) return null;\n    const lower = trimmed.toLowerCase();\n    if (lower === \"italic\") return \"Italic\";\n    if (lower === \"normal\") return \"Regular\";\n    if (lower === \"oblique\") return \"Oblique\";\n    return trimmed;\n}\n\nexport interface TypographyFontNameResult {\n    fontName: FontName | null;\n    usedFallback: boolean;\n}\n\nexport function typographyFontNameFromValue(\n    value: TypographyValue\n): TypographyFontNameResult {\n    const family =\n        typeof value.fontFamily === \"string\" ? value.fontFamily.trim() : \"\";\n    if (!family) {\n        return { fontName: null, usedFallback: false };\n    }\n\n    const candidates: (string | null | undefined)[] = [\n        value.fontVariant,\n        value.fontWeight,\n        normalizeFontVariantName(value.fontStyle),\n    ];\n\n    for (const cand of candidates) {\n        if (typeof cand !== \"string\") continue;\n        const trimmed = cand.trim();\n        if (trimmed.length === 0) continue;\n        return { fontName: { family, style: trimmed }, usedFallback: false };\n    }\n\n    return { fontName: { family, style: \"Regular\" }, usedFallback: true };\n}\n\nfunction normalizeKey(raw: string | undefined): string | null {\n    if (typeof raw !== \"string\") return null;\n    const trimmed = raw.trim();\n    if (!trimmed) return null;\n    return trimmed.toLowerCase();\n}\n\nconst TEXT_CASE_REVERSE_MAP: { [key: string]: TextCase } = {\n    none: \"ORIGINAL\",\n    original: \"ORIGINAL\",\n    uppercase: \"UPPER\",\n    upper: \"UPPER\",\n    lowercase: \"LOWER\",\n    lower: \"LOWER\",\n    capitalize: \"TITLE\",\n    title: \"TITLE\",\n    smallcaps: \"SMALL_CAPS\",\n    \"small-caps\": \"SMALL_CAPS\",\n    smallcapsforced: \"SMALL_CAPS_FORCED\",\n    \"small-caps-forced\": \"SMALL_CAPS_FORCED\",\n};\n\nconst TEXT_DECORATION_REVERSE_MAP: { [key: string]: TextDecoration } = {\n    none: \"NONE\",\n    underline: \"UNDERLINE\",\n    strikethrough: \"STRIKETHROUGH\",\n    \"strike-through\": \"STRIKETHROUGH\",\n    linethrough: \"STRIKETHROUGH\",\n    \"line-through\": \"STRIKETHROUGH\",\n};\n\ntype FigmaTextAlignHorizontal = \"LEFT\" | \"CENTER\" | \"RIGHT\" | \"JUSTIFIED\";\ntype FigmaTextAlignVertical = \"TOP\" | \"CENTER\" | \"BOTTOM\";\n\nconst TEXT_ALIGN_HORIZONTAL_REVERSE_MAP: {\n    [key: string]: FigmaTextAlignHorizontal;\n} = {\n    left: \"LEFT\",\n    right: \"RIGHT\",\n    center: \"CENTER\",\n    justify: \"JUSTIFIED\",\n    justified: \"JUSTIFIED\",\n};\n\nconst TEXT_ALIGN_VERTICAL_REVERSE_MAP: {\n    [key: string]: FigmaTextAlignVertical;\n} = {\n    top: \"TOP\",\n    center: \"CENTER\",\n    middle: \"CENTER\",\n    bottom: \"BOTTOM\",\n};\n\nfunction mapTextCaseToFigma(raw: string | undefined): TextCase | null {\n    const key = normalizeKey(raw);\n    if (!key) return null;\n    return TEXT_CASE_REVERSE_MAP[key] || null;\n}\n\nfunction mapTextDecorationToFigma(\n    raw: string | undefined\n): TextDecoration | null {\n    const key = normalizeKey(raw);\n    if (!key) return null;\n    return TEXT_DECORATION_REVERSE_MAP[key] || null;\n}\n\nfunction mapTextAlignHorizontalToFigma(\n    raw: string | undefined\n): FigmaTextAlignHorizontal | null {\n    const key = normalizeKey(raw);\n    if (!key) return null;\n    return TEXT_ALIGN_HORIZONTAL_REVERSE_MAP[key] || null;\n}\n\nfunction mapTextAlignVerticalToFigma(\n    raw: string | undefined\n): FigmaTextAlignVertical | null {\n    const key = normalizeKey(raw);\n    if (!key) return null;\n    return TEXT_ALIGN_VERTICAL_REVERSE_MAP[key] || null;\n}\n\n// Apply a typography token to a Figma text style, returning warnings when values require manual follow-up.\nexport function applyTypographyValueToTextStyle(\n    style: TextStyle,\n    value: TypographyValue,\n    opts?: {\n        fontName?: FontName | null;\n        figma?: TypographyFigmaExtension | null;\n    }\n): string[] {\n    const warnings: string[] = [];\n\n    if (opts && opts.fontName) {\n        style.fontName = opts.fontName;\n    }\n\n    const figmaExt = opts && opts.figma ? opts.figma : null;\n\n    if (value.fontSize) {\n        if (value.fontSize.unit === \"pixel\") {\n            style.fontSize = value.fontSize.value;\n        } else {\n            warnings.push(\n                `fontSize unit \u201C${value.fontSize.unit}\u201D is not supported. Expected \"pixel\".`\n            );\n        }\n    }\n\n    const extLineHeight = figmaExt?.lineHeight;\n    style.lineHeight = { unit: \"AUTO\" };\n    if (extLineHeight) {\n        if (extLineHeight.unit === \"AUTO\") {\n            style.lineHeight = { unit: \"AUTO\" };\n        } else if (\n            (extLineHeight.unit === \"PIXELS\" ||\n                extLineHeight.unit === \"PERCENT\") &&\n            isFiniteNumber(extLineHeight.value)\n        ) {\n            style.lineHeight = {\n                unit: extLineHeight.unit,\n                value: extLineHeight.value,\n            } as {\n                unit: \"PIXELS\" | \"PERCENT\";\n                value: number;\n            };\n        }\n    } else if (value.lineHeight) {\n        if (value.lineHeight === \"auto\") {\n            style.lineHeight = { unit: \"AUTO\" };\n        } else if (value.lineHeight.unit === \"pixel\") {\n            style.lineHeight = {\n                unit: \"PIXELS\",\n                value: value.lineHeight.value,\n            };\n        } else if (value.lineHeight.unit === \"percent\") {\n            style.lineHeight = {\n                unit: \"PERCENT\",\n                value: value.lineHeight.value,\n            };\n        } else {\n            warnings.push(\n                `lineHeight unit \u201C${\n                    (value.lineHeight as DimensionValue).unit\n                }\u201D is not supported.`\n            );\n        }\n    }\n\n    const extLetterSpacing = figmaExt?.letterSpacing;\n    style.letterSpacing = { unit: \"PERCENT\", value: 0 };\n    if (extLetterSpacing) {\n        if (\n            (extLetterSpacing.unit === \"PIXELS\" ||\n                extLetterSpacing.unit === \"PERCENT\") &&\n            isFiniteNumber(extLetterSpacing.value)\n        ) {\n            style.letterSpacing = {\n                unit: extLetterSpacing.unit,\n                value: extLetterSpacing.value,\n            };\n        }\n    } else if (value.letterSpacing) {\n        if (value.letterSpacing.unit === \"pixel\") {\n            style.letterSpacing = {\n                unit: \"PIXELS\",\n                value: value.letterSpacing.value,\n            };\n        } else if (value.letterSpacing.unit === \"percent\") {\n            style.letterSpacing = {\n                unit: \"PERCENT\",\n                value: value.letterSpacing.value,\n            };\n        } else {\n            warnings.push(\n                `letterSpacing unit \u201C${value.letterSpacing.unit}\u201D is not supported.`\n            );\n        }\n    }\n\n    style.paragraphSpacing = 0;\n    if (figmaExt && isFiniteNumber(figmaExt.paragraphSpacing)) {\n        style.paragraphSpacing = figmaExt.paragraphSpacing;\n    } else if (value.paragraphSpacing) {\n        if (value.paragraphSpacing.unit === \"pixel\") {\n            style.paragraphSpacing = value.paragraphSpacing.value;\n        } else {\n            warnings.push(\n                `paragraphSpacing unit \u201C${value.paragraphSpacing.unit}\u201D is not supported. Expected \"pixel\".`\n            );\n        }\n    }\n\n    style.paragraphIndent = 0;\n    if (figmaExt && isFiniteNumber(figmaExt.paragraphIndent)) {\n        style.paragraphIndent = figmaExt.paragraphIndent;\n    } else if (value.paragraphIndent) {\n        if (value.paragraphIndent.unit === \"pixel\") {\n            style.paragraphIndent = value.paragraphIndent.value;\n        } else {\n            warnings.push(\n                `paragraphIndent unit \u201C${value.paragraphIndent.unit}\u201D is not supported. Expected \"pixel\".`\n            );\n        }\n    }\n\n    if (figmaExt && typeof figmaExt.textCase === \"string\") {\n        try {\n            style.textCase = figmaExt.textCase as TextCase;\n        } catch {\n            /* ignore */\n        }\n    } else {\n        const textCase = mapTextCaseToFigma(value.textCase);\n        if (textCase) {\n            style.textCase = textCase;\n        } else {\n            if (value.textCase)\n                warnings.push(\n                    `textCase \u201C${value.textCase}\u201D is not recognized. Using default.`\n                );\n            style.textCase = \"ORIGINAL\";\n        }\n    }\n\n    if (figmaExt && typeof figmaExt.textDecoration === \"string\") {\n        try {\n            style.textDecoration = figmaExt.textDecoration as TextDecoration;\n        } catch {\n            /* ignore */\n        }\n    } else {\n        const textDecoration = mapTextDecorationToFigma(value.textDecoration);\n        if (textDecoration) {\n            style.textDecoration = textDecoration;\n        } else {\n            if (value.textDecoration)\n                warnings.push(\n                    `textDecoration \u201C${value.textDecoration}\u201D is not recognized. Using default.`\n                );\n            style.textDecoration = \"NONE\";\n        }\n    }\n\n    const anyStyle = style as any;\n    const supportsTextAlignHorizontal =\n        typeof anyStyle.textAlignHorizontal !== \"undefined\";\n    const extTextAlignHorizontal =\n        figmaExt && typeof figmaExt.textAlignHorizontal === \"string\"\n            ? (figmaExt.textAlignHorizontal as FigmaTextAlignHorizontal)\n            : null;\n    if (extTextAlignHorizontal) {\n        if (supportsTextAlignHorizontal) {\n            try {\n                anyStyle.textAlignHorizontal = extTextAlignHorizontal;\n            } catch {\n                /* ignore */\n            }\n        } else {\n            warnings.push(\n                \"textAlignHorizontal is not supported for text styles in this version of Figma.\"\n            );\n        }\n    } else {\n        const textAlignHorizontal = mapTextAlignHorizontalToFigma(\n            value.textAlignHorizontal\n        );\n        if (textAlignHorizontal) {\n            if (supportsTextAlignHorizontal) {\n                try {\n                    anyStyle.textAlignHorizontal = textAlignHorizontal;\n                } catch {\n                    /* ignore */\n                }\n            } else {\n                warnings.push(\n                    \"textAlignHorizontal is not supported for text styles in this version of Figma.\"\n                );\n            }\n        } else if (value.textAlignHorizontal) {\n            warnings.push(\n                `textAlignHorizontal \u201C${value.textAlignHorizontal}\u201D is not recognized. Using default.`\n            );\n        } else if (supportsTextAlignHorizontal) {\n            try {\n                anyStyle.textAlignHorizontal = \"LEFT\";\n            } catch {\n                /* ignore */\n            }\n        }\n    }\n\n    const supportsTextAlignVertical =\n        typeof anyStyle.textAlignVertical !== \"undefined\";\n    const extTextAlignVertical =\n        figmaExt && typeof figmaExt.textAlignVertical === \"string\"\n            ? (figmaExt.textAlignVertical as FigmaTextAlignVertical)\n            : null;\n    if (extTextAlignVertical) {\n        if (supportsTextAlignVertical) {\n            try {\n                anyStyle.textAlignVertical = extTextAlignVertical;\n            } catch {\n                /* ignore */\n            }\n        } else {\n            warnings.push(\n                \"textAlignVertical is not supported for text styles in this version of Figma.\"\n            );\n        }\n    } else {\n        const textAlignVertical = mapTextAlignVerticalToFigma(\n            value.textAlignVertical\n        );\n        if (textAlignVertical) {\n            if (supportsTextAlignVertical) {\n                try {\n                    anyStyle.textAlignVertical = textAlignVertical;\n                } catch {\n                    /* ignore */\n                }\n            } else {\n                warnings.push(\n                    \"textAlignVertical is not supported for text styles in this version of Figma.\"\n                );\n            }\n        } else if (value.textAlignVertical) {\n            warnings.push(\n                `textAlignVertical \u201C${value.textAlignVertical}\u201D is not recognized. Using default.`\n            );\n        } else if (supportsTextAlignVertical) {\n            try {\n                anyStyle.textAlignVertical = \"TOP\";\n            } catch {\n                /* ignore */\n            }\n        }\n    }\n\n    if (figmaExt) {\n        if (\n            isFiniteNumber(figmaExt.listSpacing) &&\n            typeof anyStyle.listSpacing !== \"undefined\"\n        ) {\n            try {\n                anyStyle.listSpacing = figmaExt.listSpacing;\n            } catch {\n                /* ignore */\n            }\n        }\n        if (\n            typeof figmaExt.hangingPunctuation === \"boolean\" &&\n            typeof anyStyle.hangingPunctuation !== \"undefined\"\n        ) {\n            try {\n                anyStyle.hangingPunctuation = figmaExt.hangingPunctuation;\n            } catch {\n                /* ignore */\n            }\n        }\n        if (\n            typeof figmaExt.hangingList === \"boolean\" &&\n            typeof anyStyle.hangingList !== \"undefined\"\n        ) {\n            try {\n                anyStyle.hangingList = figmaExt.hangingList;\n            } catch {\n                /* ignore */\n            }\n        }\n        if (\n            typeof figmaExt.leadingTrim !== \"undefined\" &&\n            typeof anyStyle.leadingTrim !== \"undefined\"\n        ) {\n            try {\n                anyStyle.leadingTrim = figmaExt.leadingTrim;\n            } catch {\n                /* ignore */\n            }\n        }\n        if (\n            typeof figmaExt.textAutoResize === \"string\" &&\n            typeof anyStyle.textAutoResize !== \"undefined\"\n        ) {\n            try {\n                anyStyle.textAutoResize = figmaExt.textAutoResize;\n            } catch {\n                /* ignore */\n            }\n        }\n        if (\n            typeof figmaExt.fills !== \"undefined\" &&\n            typeof anyStyle.fills !== \"undefined\"\n        ) {\n            try {\n                anyStyle.fills = figmaExt.fills;\n            } catch {\n                /* ignore */\n            }\n        }\n        if (\n            typeof figmaExt.strokes !== \"undefined\" &&\n            typeof anyStyle.strokes !== \"undefined\"\n        ) {\n            try {\n                anyStyle.strokes = figmaExt.strokes;\n            } catch {\n                /* ignore */\n            }\n        }\n    }\n\n    return warnings;\n}\n", "// src/core/color.ts\n// Accurate, spec-aligned color handling for DTCG <-> Figma.\n// - Validates incoming data so we never write impossible color spaces\n// - Converts between srgb/display-p3 while keeping precision intact\n\nimport type { ColorValue } from \"./ir\";\n\n// --- ADD: supported DTCG color spaces (limited to what we\u2019ll accept) ---\nexport type DocumentProfile =\n    | \"SRGB\"\n    | \"DISPLAY_P3\"\n    | \"DOCUMENT_SRGB\"\n    | \"DOCUMENT_DISPLAY_P3\"; // Figma document profiles\nexport type CanonicalDocumentProfile = \"SRGB\" | \"DISPLAY_P3\";\n\n/** Normalize the various document profile strings Figma can return. */\nexport function normalizeDocumentProfile(\n    profile: DocumentProfile | string\n): CanonicalDocumentProfile {\n    const upper = String(profile).toUpperCase();\n    return upper.includes(\"DISPLAY_P3\") ? \"DISPLAY_P3\" : \"SRGB\";\n}\n\n// Only accept these DTCG color spaces in this plugin:\nconst SUPPORTED_DTCG_COLOR_SPACES = new Set([\"srgb\", \"display-p3\"] as const);\n\n/**\n * Strict shape validator for a DTCG color object.\n * Expects: { colorSpace: 'srgb'|'display-p3', components: [r,g,b], alpha?: number, hex?: string }\n */\nexport function isDtcgColorShapeValid(input: any): {\n    ok: boolean;\n    reason?: string;\n} {\n    if (!input || typeof input !== \"object\") {\n        return { ok: false, reason: \"not an object\" };\n    }\n\n    const cs = String(input.colorSpace || \"\").toLowerCase();\n    if (!SUPPORTED_DTCG_COLOR_SPACES.has(cs as any)) {\n        return {\n            ok: false,\n            reason: `unsupported colorSpace (\u201C${input.colorSpace}\u201D)`,\n        };\n    }\n\n    if (!Array.isArray(input.components) || input.components.length !== 3) {\n        return { ok: false, reason: \"components must be an array of length 3\" };\n    }\n\n    // components must be finite numbers in [0..1]\n    for (let i = 0; i < 3; i++) {\n        const v = input.components[i];\n        if (typeof v !== \"number\" || !Number.isFinite(v)) {\n            return {\n                ok: false,\n                reason: `component ${i} is not a finite number`,\n            };\n        }\n        if (v < 0 || v > 1) {\n            return { ok: false, reason: `component ${i} out of range (${v})` };\n        }\n    }\n\n    // alpha, if present, must be finite number in [0..1]\n    if (typeof input.alpha !== \"undefined\") {\n        if (typeof input.alpha !== \"number\" || !Number.isFinite(input.alpha)) {\n            return { ok: false, reason: \"alpha is not a finite number\" };\n        }\n        if (input.alpha < 0 || input.alpha > 1) {\n            return { ok: false, reason: `alpha out of range (${input.alpha})` };\n        }\n    }\n\n    return { ok: true };\n}\n\n/**\n * Gate colorSpace by document profile: SRGB docs only allow 'srgb',\n * Display-P3 docs allow both 'srgb' and 'display-p3'.\n */\nexport function isColorSpaceRepresentableInDocument(\n    colorSpace: string,\n    profile: DocumentProfile | string\n): boolean {\n    const cs = String(colorSpace).toLowerCase();\n    const normalized = normalizeDocumentProfile(profile);\n    if (normalized === \"DISPLAY_P3\")\n        return cs === \"srgb\" || cs === \"display-p3\";\n    return cs === \"srgb\";\n}\n\nfunction clamp01(x: number): number {\n    if (x < 0) return 0;\n    if (x > 1) return 1;\n    return x;\n}\nfunction clamp01Array(v: number[]): number[] {\n    const out: number[] = [];\n    let i = 0;\n    for (i = 0; i < v.length; i++) out.push(clamp01(v[i]));\n    return out;\n}\n\n// sRGB / P3 TRC\nfunction srgbEncode(linear: number): number {\n    if (linear <= 0.0031308) return 12.92 * linear;\n    return 1.055 * Math.pow(linear, 1 / 2.4) - 0.055;\n}\nfunction srgbDecode(encoded: number): number {\n    if (encoded <= 0.04045) return encoded / 12.92;\n    return Math.pow((encoded + 0.055) / 1.055, 2.4);\n}\nconst p3Encode = srgbEncode;\nconst p3Decode = srgbDecode;\n\nfunction mul3(m: number[][], v: number[]): number[] {\n    return [\n        m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2],\n        m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2],\n        m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2],\n    ];\n}\n\n// D65 matrices\nconst M_SRGB_TO_XYZ = [\n    [0.4124564, 0.3575761, 0.1804375],\n    [0.2126729, 0.7151522, 0.072175],\n    [0.0193339, 0.119192, 0.9503041],\n];\nconst M_XYZ_TO_SRGB = [\n    [3.2404542, -1.5371385, -0.4985314],\n    [-0.969266, 1.8760108, 0.041556],\n    [0.0556434, -0.2040259, 1.0572252],\n];\n\nconst M_P3_TO_XYZ = [\n    [0.4865709486482162, 0.26566769316909306, 0.1982172852343625],\n    [0.2289745640697488, 0.6917385218365064, 0.079286914093745],\n    [0.0, 0.04511338185890264, 1.043944368900976],\n];\nconst M_XYZ_TO_P3 = [\n    [2.493496911941425, -0.9313836179191239, -0.40271078445071684],\n    [-0.8294889695615747, 1.7626640603183463, 0.02362468584194358],\n    [0.03584583024378447, -0.07617238926804182, 0.9568845240076872],\n];\n\nfunction encode(space: \"srgb\" | \"display-p3\", linearRGB: number[]): number[] {\n    if (space === \"display-p3\")\n        return [\n            p3Encode(linearRGB[0]),\n            p3Encode(linearRGB[1]),\n            p3Encode(linearRGB[2]),\n        ];\n    return [\n        srgbEncode(linearRGB[0]),\n        srgbEncode(linearRGB[1]),\n        srgbEncode(linearRGB[2]),\n    ];\n}\nfunction decode(space: \"srgb\" | \"display-p3\", encodedRGB: number[]): number[] {\n    if (space === \"display-p3\")\n        return [\n            p3Decode(encodedRGB[0]),\n            p3Decode(encodedRGB[1]),\n            p3Decode(encodedRGB[2]),\n        ];\n    return [\n        srgbDecode(encodedRGB[0]),\n        srgbDecode(encodedRGB[1]),\n        srgbDecode(encodedRGB[2]),\n    ];\n}\n\nfunction convertRgbSpace(\n    rgb: number[],\n    src: \"srgb\" | \"display-p3\",\n    dst: \"srgb\" | \"display-p3\"\n): number[] {\n    if (src === dst) return clamp01Array(rgb);\n    const lin = decode(src, clamp01Array(rgb));\n    const xyz: number[] =\n        src === \"srgb\" ? mul3(M_SRGB_TO_XYZ, lin) : mul3(M_P3_TO_XYZ, lin);\n    const linDst: number[] =\n        dst === \"srgb\" ? mul3(M_XYZ_TO_SRGB, xyz) : mul3(M_XYZ_TO_P3, xyz);\n    const enc = encode(dst, linDst);\n    return clamp01Array(enc);\n}\n\nfunction srgbToHex6(rgb: number[]): string {\n    const r = Math.round(clamp01(rgb[0]) * 255);\n    const g = Math.round(clamp01(rgb[1]) * 255);\n    const b = Math.round(clamp01(rgb[2]) * 255);\n    function to2(n: number): string {\n        const s = n.toString(16);\n        return s.length === 1 ? \"0\" + s : s;\n    }\n    return \"#\" + to2(r) + to2(g) + to2(b);\n}\nfunction srgbToHex8(rgba: {\n    r: number;\n    g: number;\n    b: number;\n    a: number;\n}): string {\n    const r = Math.round(clamp01(rgba.r) * 255);\n    const g = Math.round(clamp01(rgba.g) * 255);\n    const b = Math.round(clamp01(rgba.b) * 255);\n    const a = Math.round(clamp01(rgba.a) * 255);\n    function to2(n: number): string {\n        const s = n.toString(16);\n        return s.length === 1 ? \"0\" + s : s;\n    }\n    return \"#\" + to2(r) + to2(g) + to2(b) + to2(a);\n}\n\nfunction isHexCharCode(code: number): boolean {\n    if (code >= 48 && code <= 57) return true;\n    if (code >= 65 && code <= 70) return true;\n    if (code >= 97 && code <= 102) return true;\n    return false;\n}\nfunction hexPairToByte(h1: number, h2: number): number {\n    function val(c: number): number {\n        if (c >= 48 && c <= 57) return c - 48;\n        if (c >= 65 && c <= 70) return c - 55;\n        if (c >= 97 && c <= 102) return c - 87;\n        return 0;\n    }\n    return (val(h1) << 4) | val(h2);\n}\n\nexport function parseHexToSrgbRGBA(hex: string): {\n    r: number;\n    g: number;\n    b: number;\n    a: number;\n} {\n    let s = hex;\n    if (s.length > 0 && s.charAt(0) === \"#\") s = s.substring(1);\n\n    let i = 0;\n    for (i = 0; i < s.length; i++) {\n        if (!isHexCharCode(s.charCodeAt(i)))\n            throw new Error(\"Invalid hex color: \" + hex);\n    }\n\n    let r = 0,\n        g = 0,\n        b = 0,\n        a = 255;\n\n    if (s.length === 3 || s.length === 4) {\n        const rNib = s.charCodeAt(0);\n        const gNib = s.charCodeAt(1);\n        const bNib = s.charCodeAt(2);\n        const aNib = s.length === 4 ? s.charCodeAt(3) : 102;\n        r = hexPairToByte(rNib, rNib);\n        g = hexPairToByte(gNib, gNib);\n        b = hexPairToByte(bNib, bNib);\n        a = hexPairToByte(aNib, aNib);\n    } else if (s.length === 6 || s.length === 8) {\n        r = hexPairToByte(s.charCodeAt(0), s.charCodeAt(1));\n        g = hexPairToByte(s.charCodeAt(2), s.charCodeAt(3));\n        b = hexPairToByte(s.charCodeAt(4), s.charCodeAt(5));\n        if (s.length === 8) a = hexPairToByte(s.charCodeAt(6), s.charCodeAt(7));\n    } else {\n        throw new Error(\"Invalid hex length: \" + hex);\n    }\n\n    return {\n        r: clamp01(r / 255),\n        g: clamp01(g / 255),\n        b: clamp01(b / 255),\n        a: clamp01(a / 255),\n    };\n}\n\nfunction docProfileToSpaceKey(\n    profile: DocumentProfile | string\n): \"srgb\" | \"display-p3\" {\n    return normalizeDocumentProfile(profile) === \"DISPLAY_P3\"\n        ? \"display-p3\"\n        : \"srgb\";\n}\n\n/** DTCG -> Figma RGBA in current doc profile. */\nexport function dtcgToFigmaRGBA(\n    value: ColorValue,\n    docProfile: DocumentProfile | string\n): { r: number; g: number; b: number; a: number } {\n    const alpha = typeof value.alpha === \"number\" ? value.alpha : 1;\n    const dst = docProfileToSpaceKey(docProfile);\n\n    const comps = value.components;\n    if (comps && comps.length >= 3) {\n        const space = value.colorSpace;\n        if (space === \"srgb\" || space === \"display-p3\") {\n            const converted = convertRgbSpace(\n                [comps[0], comps[1], comps[2]],\n                space,\n                dst\n            );\n            return {\n                r: converted[0],\n                g: converted[1],\n                b: converted[2],\n                a: clamp01(alpha),\n            };\n        }\n        throw new Error(\n            \"Unsupported colorSpace: \" +\n                space +\n                \". Supported: srgb, display-p3.\"\n        );\n    }\n\n    if (value.hex && typeof value.hex === \"string\") {\n        const fromHex = parseHexToSrgbRGBA(value.hex);\n        const a =\n            typeof value.alpha === \"number\" ? clamp01(value.alpha) : fromHex.a;\n        if (dst === \"srgb\")\n            return { r: fromHex.r, g: fromHex.g, b: fromHex.b, a: a };\n        const toDst = convertRgbSpace(\n            [fromHex.r, fromHex.g, fromHex.b],\n            \"srgb\",\n            dst\n        );\n        return { r: toDst[0], g: toDst[1], b: toDst[2], a: a };\n    }\n\n    throw new Error(\"Color has neither components nor hex.\");\n}\n\n/** Figma -> DTCG in document-native space + sRGB hex fallback. */\nexport function figmaRGBAToDtcg(\n    rgba: { r: number; g: number; b: number; a: number },\n    docProfile: DocumentProfile | string\n): ColorValue {\n    const src = docProfileToSpaceKey(docProfile);\n    const rgb = [clamp01(rgba.r), clamp01(rgba.g), clamp01(rgba.b)];\n    const a = clamp01(rgba.a);\n\n    const colorSpace: \"srgb\" | \"display-p3\" = src;\n    const components: [number, number, number] = [rgb[0], rgb[1], rgb[2]];\n\n    const srgbRgb =\n        src === \"srgb\" ? rgb : convertRgbSpace(rgb, \"display-p3\", \"srgb\");\n    const hex = srgbToHex6(srgbRgb);\n\n    return {\n        colorSpace: colorSpace,\n        components: components,\n        alpha: a,\n        hex: hex,\n    };\n}\n\n// Legacy wrappers kept for existing callers\nexport function srgbToFigma(color: ColorValue): {\n    r: number;\n    g: number;\n    b: number;\n    a: number;\n} {\n    return dtcgToFigmaRGBA(color, \"SRGB\");\n}\nexport function figmaToSrgb(\n    r: number,\n    g: number,\n    b: number,\n    a: number\n): ColorValue {\n    const comps: [number, number, number] = [clamp01(r), clamp01(g), clamp01(b)];\n    return { colorSpace: \"srgb\", components: comps, alpha: clamp01(a) };\n}\n\n// Hex helpers for tooling\nexport function toHex6FromSrgb(rgb: {\n    r: number;\n    g: number;\n    b: number;\n}): string {\n    return srgbToHex6([clamp01(rgb.r), clamp01(rgb.g), clamp01(rgb.b)]);\n}\nexport function toHex8FromSrgb(rgba: {\n    r: number;\n    g: number;\n    b: number;\n    a: number;\n}): string {\n    return srgbToHex8({\n        r: clamp01(rgba.r),\n        g: clamp01(rgba.g),\n        b: clamp01(rgba.b),\n        a: clamp01(rgba.a),\n    });\n}\n\nexport function colorValueToHexString(value: ColorValue): string {\n    const comps = Array.isArray(value.components)\n        ? value.components\n        : [0, 0, 0];\n    const srgb =\n        value.colorSpace === \"display-p3\"\n            ? convertRgbSpace(comps, \"display-p3\", \"srgb\")\n            : clamp01Array(comps);\n\n    const baseHex =\n        typeof value.hex === \"string\" && value.hex.length > 0\n            ? value.hex.charAt(0) === \"#\"\n                ? value.hex\n                : \"#\" + value.hex\n            : srgbToHex6(srgb);\n\n    if (typeof value.alpha === \"number\") {\n        const alpha = clamp01(value.alpha);\n        if (alpha < 1) {\n            return srgbToHex8({ r: srgb[0], g: srgb[1], b: srgb[2], a: alpha });\n        }\n    }\n\n    return baseHex;\n}\nexport function hexToDtcgColor(hex: string): ColorValue {\n    const rgba = parseHexToSrgbRGBA(hex);\n    const comps: [number, number, number] = [rgba.r, rgba.g, rgba.b];\n    return {\n        colorSpace: \"srgb\",\n        components: comps,\n        alpha: rgba.a,\n        hex: toHex6FromSrgb({ r: rgba.r, g: rgba.g, b: rgba.b }),\n    };\n}\n\n// ==== DTCG color guards & normalization ===================================\n\n/**\n * Lightweight structural check for a DTCG color object.\n * Accepts { components[3], colorSpace?, alpha?, hex? }.\n * (colorSpace may be absent; we'll default it during normalization.)\n */\nexport function isValidDtcgColorValueObject(v: unknown): v is {\n    colorSpace?: string;\n    components?: unknown;\n    alpha?: unknown;\n    hex?: unknown;\n} {\n    if (!v || typeof v !== \"object\") return false;\n    const o = v as any;\n    if (!Array.isArray(o.components) || o.components.length < 3) return false;\n    if (\n        typeof o.components[0] !== \"number\" ||\n        typeof o.components[1] !== \"number\" ||\n        typeof o.components[2] !== \"number\"\n    )\n        return false;\n    return true;\n}\n\n/**\n * Normalize a DTCG color object into your internal ColorValue:\n * - clamps components/alpha to [0,1]\n * - preserves hex when present (no rounding/quantization)\n * - defaults missing colorSpace to \"srgb\"\n */\nexport function normalizeDtcgColorValue(input: {\n    colorSpace?: string;\n    components: [number, number, number] | number[];\n    alpha?: number;\n    hex?: string;\n}): ColorValue {\n    function clamp01(x: number): number {\n        if (!Number.isFinite(x)) return 0;\n        if (x < 0) return 0;\n        if (x > 1) return 1;\n        return x;\n    }\n    const comps = [\n        clamp01(Number(input.components[0])),\n        clamp01(Number(input.components[1])),\n        clamp01(Number(input.components[2])),\n    ] as [number, number, number];\n\n    const alpha =\n        typeof input.alpha === \"number\" ? clamp01(input.alpha) : undefined;\n\n    // Honor provided colorSpace when it's one of the supported ones; default to srgb\n    const cs = input.colorSpace === \"display-p3\" ? \"display-p3\" : \"srgb\";\n\n    return {\n        colorSpace: cs,\n        components: comps,\n        ...(alpha !== undefined ? { alpha } : {}),\n        ...(typeof input.hex === \"string\" ? { hex: input.hex } : {}),\n    };\n}\n\n// STRICT range check: components and alpha must be in [0..1] with no clamping.\nexport function isDtcgColorInUnitRange(input: {\n    components?: [number, number, number] | number[];\n    alpha?: number;\n}): { ok: boolean; reason?: string } {\n    if (\n        !input ||\n        !Array.isArray(input.components) ||\n        input.components.length < 3\n    ) {\n        return { ok: false, reason: \"components missing\" };\n    }\n    for (let i = 0; i < 3; i++) {\n        const n = Number(input.components[i]);\n        if (!Number.isFinite(n) || n < 0 || n > 1) {\n            return {\n                ok: false,\n                reason: `component[${i}] out of range (${input.components[i]})`,\n            };\n        }\n    }\n    if (typeof input.alpha === \"number\") {\n        const a = Number(input.alpha);\n        if (!Number.isFinite(a) || a < 0 || a > 1) {\n            return { ok: false, reason: `alpha out of range (${input.alpha})` };\n        }\n    }\n    return { ok: true };\n}\n", "// src/adapters/dtcg-reader.ts\n// Parse raw DTCG token JSON into our IR without losing metadata or alias structure.\n// - Validates values strictly so we fail fast on malformed input\n// - Preserves $extensions fields to keep Figma round-trips intact\n\nimport {\n    type TokenGraph,\n    type TokenNode,\n    type PrimitiveType,\n    type ValueOrAlias,\n} from \"../core/ir\";\nimport { parseTypographyValue } from \"../core/typography\";\n\n// ---------- color parsing (strict) ----------\nimport { hexToDtcgColor, isDtcgColorShapeValid } from \"../core/color\";\n\n// ---------- lightweight logging (console fallback outside Figma) ----------\nfunction postInfoToUi(msg: string): boolean {\n    try {\n        if (typeof figma !== \"undefined\" && figma.ui?.postMessage) {\n            figma.ui.postMessage({ type: \"INFO\", payload: { message: msg } });\n            return true;\n        }\n    } catch {\n        /* ignore */\n    }\n    return false;\n}\n\nfunction logInfo(msg: string) {\n    if (postInfoToUi(msg)) return;\n    try {\n        globalThis.console?.log?.(msg);\n    } catch {\n        /* ignore */\n    }\n}\n\nfunction logWarn(msg: string) {\n    const payload = \"Warning: \" + msg;\n    if (postInfoToUi(payload)) return;\n    try {\n        globalThis.console?.warn?.(payload);\n    } catch {\n        try {\n            globalThis.console?.log?.(payload);\n        } catch {\n            /* ignore */\n        }\n    }\n}\n\n// ---------- helpers ----------\n/** Guard for plain-object own keys without letting sneaky prototypes through. */\nfunction hasKey(o: unknown, k: string): boolean {\n    return (\n        !!o &&\n        typeof o === \"object\" &&\n        Object.prototype.hasOwnProperty.call(o, k)\n    );\n}\n\n/** True when the value looks like an alias string: \"{collection.group.token}\". */\nfunction isAliasString(v: unknown): v is string {\n    return (\n        typeof v === \"string\" &&\n        v.startsWith(\"{\") &&\n        v.endsWith(\"}\") &&\n        v.length > 2\n    );\n}\n\n/** Split an alias string into raw segments while keeping user formatting intact. */\nfunction parseAliasToSegments(v: string): string[] {\n    // exact segments, keep spacing/punctuation as-is (only trim around the dot delimiter)\n    return v\n        .slice(1, -1)\n        .split(\".\")\n        .map((s) => s.trim());\n}\n\n/** Quick heuristic for hex strings so we only attempt conversions on plausible inputs. */\nfunction isLikelyHexString(v: unknown): v is string {\n    return (\n        typeof v === \"string\" &&\n        /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(v.trim())\n    );\n}\n\n/** Extract a trimmed $description if present; avoids emitting empty strings. */\nfunction readDescription(obj: unknown): string | undefined {\n    if (!obj || typeof obj !== \"object\") return undefined;\n    const d = (obj as any)[\"$description\"];\n    if (typeof d === \"string\") {\n        const s = d.trim();\n        if (s.length > 0) return s;\n    }\n    return undefined;\n}\n\n/**\n * Flexible color parser:\n * - Strict by default (reject all string forms).\n * - When allowHexStrings = true, accept hex strings -> DTCG object via hexToDtcgColor (srgb).\n * - Always accept objects only if shape is valid (supported colorSpace, 3 numeric components, alpha number in [0..1] or undefined).\n * - Do NOT coerce object member types (alpha:\"1\" stays string -> rejected by validator).\n */\nfunction readColorValueFlexible(\n    raw: unknown,\n    allowHexStrings: boolean\n): { value: any; coercedFromHex: boolean } | null {\n    // String form\n    if (typeof raw === \"string\") {\n        if (!allowHexStrings) return null;\n        if (!isLikelyHexString(raw)) return null;\n        try {\n            return { value: hexToDtcgColor(raw), coercedFromHex: true };\n        } catch {\n            return null;\n        }\n    }\n\n    // Object form (no coercion)\n    if (raw && typeof raw === \"object\") {\n        const obj = raw as any;\n        const candidate: any = {\n            // keep as-is; validator will check allowed spaces (srgb/display-p3)\n            ...(typeof obj.colorSpace === \"string\"\n                ? { colorSpace: obj.colorSpace }\n                : {}),\n            ...(Array.isArray(obj.components)\n                ? { components: obj.components.slice(0, 3) }\n                : {}),\n            // preserve provided alpha *as-is*; validator will reject non-number/out-of-range\n            ...(\"alpha\" in obj ? { alpha: obj.alpha } : {}),\n            ...(typeof obj.hex === \"string\" ? { hex: obj.hex } : {}),\n        };\n\n        const shape = isDtcgColorShapeValid(candidate);\n        if (!shape.ok) return null;\n        return { value: candidate, coercedFromHex: false };\n    }\n\n    return null;\n}\n\n/**\n * Compute IR path and ctx for a token based on:\n *  - $extensions.com.figma.modeName (if present, use EXACT string)\n *  - otherwise the JSON group path literally (no normalization)\n *  - default Figma mode when missing = \"Mode 1\"\n */\nfunction computePathAndCtx(\n    path: string[],\n    obj: unknown\n): { irPath: string[]; ctx: string } {\n    const irPath = path.slice(); // EXACT JSON path\n    let mode = \"Mode 1\";\n    const ext = hasKey(obj, \"$extensions\")\n        ? ((obj as any)[\"$extensions\"] as Record<string, unknown>)\n        : undefined;\n    const cf =\n        ext && typeof ext === \"object\" ? (ext as any)[\"com.figma\"] : undefined;\n    if (\n        cf &&\n        typeof cf === \"object\" &&\n        typeof (cf as any).modeName === \"string\"\n    ) {\n        mode = (cf as any).modeName as string;\n    }\n    const collection = irPath[0] ?? \"Tokens\";\n    return { irPath, ctx: `${collection}/${mode}` };\n}\n\nexport interface DtcgReaderOptions {\n    /** When true, accept hex strings like \"#RRGGBB[AA]\" and coerce to a DTCG color object (srgb). Default: false (strict). */\n    allowHexStrings?: boolean;\n}\n\nexport function readDtcgToIR(\n    root: unknown,\n    opts: DtcgReaderOptions = {}\n): TokenGraph {\n    const allowHexStrings = !!opts.allowHexStrings;\n    const tokens: TokenNode[] = [];\n    const tokensByPath = new Map<string, TokenNode>();\n    const aliasTokens: Array<{\n        token: TokenNode;\n        declaredType: PrimitiveType | null;\n    }> = [];\n\n    function registerToken(token: TokenNode): void {\n        tokens.push(token);\n        tokensByPath.set(token.path.join(\"/\"), token);\n    }\n\n    function visit(\n        obj: unknown,\n        path: string[],\n        inheritedType: PrimitiveType | null\n    ): void {\n        if (!obj || typeof obj !== \"object\") return;\n\n        // group-level $type inheritance (DTCG)\n        let groupType: PrimitiveType | null = inheritedType;\n        if (hasKey(obj, \"$type\") && typeof (obj as any).$type === \"string\") {\n            const t = String((obj as any).$type);\n            if (\n                t === \"color\" ||\n                t === \"number\" ||\n                t === \"string\" ||\n                t === \"boolean\" ||\n                t === \"typography\"\n            ) {\n                groupType = t as PrimitiveType;\n            }\n        }\n\n        // Token node?\n        if (hasKey(obj, \"$value\")) {\n            const rawVal = (obj as any).$value;\n\n            // Optional $description (DTCG)\n            const desc = readDescription(obj);\n\n            // Aliases are always strings of the form {a.b.c}\n            if (isAliasString(rawVal)) {\n                const segs = parseAliasToSegments(rawVal);\n                const { irPath, ctx } = computePathAndCtx(path, obj);\n                const byCtx: { [k: string]: ValueOrAlias } = {};\n                byCtx[ctx] = { kind: \"alias\", path: segs };\n\n                const token: TokenNode = {\n                    path: irPath,\n                    type: groupType ?? \"string\",\n                    byContext: byCtx,\n                    ...(desc ? { description: desc } : {}),\n                    ...(hasKey(obj, \"$extensions\")\n                        ? {\n                              extensions: (obj as any)[\"$extensions\"] as Record<\n                                  string,\n                                  unknown\n                              >,\n                          }\n                        : {}),\n                };\n                registerToken(token);\n                aliasTokens.push({ token, declaredType: groupType ?? null });\n                return;\n            }\n\n            // Colors: ONLY when $type (inherited or local) is 'color'\n            if (groupType === \"color\") {\n                const { irPath, ctx } = computePathAndCtx(path, obj);\n                const parsed = readColorValueFlexible(rawVal, allowHexStrings);\n\n                if (!parsed) {\n                    if (typeof rawVal === \"string\") {\n                        if (allowHexStrings) {\n                            logWarn(\n                                `Skipped invalid color for \u201C${irPath.join(\n                                    \"/\"\n                                )}\u201D \u2014 expected hex string or a valid DTCG color object (srgb/display-p3, 3 numeric components, alpha in [0..1]).`\n                            );\n                        } else {\n                            logWarn(\n                                `Skipped invalid color for \u201C${irPath.join(\n                                    \"/\"\n                                )}\u201D \u2014 expected a DTCG color object (srgb/display-p3, 3 numeric components, optional numeric alpha in [0..1]); strings like \"#RRGGBB\" are not accepted.`\n                            );\n                        }\n                    } else {\n                        logWarn(\n                            `Skipped invalid color for \u201C${irPath.join(\n                                \"/\"\n                            )}\u201D \u2014 expected a valid DTCG color object (srgb/display-p3, 3 numeric components, alpha in [0..1]).`\n                        );\n                    }\n                    return;\n                }\n\n                if (parsed.coercedFromHex) {\n                    logInfo(\n                        `Coerced string hex to DTCG color object for \u201C${irPath.join(\n                            \"/\"\n                        )}\u201D.`\n                    );\n                }\n\n                const byCtx: { [k: string]: ValueOrAlias } = {};\n                byCtx[ctx] = { kind: \"color\", value: parsed.value };\n\n                registerToken({\n                    path: irPath,\n                    type: \"color\",\n                    byContext: byCtx,\n                    ...(desc ? { description: desc } : {}),\n                    ...(hasKey(obj, \"$extensions\")\n                        ? {\n                              extensions: (obj as any)[\"$extensions\"] as Record<\n                                  string,\n                                  unknown\n                              >,\n                          }\n                        : {}),\n                });\n                return;\n            }\n\n            // Primitives (respect declared type; only fall back when no type was declared)\n            const declaredType = groupType;\n            if (!declaredType) {\n                logWarn(\n                    `Skipped token \u201C${path.join(\n                        \"/\"\n                    )}\u201D \u2014 no $type found in token or parent groups.`\n                );\n                return;\n            }\n\n            let effectiveType: PrimitiveType = declaredType;\n            let valObj: ValueOrAlias | null = null;\n\n            if (declaredType === \"number\" && typeof rawVal === \"number\") {\n                valObj = { kind: \"number\", value: rawVal };\n            } else if (\n                declaredType === \"boolean\" &&\n                typeof rawVal === \"boolean\"\n            ) {\n                valObj = { kind: \"boolean\", value: rawVal };\n            } else if (\n                declaredType === \"string\" &&\n                typeof rawVal === \"string\"\n            ) {\n                valObj = { kind: \"string\", value: rawVal };\n            }\n            // DTCG-compliant boolean round-trip:\n            // If $type is (or resolves to) \"string\" and $extensions.com.figma.variableType == \"BOOLEAN\"\n            // and $value is \"true\"/\"false\", coerce back to boolean with a mild note.\n            if (\n                !valObj &&\n                declaredType === \"string\" &&\n                typeof rawVal === \"string\"\n            ) {\n                const ext = hasKey(obj, \"$extensions\")\n                    ? ((obj as any)[\"$extensions\"] as Record<string, unknown>)\n                    : undefined;\n                const com =\n                    ext && typeof ext === \"object\"\n                        ? (ext as any)[\"com.figma\"]\n                        : undefined;\n                const varType =\n                    com && typeof com === \"object\"\n                        ? (com as any)[\"variableType\"]\n                        : undefined;\n                if (varType === \"BOOLEAN\") {\n                    const raw = rawVal.trim().toLowerCase();\n                    if (raw === \"true\" || raw === \"false\") {\n                        valObj = { kind: \"boolean\", value: raw === \"true\" };\n                        // mild note in the plugin log\n                        logInfo(\n                            `Note: coerced string \u201C${rawVal}\u201D to boolean due to $extensions.com.figma.variableType=BOOLEAN at \u201C${path.join(\n                                \"/\"\n                            )}\u201D.`\n                        );\n                        effectiveType = \"boolean\";\n                    }\n                }\n            }\n\n            if (!valObj && declaredType === \"typography\") {\n                const parsedTypography = parseTypographyValue(rawVal);\n                if (!parsedTypography) {\n                    logWarn(\n                        `Skipped token \u201C${path.join(\n                            \"/\"\n                        )}\u201D \u2014 expected a valid typography object.`\n                    );\n                    return;\n                }\n\n                const { irPath, ctx } = computePathAndCtx(path, obj);\n                const byCtx: { [k: string]: ValueOrAlias } = {};\n                byCtx[ctx] = { kind: \"typography\", value: parsedTypography };\n\n                registerToken({\n                    path: irPath,\n                    type: \"typography\",\n                    byContext: byCtx,\n                    ...(desc ? { description: desc } : {}),\n                    ...(hasKey(obj, \"$extensions\")\n                        ? {\n                              extensions: (obj as any)[\"$extensions\"] as Record<\n                                  string,\n                                  unknown\n                              >,\n                          }\n                        : {}),\n                });\n                return;\n            }\n\n            if (!valObj) {\n                const observed = typeof rawVal;\n                logWarn(\n                    `Skipped token \u201C${path.join(\n                        \"/\"\n                    )}\u201D \u2014 declared $type ${declaredType} but found ${observed}.`\n                );\n                return;\n            }\n\n            const { irPath, ctx } = computePathAndCtx(path, obj);\n            const byCtx: { [k: string]: ValueOrAlias } = {};\n            byCtx[ctx] = valObj;\n\n            registerToken({\n                path: irPath,\n                type: effectiveType,\n                byContext: byCtx,\n                ...(desc ? { description: desc } : {}),\n                ...(hasKey(obj, \"$extensions\")\n                    ? {\n                          extensions: (obj as any)[\"$extensions\"] as Record<\n                              string,\n                              unknown\n                          >,\n                      }\n                    : {}),\n            });\n            return;\n        }\n\n        // Group: recurse children with *exact* key names (no slugging/canonicalization)\n        for (const k in obj as Record<string, unknown>) {\n            if (!Object.prototype.hasOwnProperty.call(obj, k)) continue;\n            if (k.startsWith(\"$\")) continue; // skip metadata keys\n            const child = (obj as Record<string, unknown>)[k];\n            const newPath = path.concat([k]); // preserve key *exactly*\n            visit(child, newPath, groupType);\n        }\n    }\n\n    visit(root, [], null);\n\n    const aliasTokenSet = new Set(aliasTokens.map((a) => a.token));\n    const resolvedTypeCache = new Map<string, PrimitiveType | null>();\n    const invalidTokens = new Set<TokenNode>();\n\n    function resolveTypeForPath(\n        pathSegs: string[],\n        stack: Set<string>\n    ): PrimitiveType | null {\n        const key = pathSegs.join(\"/\");\n        if (resolvedTypeCache.has(key)) return resolvedTypeCache.get(key)!;\n        if (stack.has(key)) {\n            resolvedTypeCache.set(key, null);\n            return null;\n        }\n\n        const target = tokensByPath.get(key);\n        if (!target) {\n            resolvedTypeCache.set(key, null);\n            return null;\n        }\n\n        if (!aliasTokenSet.has(target)) {\n            resolvedTypeCache.set(key, target.type);\n            return target.type;\n        }\n\n        stack.add(key);\n        let detected: PrimitiveType | null = null;\n        const ctxValues = Object.values(target.byContext);\n        for (const ctxVal of ctxValues) {\n            if (!ctxVal || ctxVal.kind !== \"alias\") {\n                detected = null;\n                break;\n            }\n            const nested = resolveTypeForPath(ctxVal.path, stack);\n            if (!nested) {\n                detected = null;\n                break;\n            }\n            if (!detected) detected = nested;\n            else if (detected !== nested) {\n                detected = null;\n                break;\n            }\n        }\n        stack.delete(key);\n        resolvedTypeCache.set(key, detected);\n        return detected;\n    }\n\n    for (const { token, declaredType } of aliasTokens) {\n        const tokenKey = token.path.join(\"/\");\n        let resolvedType: PrimitiveType | null = null;\n        let unresolved = false;\n\n        for (const ctxVal of Object.values(token.byContext)) {\n            if (!ctxVal || ctxVal.kind !== \"alias\") {\n                unresolved = true;\n                break;\n            }\n            const stack = new Set<string>([tokenKey]);\n            const nestedType = resolveTypeForPath(ctxVal.path, stack);\n            if (!nestedType) {\n                unresolved = true;\n                break;\n            }\n            if (!resolvedType) resolvedType = nestedType;\n            else if (resolvedType !== nestedType) {\n                unresolved = true;\n                break;\n            }\n        }\n\n        if (!resolvedType || unresolved) {\n            if (declaredType) {\n                // Fallback: trust the declared type if we can't resolve the alias (e.g. external ref)\n                resolvedType = declaredType;\n            } else {\n                logWarn(\n                    `Skipped token \u201C${token.path.join(\n                        \"/\"\n                    )}\u201D \u2014 could not resolve alias type and no $type declared.`\n                );\n                invalidTokens.add(token);\n                continue;\n            }\n        }\n\n        if (declaredType && declaredType !== resolvedType) {\n            logWarn(\n                `Token \u201C${token.path.join(\n                    \"/\"\n                )}\u201D declared $type ${declaredType} but resolves to ${resolvedType}; using resolved type.`\n            );\n        }\n\n        token.type = resolvedType;\n        tokensByPath.set(tokenKey, token);\n    }\n\n    const finalTokens = tokens.filter((t) => !invalidTokens.has(t));\n    return { tokens: finalTokens };\n}\n", "// src/adapters/dtcg-writer.ts\n// Convert the IR graph back into DTCG JSON while keeping alias strings readable.\n// - Emits groups directly from the IR path so git diffs stay predictable\n// - Uses Figma display metadata only for alias references to preserve user intent\n\nimport { type TokenGraph, type TokenNode, type ValueOrAlias } from \"../core/ir\";\nimport { serializeTypographyValue } from \"../core/typography\";\nimport { colorValueToHexString } from \"../core/color\";\n\n// ---------- tiny utils (lookup-only; never used for emission) ----------\n/** Join path segments with '.' for alias lookups. */\nfunction dotRaw(segs: string[]): string {\n    return segs.join(\".\");\n}\n\n/** Matching-only slug so aliases written in slug form still resolve (never for emission). */\nfunction slugForMatch(s: string): string {\n    return s\n        .trim()\n        .replace(/\\s+/g, \"-\") // collapse whitespace to single '-'\n        .replace(/-+/g, \"-\") // collapse multiple '-' to one\n        .toLowerCase();\n}\n\ntype DisplayNames = { collection: string; variable: string };\n\n/**\n * Extract Figma display names for alias emission, preferring per-context overrides.\n * NEVER used for key generation; JSON structure always follows IR paths.\n */\nfunction getFigmaDisplayNames(t: TokenNode, ctx?: string): DisplayNames {\n    const extAll =\n        t.extensions && typeof t.extensions === \"object\"\n            ? (t.extensions as any)[\"com.figma\"] ??\n              (t.extensions as any)[\"org.figma\"]\n            : undefined;\n\n    // Pull top-level first\n    let collection =\n        extAll && typeof (extAll as any).collectionName === \"string\"\n            ? (extAll as any).collectionName\n            : undefined;\n\n    let variable =\n        extAll && typeof (extAll as any).variableName === \"string\"\n            ? (extAll as any).variableName\n            : undefined;\n\n    // If a context is chosen, prefer perContext overrides for names\n    if (\n        ctx &&\n        extAll &&\n        typeof extAll === \"object\" &&\n        typeof (extAll as any).perContext === \"object\"\n    ) {\n        const ctxBlock = (extAll as any).perContext[ctx];\n        if (ctxBlock && typeof ctxBlock === \"object\") {\n            if (typeof (ctxBlock as any).collectionName === \"string\")\n                collection = (ctxBlock as any).collectionName;\n            if (typeof (ctxBlock as any).variableName === \"string\")\n                variable = (ctxBlock as any).variableName;\n        }\n    }\n\n    // Final fallback to IR path (for display purposes only)\n    if (!collection) collection = t.path[0];\n    if (!variable) variable = t.path.slice(1).join(\"/\");\n\n    return { collection, variable };\n}\n\n// ---------- Build alias resolution index (using per-context names) ----------\n/** Build a lookup map so alias emission can resolve display names quickly. */\nfunction buildDisplayNameIndex(graph: TokenGraph): Map<string, DisplayNames> {\n    const byKey = new Map<string, DisplayNames>();\n\n    for (const t of graph.tokens) {\n        const ctxKeys = keysOf(t.byContext);\n        const chosenCtx = ctxKeys.length > 0 ? ctxKeys[0] : undefined;\n\n        const { collection, variable } = getFigmaDisplayNames(t, chosenCtx);\n        const entry: DisplayNames = { collection, variable };\n\n        // 1) raw IR path key (used by some alias paths)\n        byKey.set(dotRaw(t.path), entry);\n\n        // 2) exact display key (collection + variable split)\n        const displaySegs = [collection, ...String(variable).split(\"/\")];\n        byKey.set(dotRaw(displaySegs), entry);\n\n        // 3) slug-for-match key (lookup only)\n        const slugSegs = [\n            slugForMatch(collection),\n            ...String(variable)\n                .split(\"/\")\n                .map((s: string) => slugForMatch(s)),\n        ];\n        byKey.set(dotRaw(slugSegs), entry);\n    }\n\n    return byKey;\n}\n\nexport interface SerializeResult {\n    json: unknown;\n}\nexport interface SerializeOptions {\n    styleDictionary?: boolean;\n    flatTokens?: boolean;\n}\n\n/**\n * Walk the token graph and emit grouped DTCG JSON.\n * Keeps all grouping logic deterministic so repeated exports diff cleanly.\n */\nexport function serialize(\n    graph: TokenGraph,\n    opts?: SerializeOptions\n): SerializeResult {\n    const root: { [k: string]: unknown } = {};\n    const displayIndex = buildDisplayNameIndex(graph);\n\n    for (const t of graph.tokens) {\n        writeTokenInto(root, t, displayIndex, opts);\n    }\n\n    return { json: root };\n}\n\n/**\n * Emit a single token into the mutable JSON root. Handles alias resolution and metadata.\n */\nfunction writeTokenInto(\n    root: { [k: string]: unknown },\n    t: TokenNode,\n    displayIndex: Map<string, DisplayNames>,\n    opts?: SerializeOptions\n): void {\n    // DTCG has no modes; pick one context just to serialize value/ids\n    const ctxKeys = keysOf(t.byContext);\n    const chosenCtx = ctxKeys.length > 0 ? ctxKeys[0] : undefined;\n\n    const chosen: ValueOrAlias | null =\n        chosenCtx !== undefined\n            ? (t.byContext[chosenCtx] as ValueOrAlias | undefined) ?? null\n            : null;\n\n    // ***** THE CRITICAL GUARANTEE *****\n    // Build the JSON hierarchy STRICTLY from the IR path segments:\n    //   t.path === [collection, ...variableSegments]\n    const path = Array.isArray(t.path) ? t.path : [String(t.path)];\n    const collectionSeg = path[0] ?? \"Tokens\";\n    const variableSegs = path.slice(1); // [\"group1\",\"baseVar\"] etc.\n\n    // Groups are the collection + parent segments; the JSON leaf key is ALWAYS the last segment.\n    const useFlat = !!(opts && opts.flatTokens);\n    const groupSegments = useFlat\n        ? variableSegs.slice(0, -1)\n        : [collectionSeg, ...variableSegs.slice(0, -1)];\n    const leaf = variableSegs.length\n        ? variableSegs[variableSegs.length - 1]\n        : path[path.length - 1] ?? \"token\";\n\n    // Preserve the exact group hierarchy; do not strip user-authored segments\n    // like \"Collection 2\" that participate in canonical alias paths (\u00A75.1).\n\n    // Walk/build the group objects\n    let obj = root;\n    for (let i = 0; i < groupSegments.length; i++) {\n        const seg = groupSegments[i];\n        let next = obj[seg];\n        if (!next || typeof next !== \"object\") {\n            next = {};\n            obj[seg] = next;\n        }\n        obj = next as { [k: string]: unknown };\n    }\n\n    // Build token payload\n    const tokenObj: { [k: string]: unknown } = {};\n    // Emit boolean as DTCG string (with a hint in $extensions for round-trip)\n    const emittedType = t.type === \"boolean\" ? \"string\" : t.type;\n    tokenObj[\"$type\"] = emittedType;\n\n    // ----- value emission -----\n    if (chosen !== null) {\n        switch (chosen.kind) {\n            case \"alias\": {\n                // Resolve to display names if we can (no normalization on emitted string).\n                const segsIn: string[] = Array.isArray((chosen as any).path)\n                    ? ((chosen as any).path as string[]).slice()\n                    : String((chosen as any).path)\n                          .split(\".\")\n                          .map((p: string) => p.trim())\n                          .filter(Boolean);\n\n                let refDisp = displayIndex.get(dotRaw(segsIn));\n                if (!refDisp) {\n                    // try slug-for-match\n                    refDisp = displayIndex.get(\n                        dotRaw(segsIn.map((s: string) => slugForMatch(s)))\n                    );\n                }\n\n                if (!refDisp && segsIn.length > 0) {\n                    // Courtesy: try swapping a slugged collection with a matching display collection\n                    const firstSlug = slugForMatch(segsIn[0]);\n                    for (const [k] of displayIndex.entries()) {\n                        const parts = k.split(\".\");\n                        if (parts.length === 0) continue;\n                        if (slugForMatch(parts[0]) === firstSlug) {\n                            const cand1 = [parts[0], ...segsIn.slice(1)];\n                            const cand2 = [\n                                parts[0],\n                                ...segsIn\n                                    .slice(1)\n                                    .map((s: string) => slugForMatch(s)),\n                            ];\n                            refDisp =\n                                displayIndex.get(dotRaw(cand1)) ||\n                                displayIndex.get(dotRaw(cand2));\n                            if (refDisp) break;\n                        }\n                    }\n                }\n\n                tokenObj[\"$value\"] = refDisp\n                    ? `{${[\n                          refDisp.collection,\n                          ...String(refDisp.variable).split(\"/\"),\n                      ].join(\".\")}}`\n                    : `{${segsIn.join(\".\")}}`;\n                break;\n            }\n\n            case \"color\": {\n                const cv = chosen.value;\n                if (opts && opts.styleDictionary) {\n                    tokenObj[\"$value\"] = colorValueToHexString(cv);\n                } else {\n                    const out: { [k: string]: unknown } = {\n                        colorSpace: cv.colorSpace,\n                        components: [\n                            cv.components[0],\n                            cv.components[1],\n                            cv.components[2],\n                        ],\n                    };\n                    if (typeof cv.alpha === \"number\") out[\"alpha\"] = cv.alpha;\n                    if (typeof cv.hex === \"string\") out[\"hex\"] = cv.hex;\n                    tokenObj[\"$value\"] = out;\n                }\n                break;\n            }\n\n            case \"number\":\n            case \"string\": {\n                tokenObj[\"$value\"] = chosen.value;\n                break;\n            }\n\n            case \"boolean\": {\n                // DTCG: write as string \"true\"/\"false\"\n                tokenObj[\"$value\"] = chosen.value ? \"true\" : \"false\";\n                break;\n            }\n\n            case \"typography\": {\n                tokenObj[\"$value\"] = serializeTypographyValue(chosen.value);\n                break;\n            }\n        }\n    }\n\n    // Only emit non-empty descriptions\n    if (typeof t.description === \"string\" && t.description.trim() !== \"\") {\n        tokenObj[\"$description\"] = t.description;\n    }\n\n    // Flatten $extensions.(com|org).figma.perContext[chosenCtx] into $extensions.com.figma\n    let extOut: Record<string, unknown> | undefined;\n    if (t.extensions) {\n        const flattened = flattenFigmaExtensionsForCtx(\n            t.extensions as Record<string, unknown>,\n            chosenCtx\n        );\n        extOut = flattened ?? (t.extensions as Record<string, unknown>);\n    }\n\n    // Add boolean round-trip hint (keeps DTCG $type as \"string\")\n    if (t.type === \"boolean\") {\n        if (!extOut) extOut = {};\n        const fig =\n            extOut[\"com.figma\"] && typeof extOut[\"com.figma\"] === \"object\"\n                ? (extOut[\"com.figma\"] as Record<string, unknown>)\n                : ((extOut[\"com.figma\"] = {} as Record<\n                      string,\n                      unknown\n                  >) as Record<string, unknown>);\n        if (fig[\"variableType\"] !== \"BOOLEAN\") fig[\"variableType\"] = \"BOOLEAN\";\n    }\n\n    if (extOut) tokenObj[\"$extensions\"] = extOut;\n\n    // ***** Final write: leaf only (NEVER the full display path) *****\n    (obj as any)[leaf] = tokenObj;\n}\n\n/**\n * Flattens either $extensions.com.figma or $extensions.org.figma.\n * - Copies all other namespaces through unchanged.\n * - Removes \"perContext\" and merges the selected context's identifiers.\n * - Always emits under \"com.figma\" to follow current DTCG guidance.\n */\nfunction flattenFigmaExtensionsForCtx(\n    ext: Record<string, unknown>,\n    ctx?: string\n): Record<string, unknown> | null {\n    if (!ext || typeof ext !== \"object\") return null;\n\n    const out: Record<string, unknown> = {};\n\n    // Copy non-figma namespaces as-is\n    for (const k in ext) {\n        if (!Object.prototype.hasOwnProperty.call(ext, k)) continue;\n        if (k !== \"com.figma\" && k !== \"org.figma\") {\n            out[k] = (ext as any)[k];\n        }\n    }\n\n    // Prefer com.figma if present; otherwise accept org.figma for backward-compat\n    const ns = (ext as any)[\"com.figma\"]\n        ? \"com.figma\"\n        : (ext as any)[\"org.figma\"]\n        ? \"org.figma\"\n        : null;\n\n    if (ns) {\n        const figmaBlock = (ext as any)[ns];\n        if (figmaBlock && typeof figmaBlock === \"object\") {\n            const base: Record<string, unknown> = {};\n            // copy all keys except perContext\n            for (const k of Object.keys(figmaBlock)) {\n                if (k !== \"perContext\") base[k] = (figmaBlock as any)[k];\n            }\n            // merge selected context\n            const per = (figmaBlock as any)[\"perContext\"];\n            if (ctx && per && typeof per === \"object\") {\n                const ctxData = (per as any)[ctx];\n                if (ctxData && typeof ctxData === \"object\") {\n                    Object.assign(base, ctxData);\n                }\n            }\n            if (Object.keys(base).length > 0) {\n                // Always emit using the standardized \"com.figma\" key\n                out[\"com.figma\"] = base;\n            }\n        }\n    }\n\n    return Object.keys(out).length > 0 ? out : null;\n}\n\nfunction keysOf<T>(o: { [k: string]: T } | undefined): string[] {\n    const out: string[] = [];\n    if (!o) return out;\n    for (const k in o)\n        if (Object.prototype.hasOwnProperty.call(o, k)) out.push(k);\n    return out;\n}\n", "// src/core/figma-cache.ts\n// Shared helpers for loading Figma variable collections with cached Variable handles.\n// - Avoids repeated getVariableByIdAsync calls during read/write passes\n// - Supplies quick lookups for collection names so alias resolution stays fast\n\nexport interface CollectionsSnapshot {\n    collections: VariableCollection[];\n    variablesById: Map<string, Variable>;\n    collectionNameById: Map<string, string>;\n}\n\n/**\n * Load all local variable collections and hydrate a cache of Variable objects.\n * Callers can reuse the returned maps to avoid redundant async lookups.\n */\nexport async function loadCollectionsSnapshot(\n    variablesApi: PluginAPI[\"variables\"]\n): Promise<CollectionsSnapshot> {\n    const collections = await variablesApi.getLocalVariableCollectionsAsync();\n\n    const collectionNameById = new Map<string, string>();\n    for (const col of collections) {\n        collectionNameById.set(col.id, col.name);\n    }\n\n    const seenIds = new Set<string>();\n    const ids: string[] = [];\n    for (const col of collections) {\n        for (const id of col.variableIds) {\n            if (id && !seenIds.has(id)) {\n                seenIds.add(id);\n                ids.push(id);\n            }\n        }\n    }\n\n    const variablesById = new Map<string, Variable>();\n    if (ids.length > 0) {\n        const fetched = await Promise.all(\n            ids.map((id) => variablesApi.getVariableByIdAsync(id))\n        );\n        for (let i = 0; i < ids.length; i++) {\n            const variable = fetched[i];\n            if (variable) variablesById.set(ids[i], variable);\n        }\n    }\n\n    return { collections, variablesById, collectionNameById };\n}\n", "// src/core/ir.ts\n// Central token graph types shared between adapters.\n// - Defines the minimal shape needed to round-trip DTCG and Figma\n// - Keeps primitive helpers colocated with the structural types\n\nimport type { TypographyValue } from \"./typography\";\n\n/** Primitive kinds supported by both Figma variables and DTCG. */\nexport type PrimitiveType =\n    | \"color\"\n    | \"number\"\n    | \"string\"\n    | \"boolean\"\n    | \"typography\";\n\n/** Normalized color payload aligning with DTCG's schema. */\nexport interface ColorValue {\n    colorSpace: \"srgb\" | \"display-p3\";\n    components: [number, number, number]; // 0..1\n    alpha?: number; // 0..1\n    hex?: string; // sRGB fallback \"#RRGGBB\"\n}\n\nexport type ValueOrAlias =\n    | { kind: \"alias\"; path: string[] }\n    | { kind: \"color\"; value: ColorValue }\n    | { kind: \"number\"; value: number }\n    | { kind: \"string\"; value: string }\n    | { kind: \"boolean\"; value: boolean }\n    | { kind: \"typography\"; value: TypographyValue };\n\n/** Single token entry with canonical path + per-context values. */\nexport interface TokenNode {\n    path: string[]; // canonical path segments\n    type: PrimitiveType;\n    byContext: { [ctx: string]: ValueOrAlias }; // ctx like \"Collection/Mode\"\n    description?: string;\n    extensions?: { [k: string]: unknown };\n}\n\n/** Container for all tokens we imported or plan to export. */\nexport interface TokenGraph {\n    tokens: TokenNode[];\n}\n\n/** Build a context key like `Collection/Mode`. */\nexport function ctxKey(collection: string, mode: string): string {\n    return collection + \"/\" + mode;\n}\n", "// src/adapters/figma-reader.ts\n// Convert live Figma variables into the IR token graph shape used everywhere else.\n// - Preserves canonical path splitting for consistent lookups\n// - Captures per-mode metadata so exports can round-trip Figma specifics\n\nimport { figmaRGBAToDtcg, type DocumentProfile } from \"../core/color\";\nimport { canonicalPath } from \"../core/normalize\";\nimport { loadCollectionsSnapshot } from \"../core/figma-cache\";\nimport { typographyValueFromTextStyle } from \"../core/typography\";\nimport {\n    ctxKey,\n    type TokenGraph,\n    type TokenNode,\n    type PrimitiveType,\n    type ValueOrAlias,\n} from \"../core/ir\";\n\n/** Translate Figma's resolved type into the primitive kinds our IR expects. */\nfunction mapType(t: VariableResolvedDataType): PrimitiveType {\n    if (t === \"COLOR\") return \"color\";\n    if (t === \"FLOAT\") return \"number\";\n    if (t === \"STRING\") return \"string\";\n    return \"boolean\";\n}\n\n/** Guard for Figma alias payloads so we can branch without optional chaining chains. */\nfunction isAliasValue(v: unknown): v is { type: \"VARIABLE_ALIAS\"; id: string } {\n    return (\n        !!v &&\n        typeof v === \"object\" &&\n        (v as { type?: string }).type === \"VARIABLE_ALIAS\" &&\n        typeof (v as { id?: unknown }).id === \"string\"\n    );\n}\n\n/** Guard raw color values while staying defensive about nullish placeholders. */\nfunction isRGBA(\n    v: unknown\n): v is { r: number; g: number; b: number; a: number } {\n    return (\n        !!v &&\n        typeof v === \"object\" &&\n        typeof (v as { r?: unknown }).r === \"number\" &&\n        typeof (v as { g?: unknown }).g === \"number\" &&\n        typeof (v as { b?: unknown }).b === \"number\" &&\n        typeof (v as { a?: unknown }).a === \"number\"\n    );\n}\n\n/**\n * Snapshot every local variable into TokenGraph form while annotating per-mode metadata.\n * We favor direct reads from figma.variables so the IR mirrors whatever is live in the document.\n */\nexport async function readFigmaToIR(): Promise<TokenGraph> {\n    const profile = figma.root.documentColorProfile as DocumentProfile;\n    const variablesApi = figma.variables;\n\n    const { collections, variablesById, collectionNameById } =\n        await loadCollectionsSnapshot(variablesApi);\n\n    const tokens: TokenNode[] = [];\n\n    for (const c of collections) {\n        // Mode name lookup\n        const modeNameById: { [id: string]: string } = {};\n        for (const m of c.modes) modeNameById[m.modeId] = m.name;\n\n        for (const vid of c.variableIds) {\n            const v2 =\n                variablesById.get(vid) ||\n                (await variablesApi.getVariableByIdAsync(vid));\n            if (v2 && !variablesById.has(vid)) variablesById.set(vid, v2);\n            if (!v2) continue;\n\n            // ***** CRITICAL: always split variable name by '/' into path segments *****\n            const path = canonicalPath(c.name, v2.name);\n\n            const type = mapType(v2.resolvedType);\n            const byContext: { [ctx: string]: ValueOrAlias } = {};\n\n            // Collect per-context figma metadata (stored under $extensions.com.figma.perContext)\n            const perContext: {\n                [ctx: string]: {\n                    collectionName: string;\n                    collectionID: string;\n                    modeName: string;\n                    modeID: string;\n                    variableName: string;\n                    variableID: string;\n                    alias?: { type: \"VARIABLE_ALIAS\"; id: string };\n                };\n            } = {};\n\n            // For each mode, collect value\n            for (const md of c.modes) {\n                const ctx = ctxKey(c.name, md.name);\n                const mv = v2.valuesByMode[md.modeId];\n\n                // Always record per-context figma metadata\n                perContext[ctx] = {\n                    collectionName: c.name,\n                    collectionID: c.id,\n                    modeName: md.name,\n                    modeID: md.modeId,\n                    variableName: v2.name,\n                    variableID: v2.id,\n                };\n\n                if (isAliasValue(mv)) {\n                    // Capture alias metadata for export\n                    perContext[ctx].alias = {\n                        type: \"VARIABLE_ALIAS\",\n                        id: mv.id,\n                    };\n\n                    const target =\n                        variablesById.get(mv.id) ||\n                        (await variablesApi.getVariableByIdAsync(mv.id));\n                    if (target && !variablesById.has(target.id))\n                        variablesById.set(target.id, target);\n                    if (target) {\n                        const collName =\n                            collectionNameById.get(\n                                target.variableCollectionId\n                            ) || c.name;\n                        const aPath = canonicalPath(collName, target.name);\n                        byContext[ctx] = { kind: \"alias\", path: aPath };\n                    }\n                    continue;\n                }\n\n                if (type === \"color\" && isRGBA(mv)) {\n                    const cv = figmaRGBAToDtcg(\n                        { r: mv.r, g: mv.g, b: mv.b, a: mv.a },\n                        profile\n                    );\n                    byContext[ctx] = { kind: \"color\", value: cv };\n                    continue;\n                }\n\n                if (typeof mv === \"number\") {\n                    byContext[ctx] = { kind: \"number\", value: mv };\n                    continue;\n                }\n                if (typeof mv === \"boolean\") {\n                    byContext[ctx] = { kind: \"boolean\", value: mv };\n                    continue;\n                }\n                if (typeof mv === \"string\") {\n                    byContext[ctx] = { kind: \"string\", value: mv };\n                    continue;\n                }\n                // else unhandled null/undefined -> skip\n            }\n\n            const figmaExt: Record<string, unknown> = { perContext };\n            if (type === \"boolean\") {\n                // Hint for round-tripping booleans while staying DTCG-compliant (\"string\" on write)\n                figmaExt[\"variableType\"] = \"BOOLEAN\";\n            }\n\n            const token: TokenNode = {\n                path,\n                type,\n                byContext,\n                ...(v2.description && v2.description.length > 0\n                    ? { description: v2.description }\n                    : {}),\n                extensions: {\n                    \"com.figma\": figmaExt,\n                },\n            };\n\n            tokens.push(token);\n        }\n    }\n\n    if (typeof figma.getLocalTextStylesAsync === \"function\") {\n        const textStyles = await figma.getLocalTextStylesAsync();\n        const defaultCollection = \"typography\";\n        const defaultMode = \"Mode 1\";\n        for (const style of textStyles) {\n            const { value, figma: typographyFigma } =\n                typographyValueFromTextStyle(style);\n            const path = canonicalPath(defaultCollection, style.name);\n            const ctx = ctxKey(defaultCollection, defaultMode);\n            const byContext: { [ctx: string]: ValueOrAlias } = {};\n            byContext[ctx] = { kind: \"typography\", value };\n\n            const perContext: {\n                [ctx: string]: {\n                    styleID: string;\n                    styleName: string;\n                };\n            } = {};\n            perContext[ctx] = {\n                styleID: style.id,\n                styleName: style.name,\n            };\n\n            const extensions: Record<string, unknown> = {\n                \"com.figma\": {\n                    styleType: \"TEXT\",\n                    styleID: style.id,\n                    styleName: style.name,\n                    typography: typographyFigma,\n                    perContext,\n                },\n            };\n\n            tokens.push({\n                path,\n                type: \"typography\",\n                byContext,\n                ...(style.description && style.description.length > 0\n                    ? { description: style.description }\n                    : {}),\n                extensions,\n            });\n        }\n    }\n\n    return { tokens };\n}\n", "// src/adapters/figma-writer.ts\n// Apply TokenGraph changes back into Figma's variables API safely and predictably.\n// - Buckets tokens so we only mutate what the document can represent\n// - Preserves figma-specific metadata hints to keep round trips stable\n\nimport { slugSegment } from \"../core/normalize\";\nimport {\n    type TokenGraph,\n    type TokenNode,\n    type PrimitiveType,\n} from \"../core/ir\";\nimport { loadCollectionsSnapshot } from \"../core/figma-cache\";\n\nimport {\n    dtcgToFigmaRGBA,\n    normalizeDocumentProfile,\n    type DocumentProfile,\n    isValidDtcgColorValueObject, // kept for bucketing parity\n    normalizeDtcgColorValue,\n    isDtcgColorShapeValid,\n    isColorSpaceRepresentableInDocument,\n} from \"../core/color\";\nimport {\n    applyTypographyValueToTextStyle,\n    typographyFontNameFromValue,\n    type TypographyFigmaExtension,\n    type TypographyValue,\n} from \"../core/typography\";\n\nexport interface WriteResult {\n    createdTextStyles: number;\n}\n\n// ---------- logging to UI (no toasts) ----------\n/** Post a quiet log line to the UI without risking plugin runtime errors. */\nfunction logInfo(msg: string) {\n    try {\n        figma.ui?.postMessage({ type: \"INFO\", payload: { message: msg } });\n    } catch {\n        /* ignore */\n    }\n}\nfunction logWarn(msg: string) {\n    logInfo(\"Warning: \" + msg);\n}\nfunction logError(msg: string) {\n    logInfo(\"Error: \" + msg);\n}\n\n// ---------- helpers ----------\n\n// ---------- boolean import helpers (hint + mild note) ----------\n\n/** Read the explicit figma type hint from $extensions.com.figma.variableType. */\nfunction readFigmaVariableTypeHint(t: TokenNode): \"BOOLEAN\" | undefined {\n    try {\n        const ext =\n            t.extensions && typeof t.extensions === \"object\"\n                ? (t.extensions as any)[\"com.figma\"]\n                : undefined;\n        const vt =\n            ext && typeof ext === \"object\"\n                ? (ext as any).variableType\n                : undefined;\n        return vt === \"BOOLEAN\" ? \"BOOLEAN\" : undefined;\n    } catch {\n        return undefined;\n    }\n}\n\n/** Detect string payloads that look like boolean literals so we can warn users. */\nfunction looksBooleanString(s: unknown): s is string {\n    return typeof s === \"string\" && /^(true|false)$/i.test(s.trim());\n}\n\n/** Identify tokens that store booleans-as-strings so we can hint at safer conversion. */\nfunction tokenHasBooleanLikeString(t: TokenNode): boolean {\n    const byCtx = t.byContext || {};\n    for (const k in byCtx) {\n        const v = (byCtx as any)[k];\n        if (!v || v.kind === \"alias\") continue;\n        if (v.kind === \"string\" && looksBooleanString(v.value)) return true;\n    }\n    return false;\n}\n\n/** Token has at least one non-alias, correctly-typed value in any context. */\nfunction tokenHasDirectValue(t: TokenNode): boolean {\n    const byCtx = t.byContext || {};\n    for (const k in byCtx) {\n        const v = byCtx[k] as any;\n        if (!v) continue;\n\n        if (t.type === \"color\") {\n            // Bucketing heuristic only \u2014 Pass 1a will do the strict checks.\n            if (v.kind === \"color\" && isValidDtcgColorValueObject(v.value))\n                return true;\n        } else {\n            // number/string/boolean must match kind exactly\n            if (v.kind === t.type) return true;\n        }\n    }\n    return false;\n}\n\n/**\n * True if the token has a direct value that we can safely write for at least one context.\n * Colors require strict validation and profile checks; other primitives just need correct kind.\n */\ntype DirectValueCheck =\n    | { ok: true }\n    | { ok: false; reason?: string; suppressWarn?: boolean };\n\nfunction tokenHasAtLeastOneValidDirectValue(\n    t: TokenNode,\n    profile: DocumentProfile | string\n): DirectValueCheck {\n    const canonicalProfile = normalizeDocumentProfile(profile);\n    const byCtx = t.byContext || {};\n    let lastReason: string | undefined;\n    let reasonAlreadyLogged = false;\n    for (const ctx in byCtx) {\n        const v = (byCtx as any)[ctx];\n        if (!v || v.kind === \"alias\") continue;\n\n        if (t.type === \"color\") {\n            if (v.kind !== \"color\") continue;\n\n            // STRICT 1: shape (supported colorSpace; 3 numeric components; alpha number in [0..1] or undefined)\n            const shape = isDtcgColorShapeValid(v.value);\n            if (!shape.ok) {\n                lastReason = `color in ${ctx} is invalid: ${shape.reason}`;\n                continue;\n            }\n\n            // STRICT 2: representable in this document profile (sRGB doc: only 'srgb'; P3 doc: 'srgb' and 'display-p3')\n            const cs = (v.value.colorSpace || \"srgb\").toLowerCase();\n            if (!isColorSpaceRepresentableInDocument(cs, canonicalProfile)) {\n                lastReason = `colorSpace \u201C${cs}\u201D isn\u2019t representable in this document (${canonicalProfile}).`;\n                if (!reasonAlreadyLogged) {\n                    logWarn(\n                        `Skipped creating direct color at \u201C${t.path.join(\n                            \"/\"\n                        )}\u201D in ${ctx} \u2014 ${lastReason}`\n                    );\n                    reasonAlreadyLogged = true;\n                }\n                continue;\n            }\n\n            return { ok: true };\n        } else if (\n            t.type === \"number\" ||\n            t.type === \"string\" ||\n            t.type === \"boolean\"\n        ) {\n            if (v.kind === t.type) return { ok: true };\n        }\n    }\n    if (t.type === \"number\" || t.type === \"string\" || t.type === \"boolean\") {\n        return { ok: false };\n    }\n    if (reasonAlreadyLogged) {\n        return { ok: false, suppressWarn: true };\n    }\n    return {\n        ok: false,\n        reason:\n            lastReason ||\n            \"no valid color values in any context; not creating variable or collection.\",\n    };\n}\n\n/** Convert our primitive type into the Figma enum that createVariable expects. */\nfunction resolvedTypeFor(t: PrimitiveType): VariableResolvedDataType {\n    if (t === \"color\") return \"COLOR\";\n    if (t === \"number\") return \"FLOAT\";\n    if (t === \"string\") return \"STRING\";\n    return \"BOOLEAN\";\n}\n/** Enumerate own-string keys without trusting prototype state. */\nfunction forEachKey<T>(obj: { [k: string]: T } | undefined): string[] {\n    const out: string[] = [];\n    if (!obj) return out;\n    for (const k in obj)\n        if (Object.prototype.hasOwnProperty.call(obj, k)) out.push(k);\n    return out;\n}\n\n/** Token has at least one alias among its contexts. */\nfunction tokenHasAlias(t: TokenNode): boolean {\n    const byCtx = t.byContext || {};\n    for (const k in byCtx) {\n        const v = byCtx[k] as any;\n        if (v && v.kind === \"alias\") return true;\n    }\n    return false;\n}\n\n/** Compare imported hex values against stored metadata and raise a gentle warning if they diverge. */\nfunction maybeWarnColorMismatch(\n    t: TokenNode,\n    ctx: string,\n    importedHexOrNull: string | null\n): void {\n    try {\n        const extAll =\n            t.extensions && typeof t.extensions === \"object\"\n                ? (t.extensions as any)[\"com.figma\"]\n                : undefined;\n        if (!extAll || typeof extAll !== \"object\") return;\n\n        let hintHex: string | undefined;\n        if (typeof extAll.hex === \"string\") hintHex = extAll.hex;\n        const pc =\n            extAll.perContext && typeof extAll.perContext === \"object\"\n                ? extAll.perContext\n                : undefined;\n        if (!hintHex && pc && pc[ctx] && typeof pc[ctx].hex === \"string\")\n            hintHex = pc[ctx].hex;\n\n        if (!hintHex || !importedHexOrNull) return;\n        const a = hintHex.trim().toLowerCase();\n        const b = importedHexOrNull.trim().toLowerCase();\n        if (a !== b)\n            logWarn(\n                `color mismatch for \u201C${t.path.join(\n                    \"/\"\n                )}\u201D in ${ctx}. Using $value over $extensions.`\n            );\n    } catch {\n        /* never throw from logging */\n    }\n}\n\n/** Normalize alias path segments and map collection slugs back to display names when possible. */\nfunction normalizeAliasSegments(\n    rawPath: string[] | string,\n    currentCollection: string,\n    displayBySlug: { [slug: string]: string },\n    knownCollections: Set<string>\n): string[] {\n    const segs = Array.isArray(rawPath)\n        ? rawPath.slice()\n        : String(rawPath)\n              .split(\".\")\n              .map((s) => s.trim())\n              .filter(Boolean);\n\n    if (segs.length === 0) return [currentCollection];\n\n    const first = segs[0];\n    if (knownCollections.has(first)) return segs;\n\n    const mapped = displayBySlug[first];\n    if (mapped && knownCollections.has(mapped)) {\n        segs[0] = mapped;\n        return segs;\n    }\n\n    // relative \u2192 prefix current collection\n    return [currentCollection, ...segs];\n}\n\n/**\n * Ensure $extensions name hints line up with the JSON path we are about to write.\n * Helps catch renamed variables that could otherwise split into duplicate nodes.\n */\nfunction namesMatchExtensions(t: TokenNode): { ok: boolean; reason?: string } {\n    const ext =\n        t.extensions && typeof t.extensions === \"object\"\n            ? (t.extensions as any)[\"com.figma\"]\n            : undefined;\n\n    if (!ext || typeof ext !== \"object\") return { ok: true };\n\n    const pathCollection = t.path[0];\n    const pathVariable = t.path.slice(1).join(\"/\"); // exact JSON key\n\n    let expectedCollection: string | undefined =\n        typeof (ext as any).collectionName === \"string\"\n            ? (ext as any).collectionName\n            : undefined;\n    let expectedVariable: string | undefined =\n        typeof (ext as any).variableName === \"string\"\n            ? (ext as any).variableName\n            : undefined;\n\n    // If top-level missing, try perContext (lenient)\n    if (!expectedCollection || !expectedVariable) {\n        const per = (ext as any).perContext;\n        if (per && typeof per === \"object\") {\n            const ctxKeys = forEachKey(t.byContext);\n            let ctxToUse: string | undefined;\n\n            for (const k of ctxKeys) {\n                if (per[k] && typeof per[k] === \"object\") {\n                    ctxToUse = k;\n                    break;\n                }\n            }\n            if (!ctxToUse) {\n                for (const k in per) {\n                    if (\n                        Object.prototype.hasOwnProperty.call(per, k) &&\n                        per[k] &&\n                        typeof per[k] === \"object\"\n                    ) {\n                        ctxToUse = k;\n                        break;\n                    }\n                }\n            }\n\n            if (ctxToUse) {\n                const ctxData = per[ctxToUse] as any;\n                if (\n                    !expectedCollection &&\n                    typeof ctxData.collectionName === \"string\"\n                )\n                    expectedCollection = ctxData.collectionName;\n                if (\n                    !expectedVariable &&\n                    typeof ctxData.variableName === \"string\"\n                )\n                    expectedVariable = ctxData.variableName;\n            }\n        }\n    }\n\n    if (\n        typeof expectedCollection === \"string\" &&\n        expectedCollection !== pathCollection\n    ) {\n        return {\n            ok: false,\n            reason:\n                `Skipping \u201C${t.path.join(\n                    \"/\"\n                )}\u201D \u2014 $extensions.com.figma.collectionName (\u201C${expectedCollection}\u201D) ` +\n                `doesn\u2019t match JSON group (\u201C${pathCollection}\u201D).`,\n        };\n    }\n\n    if (\n        typeof expectedVariable === \"string\" &&\n        expectedVariable !== pathVariable\n    ) {\n        return {\n            ok: false,\n            reason:\n                `Skipping \u201C${t.path.join(\n                    \"/\"\n                )}\u201D \u2014 $extensions.com.figma.variableName (\u201C${expectedVariable}\u201D) ` +\n                `doesn\u2019t match JSON key (\u201C${pathVariable}\u201D).`,\n        };\n    }\n\n    return { ok: true };\n}\n\nfunction typographyNamesMatchExtensions(\n    t: TokenNode,\n    styleName: string\n): { ok: boolean; reason?: string } {\n    const ext =\n        t.extensions && typeof t.extensions === \"object\"\n            ? (t.extensions as any)[\"com.figma\"]\n            : undefined;\n\n    if (!ext || typeof ext !== \"object\") return { ok: true };\n\n    const expected =\n        typeof (ext as any).styleName === \"string\"\n            ? (ext as any).styleName\n            : undefined;\n    if (expected && expected !== styleName) {\n        return {\n            ok: false,\n            reason: `Skipping \u201C${t.path.join(\n                \"/\"\n            )}\u201D \u2014 $extensions.com.figma.styleName (\u201C${expected}\u201D) doesn\u2019t match JSON key (\u201C${styleName}\u201D).`,\n        };\n    }\n\n    return { ok: true };\n}\n\n// --- Key indexing helpers: index display + slug for BOTH collection and variable segments\nfunction dot(segs: string[]): string {\n    return segs.join(\".\");\n}\n\nfunction indexVarKeys(\n    map: { [k: string]: string },\n    collectionDisplay: string,\n    varSegsRaw: string[],\n    varId: string\n): void {\n    const colDisp = collectionDisplay;\n    const colSlug = slugSegment(collectionDisplay);\n    const varRaw = varSegsRaw;\n    const varSlug = varSegsRaw.map((s) => slugSegment(s));\n\n    // 1) Display collection + Raw variable segs\n    map[dot([colDisp, ...varRaw])] = varId;\n    // 2) Display collection + Slugged variable segs\n    map[dot([colDisp, ...varSlug])] = varId;\n    // 3) Slugged collection + Raw variable segs\n    map[dot([colSlug, ...varRaw])] = varId;\n    // 4) Slugged collection + Slugged variable segs\n    map[dot([colSlug, ...varSlug])] = varId;\n}\n\nexport async function writeIRToFigma(graph: TokenGraph): Promise<WriteResult> {\n    const profile = figma.root.documentColorProfile as DocumentProfile;\n    const canonicalProfile = normalizeDocumentProfile(profile);\n    const variablesApi = figma.variables;\n\n    logInfo(\n        `Import: document color profile ${String(\n            profile\n        )} (canonical ${canonicalProfile}).`\n    );\n\n    const {\n        collections: existingCollections,\n        variablesById,\n        collectionNameById,\n    } = await loadCollectionsSnapshot(variablesApi);\n\n    const colByName: { [name: string]: VariableCollection } = {};\n    for (const c of existingCollections) colByName[c.name] = c;\n\n    const existingVarIdByPathDot: { [dot: string]: string } = {};\n    for (const c of existingCollections) {\n        const cDisplay = c.name;\n        for (const vid of c.variableIds) {\n            const variable = variablesById.get(vid);\n            if (!variable) continue;\n            const varSegs = variable.name.split(\"/\");\n            indexVarKeys(\n                existingVarIdByPathDot,\n                cDisplay,\n                varSegs,\n                variable.id\n            );\n        }\n    }\n\n    // ---- build slug\u2192display mapping for collections (existing + incoming)\n    const knownCollections = new Set<string>(Object.keys(colByName));\n    const displayBySlug: { [slug: string]: string } = {};\n    for (const name of knownCollections)\n        displayBySlug[slugSegment(name)] = name;\n    for (const t of graph.tokens) {\n        const name = t.path[0];\n        knownCollections.add(name);\n        displayBySlug[slugSegment(name)] = name;\n    }\n\n    // ---- buckets for Pass 1a (direct values) and 1b (alias-only)\n    const directTokens: TokenNode[] = [];\n    const aliasOnlyTokens: TokenNode[] = [];\n    const typographyTokens: TokenNode[] = [];\n\n    for (const t of graph.tokens) {\n        if (t.type === \"typography\") {\n            typographyTokens.push(t);\n            continue;\n        }\n        const hasDirect = tokenHasDirectValue(t);\n        const hasAlias = tokenHasAlias(t);\n\n        if (hasDirect) {\n            directTokens.push(t);\n        } else if (hasAlias) {\n            aliasOnlyTokens.push(t);\n        } else {\n            logWarn(\n                `Skipped ${t.type} token \u201C${t.path.join(\"/\")}\u201D \u2014 needs a ${\n                    t.type\n                } $value or an alias reference.`\n            );\n        }\n\n        // Mild note: string tokens that look boolean but have no explicit hint\n        if (\n            t.type === \"string\" &&\n            !readFigmaVariableTypeHint(t) &&\n            tokenHasBooleanLikeString(t)\n        ) {\n            logInfo(\n                `Note: \u201C${t.path.join(\n                    \"/\"\n                )}\u201D has string values \"true\"/\"false\" but no $extensions.com.figma.variableType hint; keeping STRING in Figma.`\n            );\n        }\n    }\n\n    // helper to ensure collection exists (only when we actually create a var)\n    function ensureCollection(name: string): VariableCollection {\n        let col = colByName[name];\n        if (!col) {\n            col = variablesApi.createVariableCollection(name);\n            colByName[name] = col;\n            knownCollections.add(name);\n            displayBySlug[slugSegment(name)] = name;\n            collectionNameById.set(col.id, name);\n        }\n        return col;\n    }\n\n    let createdTextStyles = 0;\n\n    async function importTypographyTokens(tokens: TokenNode[]): Promise<void> {\n        if (tokens.length === 0) return;\n\n        const canReadStyles = typeof figma.getLocalTextStyles === \"function\";\n        const canCreateStyles = typeof figma.createTextStyle === \"function\";\n        if (!canReadStyles || !canCreateStyles) {\n            logWarn(\n                \"Typography tokens present but text style APIs are unavailable in this version of Figma. Skipping typography import.\"\n            );\n            return;\n        }\n\n        const stylesById = new Map<string, TextStyle>();\n        const stylesByName = new Map<string, TextStyle>();\n        const localStyles = figma.getLocalTextStyles();\n        for (const style of localStyles) {\n            stylesById.set(style.id, style);\n            stylesByName.set(style.name, style);\n        }\n\n        const loadedFonts = new Set<string>();\n\n        for (const token of tokens) {\n            const styleSegments = token.path.slice(1);\n            const styleName = styleSegments.join(\"/\");\n            if (!styleName) {\n                logWarn(\n                    `Skipped typography token \u201C${token.path.join(\n                        \"/\"\n                    )}\u201D \u2014 requires a style name after the collection.`\n                );\n                continue;\n            }\n\n            const nameCheck = typographyNamesMatchExtensions(token, styleName);\n            if (!nameCheck.ok) {\n                logWarn(nameCheck.reason!);\n                continue;\n            }\n\n            const ctxKeys = forEachKey(token.byContext);\n            let typographyValue: TypographyValue | null = null;\n            let typographyContexts = 0;\n            for (const ctx of ctxKeys) {\n                const val = token.byContext[ctx];\n                if (!val) continue;\n                if (val.kind === \"typography\") {\n                    typographyContexts++;\n                    if (!typographyValue) typographyValue = val.value;\n                } else if (val.kind === \"alias\") {\n                    logWarn(\n                        `Skipped typography alias at \u201C${token.path.join(\n                            \"/\"\n                        )}\u201D in ${ctx} \u2014 text styles do not support aliases.`\n                    );\n                } else {\n                    logWarn(\n                        `Skipped unsupported value for \u201C${token.path.join(\n                            \"/\"\n                        )}\u201D in ${ctx} \u2014 expected a typography $value.`\n                    );\n                }\n            }\n\n            if (!typographyValue) {\n                logWarn(\n                    `Skipped typography token \u201C${token.path.join(\n                        \"/\"\n                    )}\u201D \u2014 needs a typography $value.`\n                );\n                continue;\n            }\n            if (typographyContexts > 1) {\n                logWarn(\n                    `Typography token \u201C${token.path.join(\n                        \"/\"\n                    )}\u201D has multiple contexts. Using the first typography value.`\n                );\n            }\n\n            const ext =\n                token.extensions && typeof token.extensions === \"object\"\n                    ? (token.extensions as any)[\"com.figma\"]\n                    : undefined;\n            const extStyleId =\n                ext &&\n                typeof ext === \"object\" &&\n                typeof (ext as any).styleID === \"string\"\n                    ? String((ext as any).styleID)\n                    : undefined;\n            const typographyExt =\n                ext && typeof ext === \"object\"\n                    ? ((ext as any).typography as\n                          | TypographyFigmaExtension\n                          | undefined)\n                    : undefined;\n\n            let style: TextStyle | null = null;\n            let createdStyle = false;\n            if (extStyleId) {\n                style = stylesById.get(extStyleId) || null;\n            }\n            if (!style) {\n                style = stylesByName.get(styleName) || null;\n            }\n            if (!style) {\n                style = figma.createTextStyle();\n                createdStyle = true;\n            }\n            const { fontName, usedFallback } =\n                typographyFontNameFromValue(typographyValue);\n            let appliedFont: FontName | null = null;\n            let skipToken = false;\n            const tokenPath = token.path.join(\"/\");\n            if (fontName) {\n                const key = fontName.family + \":::\" + fontName.style;\n                if (!loadedFonts.has(key)) {\n                    try {\n                        await figma.loadFontAsync(fontName);\n                        loadedFonts.add(key);\n                    } catch (err) {\n                        const msg =\n                            err instanceof Error ? err.message : String(err);\n                        logWarn(\n                            `Skipped typography token \u201C${tokenPath}\u201D \u2014 failed to load font \u201C${fontName.family} ${fontName.style}\u201D. ${msg}`\n                        );\n                        skipToken = true;\n                    }\n                }\n                if (!skipToken && loadedFonts.has(key)) {\n                    appliedFont = fontName;\n                    if (usedFallback) {\n                        logInfo(\n                            `Typography token \u201C${token.path.join(\n                                \"/\"\n                            )}\u201D is missing a font style. Defaulted to \u201C${\n                                fontName.style\n                            }\u201D.`\n                        );\n                    }\n                }\n            } else {\n                logWarn(\n                    `Skipped typography token \u201C${tokenPath}\u201D \u2014 typography token is missing fontFamily.`\n                );\n                skipToken = true;\n            }\n\n            if (skipToken || !appliedFont) {\n                if (createdStyle) {\n                    try {\n                        style.remove();\n                    } catch {\n                        /* ignore */\n                    }\n                }\n                continue;\n            }\n\n            const prevName = style.name;\n            if (style.name !== styleName) {\n                style.name = styleName;\n            }\n            stylesById.set(style.id, style);\n            if (prevName && stylesByName.get(prevName) === style) {\n                stylesByName.delete(prevName);\n            }\n            stylesByName.set(styleName, style);\n\n            if (\n                typeof token.description === \"string\" &&\n                token.description.trim().length > 0 &&\n                style.description !== token.description\n            ) {\n                try {\n                    style.description = token.description;\n                } catch {\n                    /* ignore */\n                }\n            }\n\n            if (createdStyle) {\n                createdTextStyles++;\n            }\n\n            const warnings = applyTypographyValueToTextStyle(\n                style,\n                typographyValue,\n                {\n                    fontName: appliedFont,\n                    figma: typographyExt ?? null,\n                }\n            );\n            for (const warning of warnings) {\n                logWarn(`Text style \u201C${styleName}\u201D: ${warning}`);\n            }\n        }\n    }\n\n    // ---- Pass 1a: create direct-value variables, collect ids\n    const idByPath: { [dot: string]: string } = {};\n\n    function varNameFromPath(path: string[]): string {\n        // everything after the collection joined with '/'\n        return path.slice(1).join(\"/\") || path[0] || \"token\";\n    }\n\n    for (const t of directTokens) {\n        if (t.path.length < 1) continue;\n\n        // enforce strict name match vs $extensions (when present)\n        const nameChk = namesMatchExtensions(t);\n        if (!nameChk.ok) {\n            logWarn(nameChk.reason!);\n            continue;\n        }\n\n        const collectionName = t.path[0];\n        const varName = varNameFromPath(t.path);\n\n        // Do NOT create a collection or variable unless we have at least one *valid* direct value.\n        const directCheck = tokenHasAtLeastOneValidDirectValue(t, profile);\n        if (!directCheck.ok) {\n            if (directCheck.reason) {\n                logWarn(\n                    `Skipped creating direct ${t.type} token \u201C${t.path.join(\n                        \"/\"\n                    )}\u201D \u2014 ${directCheck.reason}`\n                );\n            } else if (!directCheck.suppressWarn) {\n                logWarn(\n                    `Skipped creating direct ${t.type} token \u201C${t.path.join(\n                        \"/\"\n                    )}\u201D \u2014 no valid direct values in any context; not creating variable or collection.`\n                );\n            }\n            continue;\n        }\n\n        const col = ensureCollection(collectionName);\n\n        // find existing\n        let existingVarId: string | null = null;\n        for (const vid of col.variableIds) {\n            const cand =\n                variablesById.get(vid) ||\n                (await variablesApi.getVariableByIdAsync(vid));\n            if (cand && !variablesById.has(vid) && cand)\n                variablesById.set(vid, cand);\n            if (cand && cand.name === varName) {\n                existingVarId = cand.id;\n                break;\n            }\n        }\n\n        let v: Variable | null = null;\n        if (existingVarId) {\n            v =\n                variablesById.get(existingVarId) ||\n                (await variablesApi.getVariableByIdAsync(existingVarId));\n            if (v && !variablesById.has(existingVarId))\n                variablesById.set(existingVarId, v);\n            if (!v) continue;\n        } else {\n            const hint = readFigmaVariableTypeHint(t);\n            // Strict rule: only honor BOOLEAN hint when DTCG $type is \"string\".\n            const createAs: VariableResolvedDataType =\n                hint === \"BOOLEAN\" && t.type === \"string\"\n                    ? \"BOOLEAN\"\n                    : resolvedTypeFor(t.type);\n\n            v = variablesApi.createVariable(varName, col, createAs);\n            variablesById.set(v.id, v);\n        }\n\n        // --- set description if provided (safe & idempotent)\n        if (\n            typeof t.description === \"string\" &&\n            t.description.trim().length > 0 &&\n            v.description !== t.description\n        ) {\n            try {\n                v.description = t.description;\n            } catch {\n                /* ignore */\n            }\n        }\n\n        // Index display & slug for BOTH collection and variable segments\n        const varSegs = varName.split(\"/\");\n        indexVarKeys(idByPath, collectionName, varSegs, v.id);\n    }\n\n    // ---- Pass 1b: create alias-only variables in ROUNDS so intra-collection chains work\n    const pending: TokenNode[] = aliasOnlyTokens.slice();\n    while (pending.length) {\n        let progress = false;\n        const nextRound: TokenNode[] = [];\n\n        for (const t of pending) {\n            // enforce strict name match vs $extensions (when present)\n            const nameChk = namesMatchExtensions(t);\n            if (!nameChk.ok) {\n                logWarn(nameChk.reason!);\n                continue;\n            }\n\n            const collectionName = t.path[0];\n            const varName = varNameFromPath(t.path);\n\n            // Self keys (display + slug) for skipping self-alias resolvability\n            const selfVarSegs = varName.split(\"/\");\n            const selfKeys = new Set<string>();\n            (function addSelfKeys() {\n                const colDisp = collectionName;\n                const colSlug = slugSegment(collectionName);\n                const varRaw = selfVarSegs;\n                const varSlug = selfVarSegs.map((s) => slugSegment(s));\n                selfKeys.add(dot([colDisp, ...varRaw]));\n                selfKeys.add(dot([colDisp, ...varSlug]));\n                selfKeys.add(dot([colSlug, ...varRaw]));\n                selfKeys.add(dot([colSlug, ...varSlug]));\n            })();\n\n            // Is ANY alias context resolvable now? (newly created, direct, or existing doc) \u2014 excluding self\n            let resolvable = false;\n            const ctxKeys = forEachKey(t.byContext);\n            for (const ctx of ctxKeys) {\n                const val = (t.byContext as any)[ctx];\n                if (!val || val.kind !== \"alias\") continue;\n\n                const segs = normalizeAliasSegments(\n                    val.path,\n                    collectionName,\n                    displayBySlug,\n                    knownCollections\n                );\n                const aliasDot = dot(segs);\n\n                if (selfKeys.has(aliasDot)) continue; // ignore self-alias\n\n                if (idByPath[aliasDot] || existingVarIdByPathDot[aliasDot]) {\n                    resolvable = true;\n                    break;\n                }\n            }\n\n            if (!resolvable) {\n                // hold for next round\n                nextRound.push(t);\n                continue;\n            }\n\n            // Create the variable now (even if its value will be set in Pass 2)\n            const col = ensureCollection(collectionName);\n\n            // find existing\n            let existingVarId: string | null = null;\n            for (const vid of col.variableIds) {\n                const cand =\n                    variablesById.get(vid) ||\n                    (await variablesApi.getVariableByIdAsync(vid));\n                if (cand && !variablesById.has(vid))\n                    variablesById.set(vid, cand);\n                if (cand && cand.name === varName) {\n                    existingVarId = cand.id;\n                    break;\n                }\n            }\n\n            let v: Variable | null = null;\n            if (existingVarId) {\n                v =\n                    variablesById.get(existingVarId) ||\n                    (await variablesApi.getVariableByIdAsync(existingVarId));\n                if (v && !variablesById.has(existingVarId))\n                    variablesById.set(existingVarId, v);\n                if (!v) continue;\n            } else {\n                const hint = readFigmaVariableTypeHint(t);\n                const createAs: VariableResolvedDataType =\n                    hint === \"BOOLEAN\" && t.type === \"string\"\n                        ? \"BOOLEAN\"\n                        : resolvedTypeFor(t.type);\n\n                v = variablesApi.createVariable(varName, col, createAs);\n                variablesById.set(v.id, v);\n            }\n\n            // --- set description if provided (safe & idempotent)\n            if (\n                typeof t.description === \"string\" &&\n                t.description.trim().length > 0 &&\n                v.description !== t.description\n            ) {\n                try {\n                    v.description = t.description;\n                } catch {\n                    /* ignore */\n                }\n            }\n\n            // Index display & slug for BOTH collection and variable segments\n            const varSegs = varName.split(\"/\");\n            indexVarKeys(idByPath, collectionName, varSegs, v.id);\n\n            progress = true;\n        }\n\n        if (!progress) {\n            // Nothing more could be created; warn & drop what\u2019s left\n            for (const t of nextRound) {\n                logWarn(\n                    `Alias target not found for \u201C${t.path.join(\n                        \"/\"\n                    )}\u201D. Variable not created.`\n                );\n            }\n            break;\n        }\n\n        // Continue with whatever is still pending\n        pending.length = 0;\n        Array.prototype.push.apply(pending, nextRound);\n    }\n\n    await importTypographyTokens(typographyTokens);\n\n    // ---- Build mode id lookup (collectionName/modeName \u2192 modeId)\n    const modeIdByKey: { [key: string]: string } = {};\n    const colsPost = await variablesApi.getLocalVariableCollectionsAsync();\n    for (const c of colsPost) {\n        for (const m of c.modes) {\n            modeIdByKey[c.name + \"/\" + m.name] = m.modeId;\n        }\n    }\n\n    // ---- Pass 2: set values (including aliases) + optional description sync\n    for (const node of graph.tokens) {\n        // resolve our variable id via any of the 4 keys we indexed\n        const collectionName = node.path[0];\n        const varName = node.path.slice(1).join(\"/\");\n        const varSegs = varName.split(\"/\");\n        const possibleSelfKeys: string[] = [];\n        (function addSelfKeys() {\n            const colDisp = collectionName;\n            const colSlug = slugSegment(collectionName);\n            const varRaw = varSegs;\n            const varSlug = varSegs.map((s) => slugSegment(s));\n            possibleSelfKeys.push(\n                dot([colDisp, ...varRaw]),\n                dot([colDisp, ...varSlug]),\n                dot([colSlug, ...varRaw]),\n                dot([colSlug, ...varSlug])\n            );\n        })();\n        let varId: string | undefined;\n        for (const k of possibleSelfKeys) {\n            varId = idByPath[k];\n            if (varId) break;\n        }\n        if (!varId) continue; // not created (e.g., unresolved alias or name mismatch)\n\n        const targetVar =\n            variablesById.get(varId) ||\n            (await variablesApi.getVariableByIdAsync(varId));\n        if (targetVar && !variablesById.has(varId))\n            variablesById.set(varId, targetVar);\n        if (!targetVar) continue;\n\n        // Optional: keep existing variables' descriptions in sync with incoming IR\n        if (\n            typeof node.description === \"string\" &&\n            node.description.trim().length > 0 &&\n            targetVar.description !== node.description\n        ) {\n            try {\n                targetVar.description = node.description;\n            } catch {\n                /* ignore */\n            }\n        }\n\n        const ctxKeys = forEachKey(node.byContext);\n        for (const ctx of ctxKeys) {\n            const val = node.byContext[ctx] as any;\n\n            // ensure mode exists (default \"Mode 1\" when missing)\n            let modeId = modeIdByKey[ctx];\n            if (!modeId) {\n                const parts = ctx.split(\"/\");\n                const cName = parts[0];\n                const mName = parts.slice(1).join(\"/\") || \"Mode 1\";\n                const col = colByName[cName];\n                if (col) {\n                    const found = col.modes.find((m) => m.name === mName);\n                    if (found) {\n                        modeId = found.modeId;\n                        modeIdByKey[cName + \"/\" + mName] = modeId;\n                        modeIdByKey[ctx] = modeId;\n                    } else if (col.modes.length === 1) {\n                        const loneMode = col.modes[0];\n                        const prevName = loneMode.name;\n                        if (prevName !== mName) {\n                            logWarn(\n                                `Collection \u201C${cName}\u201D is limited to a single mode. Renaming \u201C${prevName}\u201D to \u201C${mName}\u201D.`\n                            );\n                            try {\n                                col.renameMode(loneMode.modeId, mName);\n                                loneMode.name = mName;\n                                const keyOld = cName + \"/\" + prevName;\n                                delete modeIdByKey[keyOld];\n                                modeId = loneMode.modeId;\n                                const keyNew = cName + \"/\" + mName;\n                                modeIdByKey[keyNew] = modeId;\n                                modeIdByKey[ctx] = modeId;\n                                logInfo(\n                                    `Renamed mode \u201C${prevName}\u201D \u2192 \u201C${mName}\u201D in collection \u201C${cName}\u201D.`\n                                );\n                            } catch (err) {\n                                const errMsg =\n                                    err instanceof Error\n                                        ? err.message\n                                        : String(err);\n                                logError(\n                                    `Failed to rename mode \u201C${prevName}\u201D to \u201C${mName}\u201D in collection \u201C${cName}\u201D. ${errMsg}`\n                                );\n                            }\n                        } else {\n                            modeId = loneMode.modeId;\n                            modeIdByKey[cName + \"/\" + mName] = modeId;\n                            modeIdByKey[ctx] = modeId;\n                        }\n                    } else {\n                        try {\n                            modeId = col.addMode(mName);\n                            modeIdByKey[cName + \"/\" + mName] = modeId;\n                            modeIdByKey[ctx] = modeId;\n                        } catch (err) {\n                            const message =\n                                err instanceof Error\n                                    ? err.message\n                                    : String(err);\n                            if (message && message.includes(\"Limited to 1\")) {\n                                const loneMode = col.modes[0];\n                                const prevName = loneMode?.name || \"Mode 1\";\n                                logWarn(\n                                    `Unable to add mode \u201C${mName}\u201D to collection \u201C${cName}\u201D because only a single mode is allowed. Renaming existing mode \u201C${prevName}\u201D.`\n                                );\n                                try {\n                                    if (loneMode) {\n                                        col.renameMode(loneMode.modeId, mName);\n                                        loneMode.name = mName;\n                                        const keyOld = cName + \"/\" + prevName;\n                                        delete modeIdByKey[keyOld];\n                                        modeId = loneMode.modeId;\n                                        const keyNew = cName + \"/\" + mName;\n                                        modeIdByKey[keyNew] = modeId;\n                                        modeIdByKey[ctx] = modeId;\n                                        logInfo(\n                                            `Renamed mode \u201C${prevName}\u201D \u2192 \u201C${mName}\u201D in collection \u201C${cName}\u201D.`\n                                        );\n                                    } else {\n                                        logError(\n                                            `Unable to rename mode in collection \u201C${cName}\u201D because it has no modes.`\n                                        );\n                                    }\n                                } catch (renameErr) {\n                                    const renameMsg =\n                                        renameErr instanceof Error\n                                            ? renameErr.message\n                                            : String(renameErr);\n                                    logError(\n                                        `Failed to rename mode \u201C${prevName}\u201D to \u201C${mName}\u201D in collection \u201C${cName}\u201D. ${renameMsg}`\n                                    );\n                                }\n                            } else {\n                                logError(\n                                    `Error while adding mode \u201C${mName}\u201D to collection \u201C${cName}\u201D. ${message}`\n                                );\n                            }\n                        }\n                    }\n                }\n            }\n            if (!modeId) continue;\n\n            if (val.kind === \"alias\") {\n                const currentCollection = collectionName;\n\n                // Build candidates (as-written, relative, slug\u2192display for first seg).\n                const rawSegs = Array.isArray(val.path)\n                    ? (val.path as string[]).slice()\n                    : String(val.path)\n                          .split(\".\")\n                          .map((s) => s.trim())\n                          .filter(Boolean);\n\n                const candidates: string[][] = [];\n                if (rawSegs.length > 0) candidates.push(rawSegs);\n                candidates.push([currentCollection, ...rawSegs]);\n                if (rawSegs.length > 0 && displayBySlug[rawSegs[0]]) {\n                    candidates.push([\n                        displayBySlug[rawSegs[0]],\n                        ...rawSegs.slice(1),\n                    ]);\n                }\n\n                let targetId: string | undefined;\n                for (const cand of candidates) {\n                    // Try exact, and also a fully-slugged form (for non-color types referencing other collections)\n                    const exact = dot(cand);\n                    const fullySlugged = dot([\n                        slugSegment(cand[0] || \"\"),\n                        ...cand.slice(1).map((s) => slugSegment(s)),\n                    ]);\n\n                    targetId =\n                        idByPath[exact] ||\n                        idByPath[fullySlugged] ||\n                        existingVarIdByPathDot[exact] ||\n                        existingVarIdByPathDot[fullySlugged];\n\n                    if (targetId) break;\n                }\n\n                if (!targetId) {\n                    logWarn(\n                        `Alias target not found while setting \u201C${node.path.join(\n                            \"/\"\n                        )}\u201D in ${ctx}. Skipped this context.`\n                    );\n                    continue;\n                }\n\n                // prevent self-alias even if resolvable\n                if (targetId === targetVar.id) {\n                    logWarn(\n                        `Self-alias is not allowed for \u201C${node.path.join(\n                            \"/\"\n                        )}\u201D in ${ctx}. Skipped this context.`\n                    );\n                    continue;\n                }\n\n                const aliasObj =\n                    await variablesApi.createVariableAliasByIdAsync(targetId);\n                targetVar.setValueForMode(modeId, aliasObj);\n                continue;\n            } else if (val.kind === \"color\") {\n                // STRICT: validate DTCG color object shape first\n                const shape = isDtcgColorShapeValid(val.value);\n                if (!shape.ok) {\n                    logWarn(\n                        `Skipped setting color for \u201C${node.path.join(\n                            \"/\"\n                        )}\u201D in ${ctx} \u2014 ${shape.reason}.`\n                    );\n                    continue;\n                }\n\n                // STRICT: check representability in this document profile\n                const cs = (val.value.colorSpace || \"srgb\").toLowerCase();\n                if (\n                    !isColorSpaceRepresentableInDocument(cs, canonicalProfile)\n                ) {\n                    if (cs === \"display-p3\" && canonicalProfile === \"SRGB\") {\n                        logWarn(\n                            `Skipped \u201C${node.path.join(\n                                \"/\"\n                            )}\u201D in ${ctx}: the token is display-p3 but this file is set to sRGB. ` +\n                                \"Open File \u2192 File Settings \u2192 Color Space and switch to Display P3, or convert the token to sRGB.\"\n                        );\n                    } else {\n                        logWarn(\n                            `Skipped setting color for \u201C${node.path.join(\n                                \"/\"\n                            )}\u201D in ${ctx} \u2014 colorSpace \u201C${cs}\u201D isn\u2019t representable in this document (${canonicalProfile}).`\n                        );\n                    }\n                    continue;\n                }\n\n                // Safe normalization (no destructive clamping before checks)\n                const norm = normalizeDtcgColorValue(val.value);\n                maybeWarnColorMismatch(\n                    node,\n                    ctx,\n                    typeof norm.hex === \"string\" ? norm.hex : null\n                );\n                const rgba = dtcgToFigmaRGBA(norm, profile);\n                targetVar.setValueForMode(modeId, {\n                    r: rgba.r,\n                    g: rgba.g,\n                    b: rgba.b,\n                    a: rgba.a,\n                });\n            } else if (\n                val.kind === \"number\" ||\n                val.kind === \"string\" ||\n                val.kind === \"boolean\"\n            ) {\n                // BOOLEAN round-trip:\n                // - If the Figma variable was created as BOOLEAN (by hint), accept true/false safely.\n                // - If it's STRING but IR provides a boolean, downgrade to \"true\"/\"false\".\n                if (targetVar.resolvedType === \"BOOLEAN\") {\n                    if (val.kind === \"boolean\") {\n                        targetVar.setValueForMode(modeId, !!val.value);\n                    } else if (\n                        val.kind === \"string\" &&\n                        looksBooleanString(val.value)\n                    ) {\n                        targetVar.setValueForMode(\n                            modeId,\n                            /^true$/i.test(val.value.trim())\n                        );\n                    } else {\n                        logWarn(\n                            `Skipped setting non-boolean value for BOOLEAN variable \u201C${node.path.join(\n                                \"/\"\n                            )}\u201D in ${ctx}.`\n                        );\n                    }\n                } else if (val.kind === \"boolean\") {\n                    // Figma var is not BOOLEAN \u2192 set as string \"true\"/\"false\" (non-breaking)\n                    targetVar.setValueForMode(\n                        modeId,\n                        val.value ? \"true\" : \"false\"\n                    );\n                } else {\n                    targetVar.setValueForMode(modeId, val.value);\n                }\n            }\n        }\n    }\n\n    // After Pass 2 and after setting values\n    for (const name of Object.keys(colByName)) {\n        const col = colByName[name];\n        if (col && col.variableIds.length === 0) {\n            try {\n                col.remove();\n            } catch {\n                /* ignore */\n            }\n            knownCollections.delete(name);\n            delete colByName[name];\n        }\n    }\n    return { createdTextStyles };\n}\n", "// src/core/pipeline.ts\n// Pipeline glue between adapters and the UI.\n// - importDtcg: DTCG JSON -> IR -> write to Figma\n// - exportDtcg: read IR from Figma -> serialize to DTCG; package as files\n\nimport { normalize } from \"./normalize\";\nimport { readDtcgToIR } from \"../adapters/dtcg-reader\";\nimport { serialize } from \"../adapters/dtcg-writer\";\nimport { readFigmaToIR } from \"../adapters/figma-reader\";\nimport { writeIRToFigma } from \"../adapters/figma-writer\";\nimport type { TokenGraph, TokenNode, ValueOrAlias } from \"./ir\";\n\nexport interface ExportOpts {\n    format: \"single\" | \"perMode\" | \"typography\";\n    styleDictionary?: boolean;\n    flatTokens?: boolean;\n}\nexport interface ExportResult {\n    files: Array<{ name: string; json: unknown }>;\n}\n\nexport interface ImportSummary {\n    /** Total tokens parsed from the incoming file. */\n    totalTokens: number;\n    /** Tokens that remained after applying the selected contexts. */\n    importedTokens: number;\n    /** Total number of Figma styles created while applying the import. */\n    createdStyles: number;\n    /** Every context discovered in the incoming file (Collection/Mode). */\n    availableContexts: string[];\n    /** Contexts actually written to the document after filtering. */\n    appliedContexts: string[];\n    /** Contexts that were intentionally skipped because they weren't selected. */\n    skippedContexts: Array<{ context: string; reason: string }>;\n    /** Contexts requested by the UI that did not exist in the incoming file. */\n    missingRequestedContexts: string[];\n    /** Raw contexts requested by the UI (before intersecting with available contexts). */\n    selectionRequested: string[];\n    /** True when the requested selection had no overlap and we fell back to all contexts. */\n    selectionFallbackToAll?: boolean;\n    /** Tokens that lost one or more contexts during filtering. */\n    tokensWithRemovedContexts: Array<{\n        path: string;\n        removedContexts: string[];\n        keptContexts: string[];\n        reason: \"partial\" | \"removed\";\n    }>;\n}\n\n// ---------- helpers ----------\n\nexport interface ImportOpts {\n    allowHexStrings?: boolean;\n    contexts?: string[];\n}\n\n/**\n * Capture the enumerable keys on a plain object without trusting prototype mutation.\n * We keep this helper local so the export path never depends on a broader utility module.\n */\nfunction keysOf<T>(obj: { [k: string]: T }): string[] {\n    const out: string[] = [];\n    let k: string;\n    for (k in obj)\n        if (Object.prototype.hasOwnProperty.call(obj, k)) out.push(k);\n    return out;\n}\n\n/**\n * Replace file-hostile characters so each export path is safe for Git commits on every OS.\n * Using a narrow allow list keeps legacy file names stable while preventing accidental nesting.\n * Includes control characters (\\u0000-\\u001F) which are invalid in file paths and could cause\n * security issues or filesystem errors.\n */\n// eslint-disable-next-line no-control-regex -- Intentionally filtering control characters for path safety\nconst INVALID_FILE_CHARS = /[<>:\"/\\\\|?*\\u0000-\\u001F]/g;\n\nfunction sanitizeForFile(s: string): string {\n    let cleaned = String(s);\n    cleaned = cleaned.replace(INVALID_FILE_CHARS, \"_\");\n    cleaned = cleaned.replace(/\\s+/g, \" \").trim();\n    cleaned = cleaned.replace(/[. ]+$/g, \"\");\n    return cleaned;\n}\n\n/**\n * Build a copy of a token that only contains the requested context so per-mode exports stay minimal.\n * Returning null when the context is absent lets the caller drop empty files entirely.\n */\nfunction cloneTokenWithSingleContext(\n    t: TokenNode,\n    ctx: string\n): TokenNode | null {\n    const val = t.byContext[ctx];\n    if (!val) return null;\n\n    // shallow clone without spreads\n    const copyByCtx: { [k: string]: ValueOrAlias } = {};\n    copyByCtx[ctx] = val;\n\n    return {\n        path: (function () {\n            const arr: string[] = [];\n            let i = 0;\n            for (i = 0; i < t.path.length; i++) arr.push(t.path[i]);\n            return arr;\n        })(),\n        type: t.type,\n        byContext: copyByCtx,\n        description: t.description,\n        extensions: t.extensions,\n    };\n}\n\nfunction collectContextsFromGraph(graph: TokenGraph): string[] {\n    const seen: string[] = [];\n    let i = 0;\n    for (i = 0; i < graph.tokens.length; i++) {\n        const t = graph.tokens[i];\n        const ks = keysOf(t.byContext);\n        let j = 0;\n        for (j = 0; j < ks.length; j++) {\n            const ctx = ks[j];\n            let already = false;\n            let k = 0;\n            for (k = 0; k < seen.length; k++)\n                if (seen[k] === ctx) {\n                    already = true;\n                    break;\n                }\n            if (!already) seen.push(ctx);\n        }\n    }\n    return seen;\n}\n\nfunction sanitizeContexts(list: string[] | undefined): string[] {\n    if (!list) return [];\n    const out: string[] = [];\n    for (let i = 0; i < list.length; i++) {\n        const raw = list[i];\n        if (typeof raw !== \"string\") continue;\n        const trimmed = raw.trim();\n        if (!trimmed) continue;\n        let exists = false;\n        for (let j = 0; j < out.length; j++)\n            if (out[j] === trimmed) {\n                exists = true;\n                break;\n            }\n        if (!exists) out.push(trimmed);\n    }\n    return out;\n}\n\nfunction filterGraphByContexts(\n    graph: TokenGraph,\n    requested: string[]\n): { graph: TokenGraph; summary: ImportSummary } {\n    const available = collectContextsFromGraph(graph);\n    const requestedList = sanitizeContexts(requested);\n\n    const availableSet: { [k: string]: true } = {};\n    for (let ai = 0; ai < available.length; ai++)\n        availableSet[available[ai]] = true;\n\n    const appliedSet: { [k: string]: true } = {};\n    const missingRequested: string[] = [];\n    let fallbackToAll = false;\n\n    if (requestedList.length > 0) {\n        for (let ri = 0; ri < requestedList.length; ri++) {\n            const ctx = requestedList[ri];\n            if (availableSet[ctx]) appliedSet[ctx] = true;\n            else missingRequested.push(ctx);\n        }\n        if (Object.keys(appliedSet).length === 0 && available.length > 0) {\n            fallbackToAll = true;\n            for (let ai2 = 0; ai2 < available.length; ai2++)\n                appliedSet[available[ai2]] = true;\n        }\n    } else {\n        for (let ai3 = 0; ai3 < available.length; ai3++)\n            appliedSet[available[ai3]] = true;\n    }\n\n    const appliedList: string[] = [];\n    for (const ctxKey in appliedSet)\n        if (Object.prototype.hasOwnProperty.call(appliedSet, ctxKey))\n            appliedList.push(ctxKey);\n    appliedList.sort();\n\n    const skippedList: Array<{ context: string; reason: string }> = [];\n    for (let si = 0; si < available.length; si++) {\n        const ctxAvailable = available[si];\n        if (!appliedSet[ctxAvailable]) {\n            skippedList.push({\n                context: ctxAvailable,\n                reason: \"Excluded by partial import selection\",\n            });\n        }\n    }\n    skippedList.sort(function (a, b) {\n        if (a.context === b.context) return 0;\n        return a.context < b.context ? -1 : 1;\n    });\n\n    const filteredTokens: TokenNode[] = [];\n    const removedTokens: Array<{\n        path: string;\n        removedContexts: string[];\n        keptContexts: string[];\n        reason: \"partial\" | \"removed\";\n    }> = [];\n\n    for (let ti = 0; ti < graph.tokens.length; ti++) {\n        const tok = graph.tokens[ti];\n        const ctxs = keysOf(tok.byContext);\n        if (ctxs.length === 0) {\n            // Nothing to filter; keep token as-is (clone for safety).\n            const cloneEmpty: TokenNode = {\n                path: tok.path.slice(),\n                type: tok.type,\n                byContext: {},\n            };\n            if (typeof tok.description !== \"undefined\")\n                cloneEmpty.description = tok.description;\n            if (typeof tok.extensions !== \"undefined\")\n                cloneEmpty.extensions = tok.extensions;\n            filteredTokens.push(cloneEmpty);\n            continue;\n        }\n\n        const kept: string[] = [];\n        const removed: string[] = [];\n        const newCtx: { [k: string]: ValueOrAlias } = {};\n\n        for (let ci = 0; ci < ctxs.length; ci++) {\n            const ctx = ctxs[ci];\n            if (appliedSet[ctx]) {\n                kept.push(ctx);\n                newCtx[ctx] = tok.byContext[ctx];\n            } else {\n                removed.push(ctx);\n            }\n        }\n\n        if (kept.length === 0) {\n            removedTokens.push({\n                path: tok.path.join(\"/\"),\n                removedContexts: removed.slice(),\n                keptContexts: [],\n                reason: \"removed\",\n            });\n            continue;\n        }\n\n        if (removed.length > 0) {\n            removedTokens.push({\n                path: tok.path.join(\"/\"),\n                removedContexts: removed.slice(),\n                keptContexts: kept.slice(),\n                reason: \"partial\",\n            });\n        }\n\n        const clone: TokenNode = {\n            path: tok.path.slice(),\n            type: tok.type,\n            byContext: newCtx,\n        };\n        if (typeof tok.description !== \"undefined\")\n            clone.description = tok.description;\n        if (typeof tok.extensions !== \"undefined\")\n            clone.extensions = tok.extensions;\n        filteredTokens.push(clone);\n    }\n\n    removedTokens.sort(function (a, b) {\n        if (a.path === b.path) return 0;\n        return a.path < b.path ? -1 : 1;\n    });\n\n    return {\n        graph: { tokens: filteredTokens },\n        summary: {\n            totalTokens: graph.tokens.length,\n            importedTokens: filteredTokens.length,\n            createdStyles: 0,\n            availableContexts: available.slice().sort(),\n            appliedContexts: appliedList,\n            skippedContexts: skippedList,\n            missingRequestedContexts: missingRequested,\n            selectionRequested: requestedList,\n            selectionFallbackToAll: fallbackToAll ? true : undefined,\n            tokensWithRemovedContexts: removedTokens,\n        },\n    };\n}\n\n// ---------- API ----------\n\n// Read a DTCG payload, normalize it, and write the resulting graph into the current document.\nexport async function importDtcg(\n    json: unknown,\n    opts: ImportOpts = {}\n): Promise<ImportSummary> {\n    // Build desired graph from DTCG, then write directly to Figma.\n    // We previously shipped an unused \"plan\" module that tried to diff the desired\n    // graph against the live document. Nothing in the plugin ever called it, and\n    // the write path already overwrites the full state, so keeping the unused\n    // module only increased bundle size and maintenance cost. Keeping a single\n    // happy-path write keeps the observable behavior identical to the versions\n    // that shipped before the cleanup.\n    const desired = normalize(\n        readDtcgToIR(json, { allowHexStrings: !!opts.allowHexStrings })\n    );\n    const filtered = filterGraphByContexts(desired, opts.contexts || []);\n    const writeResult = await writeIRToFigma(filtered.graph);\n    filtered.summary.createdStyles = writeResult.createdTextStyles;\n    return filtered.summary;\n}\n\n// Pull the latest graph from Figma and emit files in the format requested by the UI (single/per-mode/typography).\nexport async function exportDtcg(opts: ExportOpts): Promise<ExportResult> {\n    const current = await readFigmaToIR();\n    const graph = normalize(current);\n    const styleDictionary = !!opts.styleDictionary;\n    const flatTokens = !!opts.flatTokens;\n\n    if (opts.format === \"typography\") {\n        const typographyTokens: TokenNode[] = [];\n        for (let ti = 0; ti < graph.tokens.length; ti++) {\n            const tok = graph.tokens[ti];\n            if (tok.type === \"typography\") {\n                const cloneTypo: TokenNode = {\n                    path: tok.path.slice(),\n                    type: tok.type,\n                    byContext: {} as { [ctx: string]: ValueOrAlias },\n                };\n                const ctxKeys = keysOf(tok.byContext);\n                for (let ci = 0; ci < ctxKeys.length; ci++) {\n                    const ctx = ctxKeys[ci];\n                    cloneTypo.byContext[ctx] = tok.byContext[ctx];\n                }\n                if (typeof tok.description !== \"undefined\")\n                    cloneTypo.description = tok.description;\n                if (typeof tok.extensions !== \"undefined\")\n                    cloneTypo.extensions = tok.extensions;\n                typographyTokens.push(cloneTypo);\n            }\n        }\n\n        const typographyGraph: TokenGraph = { tokens: typographyTokens };\n        const typographySerialized = serialize(typographyGraph, {\n            styleDictionary: styleDictionary,\n            flatTokens: flatTokens,\n        });\n        let typographyJson = typographySerialized.json;\n        if (!typographyTokens.length) {\n            typographyJson = {};\n        }\n        return { files: [{ name: \"typography.json\", json: typographyJson }] };\n    }\n\n    if (opts.format === \"single\") {\n        // One file with whatever contexts exist; writer will emit the first available per token.\n        const single = serialize(graph, {\n            styleDictionary: styleDictionary,\n            flatTokens: flatTokens,\n        });\n        return { files: [{ name: \"tokens.json\", json: single.json }] };\n    }\n\n    // Per mode: split graph by context \"Collection/Mode\", one file each.\n    const contexts: string[] = [];\n    let i = 0;\n    for (i = 0; i < graph.tokens.length; i++) {\n        const t = graph.tokens[i];\n        const ks = keysOf(t.byContext);\n        let j = 0;\n        for (j = 0; j < ks.length; j++) {\n            const c = ks[j];\n            // push if unique\n            let found = false;\n            let k = 0;\n            for (k = 0; k < contexts.length; k++)\n                if (contexts[k] === c) {\n                    found = true;\n                    break;\n                }\n            if (!found) contexts.push(c);\n        }\n    }\n\n    // Build a file per context\n    const files: Array<{ name: string; json: unknown }> = [];\n    let ci = 0;\n    for (ci = 0; ci < contexts.length; ci++) {\n        const ctx = contexts[ci];\n\n        // Create a filtered graph where each token only carries this ctx (if present)\n        const filtered: TokenGraph = { tokens: [] };\n        let ii = 0;\n        for (ii = 0; ii < graph.tokens.length; ii++) {\n            const tok = graph.tokens[ii];\n            const one = cloneTokenWithSingleContext(tok, ctx);\n            if (one) filtered.tokens.push(one);\n        }\n\n        // If nothing in this context, skip\n        if (filtered.tokens.length === 0) continue;\n\n        const out = serialize(filtered, {\n            styleDictionary: styleDictionary,\n            flatTokens: flatTokens,\n        });\n\n        // Try to recover the original collection/mode names from per-context metadata so\n        // we don't lose slashes or other punctuation that appears in the collection name.\n        let collection = ctx;\n        let mode = \"default\";\n\n        let haveCollection = false;\n        let haveMode = false;\n        for (\n            ii = 0;\n            ii < filtered.tokens.length && (!haveCollection || !haveMode);\n            ii++\n        ) {\n            const tok = filtered.tokens[ii];\n            if (!tok || !tok.extensions) continue;\n\n            const figmaExt = (tok.extensions as { [k: string]: unknown })[\n                \"com.figma\"\n            ] as\n                | {\n                      perContext?: {\n                          [ctx: string]: {\n                              collectionName?: string;\n                              modeName?: string;\n                          };\n                      };\n                  }\n                | undefined;\n            if (!figmaExt || typeof figmaExt !== \"object\") continue;\n\n            const perCtx = figmaExt.perContext;\n            if (!perCtx || typeof perCtx !== \"object\") continue;\n\n            const ctxMeta = perCtx[ctx];\n            if (!ctxMeta || typeof ctxMeta !== \"object\") continue;\n\n            const ctxCollection = (ctxMeta as { collectionName?: unknown })\n                .collectionName;\n            const ctxMode = (ctxMeta as { modeName?: unknown }).modeName;\n\n            if (typeof ctxCollection === \"string\" && !haveCollection) {\n                collection = ctxCollection;\n                haveCollection = true;\n            }\n            if (typeof ctxMode === \"string\" && !haveMode) {\n                mode = ctxMode;\n                haveMode = true;\n            }\n        }\n\n        if (!haveCollection || !haveMode) {\n            // ctx format falls back to \"Collection/Mode\"\n            const slash = ctx.lastIndexOf(\"/\");\n            collection = slash >= 0 ? ctx.substring(0, slash) : ctx;\n            mode = slash >= 0 ? ctx.substring(slash + 1) : \"default\";\n        }\n\n        const fname =\n            sanitizeForFile(collection) +\n            \"_mode=\" +\n            sanitizeForFile(mode) +\n            \".tokens.json\";\n        files.push({ name: fname, json: out.json });\n    }\n\n    // Fallback: if no contexts were found, still emit a single file\n    if (files.length === 0) {\n        const fallback = serialize(graph, {\n            styleDictionary: styleDictionary,\n            flatTokens: flatTokens,\n        });\n        files.push({ name: \"tokens.json\", json: fallback.json });\n    }\n\n    return { files: files };\n}\n\nexport { sanitizeForFile };\n", "// src/core/github/api.ts\n// Lightweight GitHub API wrapper tuned for the Figma plugin sandbox.\n// - Wraps fetch with retries and rate-limit awareness\n// - Normalizes payloads so the UI layer stays framework-agnostic\n\n/* =========================\n * Common types & helpers\n * ========================= */\n\nexport interface GhUser {\n    login: string;\n    name?: string;\n}\n\nexport type GhUserResult =\n    | { ok: true; user: GhUser }\n    | { ok: false; error: string };\n\n/** Safe header getter that handles figma's Response polyfill. */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction headerGet(h: any, key: string): string | null {\n    try {\n        if (h && typeof h.get === \"function\") return h.get(key);\n    } catch {\n        /* noop */\n    }\n    return null;\n}\n\nexport interface GhRateInfo {\n    remaining?: number;\n    resetEpochSec?: number;\n}\n\n/** Parse rate limit headers into a tiny struct (when present). */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction parseRate(h: any): GhRateInfo | undefined {\n    const remainingStr = headerGet(h, \"x-ratelimit-remaining\");\n    const resetStr = headerGet(h, \"x-ratelimit-reset\");\n    const rate: GhRateInfo = {};\n    const rem = remainingStr ? parseInt(remainingStr, 10) : NaN;\n    const rst = resetStr ? parseInt(resetStr, 10) : NaN;\n    if (Number.isFinite(rem)) rate.remaining = rem;\n    if (Number.isFinite(rst)) rate.resetEpochSec = rst;\n    return rate.remaining !== undefined || rate.resetEpochSec !== undefined\n        ? rate\n        : undefined;\n}\n\n/** Always resolve `res.text()` without throwing, even inside the sandbox. */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function safeText(res: any): Promise<string> {\n    try {\n        return await res.text();\n    } catch {\n        return \"\";\n    }\n}\n\n/** Base64 encode (Unicode safe) without using Node Buffer. */\nfunction b64(s: string): string {\n    try {\n        // Convert to UTF-8 first so btoa can handle it.\n        // unescape is fine here inside the sandbox and avoids a heavier polyfill.\n        return btoa(unescape(encodeURIComponent(s)));\n    } catch {\n        // Last-ditch fallback: encode bytes manually for btoa.\n        const enc = new TextEncoder();\n        const bytes = enc.encode(s);\n        let bin = \"\";\n        for (let i = 0; i < bytes.length; i++)\n            bin += String.fromCharCode(bytes[i]);\n        return btoa(bin);\n    }\n}\n\n/**\n * Regex to detect invalid characters in GitHub repository path segments.\n * Includes ASCII control characters (\\u0000-\\u001F) which are not allowed in\n * repository paths and could cause security or parsing issues.\n */\n// eslint-disable-next-line no-control-regex -- Intentionally filtering control characters for path security\nconst INVALID_REPO_SEGMENT = /[<>:\"\\\\|?*\\u0000-\\u001F]/;\n\nfunction sanitizeRepoPathInput(\n    path: string\n): { ok: true; path: string } | { ok: false; message: string } {\n    const collapsed = String(path || \"\")\n        .replace(/\\\\/g, \"/\")\n        .replace(/\\/{2,}/g, \"/\")\n        .replace(/^\\/+|\\/+$/g, \"\");\n\n    if (!collapsed) return { ok: true, path: \"\" };\n\n    const segments = collapsed.split(\"/\").filter(Boolean);\n    for (const seg of segments) {\n        if (!seg)\n            return { ok: false, message: \"Path contains an empty segment.\" };\n        if (seg === \".\" || seg === \"..\") {\n            return {\n                ok: false,\n                message: 'Path cannot include \".\" or \"..\" segments.',\n            };\n        }\n        if (INVALID_REPO_SEGMENT.test(seg)) {\n            return {\n                ok: false,\n                message: `Path component \"${seg}\" contains invalid characters.`,\n            };\n        }\n    }\n\n    return { ok: true, path: segments.join(\"/\") };\n}\n\n/** Encode a repo *path* but preserve `/` separators. */\nfunction encodePathSegments(path: string): string {\n    const sanitized = sanitizeRepoPathInput(path);\n    if (!sanitized.ok) throw new Error(sanitized.message);\n    if (!sanitized.path) return \"\";\n    return sanitized.path.split(\"/\").map(encodeURIComponent).join(\"/\");\n}\n\n/** Decode base64 text to UTF-8 while tolerating malformed inputs. */\nfunction decodeBase64ToUtf8(rawInput: string): string {\n    const cleaned = typeof rawInput === \"string\" ? rawInput.trim() : \"\";\n    if (!cleaned) return \"\";\n    const stripWhitespace = cleaned.replace(/\\s+/g, \"\");\n    if (!stripWhitespace) return \"\";\n\n    const decodeBytes = (bytes: Uint8Array): string => {\n        if (typeof TextDecoder !== \"undefined\") {\n            try {\n                return new TextDecoder().decode(bytes);\n            } catch {\n                /* ignore */\n            }\n        }\n        let text = \"\";\n        for (let i = 0; i < bytes.length; i++)\n            text += String.fromCharCode(bytes[i]);\n        try {\n            // escape is fine here; this path only runs in environments lacking TextDecoder\n            return decodeURIComponent(escape(text));\n        } catch {\n            return text;\n        }\n    };\n\n    if (\n        typeof figma !== \"undefined\" &&\n        typeof figma.base64Decode === \"function\"\n    ) {\n        try {\n            return decodeBytes(figma.base64Decode(stripWhitespace));\n        } catch {\n            /* fall through */\n        }\n    }\n\n    if (typeof atob === \"function\") {\n        try {\n            const bin = atob(stripWhitespace);\n            const bytes = new Uint8Array(bin.length);\n            for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);\n            return decodeBytes(bytes);\n        } catch {\n            try {\n                return decodeURIComponent(escape(atob(stripWhitespace)));\n            } catch {\n                /* ignore */\n            }\n        }\n    }\n\n    const maybeBuffer = (\n        globalThis as {\n            Buffer?: {\n                from(\n                    data: string,\n                    encoding: string\n                ): { toString(enc: string): string };\n            };\n        }\n    ).Buffer;\n    if (maybeBuffer && typeof maybeBuffer.from === \"function\") {\n        try {\n            return maybeBuffer.from(stripWhitespace, \"base64\").toString(\"utf8\");\n        } catch {\n            /* ignore */\n        }\n    }\n\n    return \"\";\n}\n\n/* =========================\n * Auth / Repos\n * ========================= */\n\n/** Verify the provided token and return the GitHub user profile. */\nexport async function ghGetUser(token: string): Promise<GhUserResult> {\n    try {\n        const res = await fetch(\"https://api.github.com/user\", {\n            method: \"GET\",\n            headers: {\n                Authorization: `Bearer ${token}`,\n                Accept: \"application/vnd.github+json\",\n                \"X-GitHub-Api-Version\": \"2022-11-28\",\n            },\n        });\n        if (res.status === 401) return { ok: false, error: \"bad credentials\" };\n        if (!res.ok) return { ok: false, error: `HTTP ${res.status}` };\n\n        const data = await res.json();\n        const login = typeof data?.login === \"string\" ? data.login : \"\";\n        const name = typeof data?.name === \"string\" ? data.name : undefined;\n        if (!login) return { ok: false, error: \"response missing login\" };\n        return { ok: true, user: { login, name } };\n    } catch (e) {\n        return { ok: false, error: (e as Error)?.message || \"network error\" };\n    }\n}\n\nexport interface GhRepo {\n    id: number;\n    name: string;\n    full_name: string; // \"owner/repo\"\n    private: boolean;\n    default_branch: string; // e.g., \"main\"\n    owner?: { login?: string };\n    permissions?: { admin?: boolean; push?: boolean; pull?: boolean };\n    fork?: boolean;\n}\n\nexport type GhListReposResult =\n    | { ok: true; repos: GhRepo[] }\n    | { ok: false; error: string };\n\n/** Fetch helper that retries transient failures a couple of times. */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function fetchJsonWithRetry(url: string, init: any, tries = 2) {\n    let last: unknown;\n    for (let i = 0; i < tries; i++) {\n        try {\n            return await fetch(url, init);\n        } catch (e: unknown) {\n            last = e;\n            await new Promise((r) => setTimeout(r, 150));\n        }\n    }\n    throw last;\n}\n\n/** List the user's repositories with pagination and retry handling. */\nexport async function ghListRepos(token: string): Promise<GhListReposResult> {\n    try {\n        const base =\n            \"https://api.github.com/user/repos\" +\n            \"?per_page=100&affiliation=owner,collaborator,organization_member&sort=updated\";\n\n        const headers = {\n            Authorization: `Bearer ${token}`,\n            Accept: \"application/vnd.github+json\",\n            \"X-GitHub-Api-Version\": \"2022-11-28\",\n        };\n\n        const all: GhRepo[] = [];\n        let page = 1;\n\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const res = await fetchJsonWithRetry(\n                `${base}&page=${page}`,\n                { headers },\n                2\n            );\n            if (res.status === 401)\n                return { ok: false, error: \"bad credentials\" };\n            if (!res.ok) {\n                if (all.length) return { ok: true, repos: all };\n                return {\n                    ok: false,\n                    error: (await res.text()) || `HTTP ${res.status}`,\n                };\n            }\n\n            const arr = await res.json();\n            if (!Array.isArray(arr) || arr.length === 0) break;\n\n            for (const r of arr) {\n                if (r?.full_name) {\n                    all.push({\n                        id: r.id,\n                        name: r.name,\n                        full_name: r.full_name,\n                        private: !!r.private,\n                        default_branch: r.default_branch || \"main\",\n                        owner: r.owner,\n                        permissions: r.permissions,\n                        fork: r.fork,\n                    });\n                }\n            }\n\n            if (arr.length < 100) break;\n            page++;\n        }\n\n        return { ok: true, repos: all };\n    } catch (e) {\n        return { ok: false, error: (e as Error)?.message || \"network error\" };\n    }\n}\n\n/* =========================\n * Branches\n * ========================= */\n\nexport type GhListBranchesResult =\n    | {\n          ok: true;\n          owner: string;\n          repo: string;\n          page: number;\n          branches: Array<{ name: string }>;\n          defaultBranch?: string;\n          hasMore: boolean;\n          rate?: GhRateInfo;\n      }\n    | {\n          ok: false;\n          owner: string;\n          repo: string;\n          status: number;\n          message: string;\n          samlRequired?: boolean;\n          rate?: GhRateInfo;\n      };\n\n/** List branches; when `force` add a ts param to bypass caches. */\n/** Fetch branches paginated, returning rate info alongside the data. */\nexport async function ghListBranches(\n    token: string,\n    owner: string,\n    repo: string,\n    page = 1,\n    force = false\n): Promise<GhListBranchesResult> {\n    const baseRepoUrl = `https://api.github.com/repos/${owner}/${repo}`;\n    const headers = {\n        Authorization: `Bearer ${token}`,\n        Accept: \"application/vnd.github+json\",\n        \"X-GitHub-Api-Version\": \"2022-11-28\",\n    } as const;\n\n    const ts = force ? `&_ts=${Date.now()}` : \"\";\n\n    try {\n        const branchesUrl = `${baseRepoUrl}/branches?per_page=100&page=${page}${ts}`;\n        const res = await fetch(branchesUrl, { headers });\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const rate = parseRate((res as any)?.headers);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const saml = headerGet((res as any)?.headers, \"x-github-saml\");\n\n        if (res.status === 403 && saml) {\n            return {\n                ok: false,\n                owner,\n                repo,\n                status: 403,\n                message: \"SAML/SSO required\",\n                samlRequired: true,\n                rate,\n            };\n        }\n\n        if (!res.ok) {\n            const text = await safeText(res);\n            return {\n                ok: false,\n                owner,\n                repo,\n                status: res.status,\n                message: text || `HTTP ${res.status}`,\n                rate,\n            };\n        }\n\n        const arr = await res.json();\n        const branches: Array<{ name: string }> = Array.isArray(arr)\n            ? arr\n                  .filter((b) => b && typeof b.name === \"string\")\n                  .map((b) => ({ name: b.name }))\n            : [];\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const link = headerGet((res as any)?.headers, \"link\");\n        let hasMore = false;\n        if (link && /\\brel=\"next\"/i.test(link)) hasMore = true;\n        else if (branches.length === 100) hasMore = true;\n\n        let defaultBranch: string | undefined;\n        if (page === 1) {\n            try {\n                const repoRes = await fetch(\n                    `${baseRepoUrl}${force ? `?_ts=${Date.now()}` : \"\"}`,\n                    { headers }\n                );\n                if (repoRes.ok) {\n                    const j = await repoRes.json();\n                    if (j && typeof j.default_branch === \"string\")\n                        defaultBranch = j.default_branch;\n                }\n            } catch {\n                /* ignore */\n            }\n        }\n\n        return {\n            ok: true,\n            owner,\n            repo,\n            page,\n            branches,\n            defaultBranch,\n            hasMore,\n            rate,\n        };\n    } catch (e) {\n        return {\n            ok: false,\n            owner,\n            repo,\n            status: 0,\n            message: (e as Error)?.message || \"network error\",\n        };\n    }\n}\n\nexport type GhCreateBranchResult =\n    | {\n          ok: true;\n          owner: string;\n          repo: string;\n          baseBranch: string;\n          newBranch: string;\n          sha: string;\n          html_url: string;\n          rate?: GhRateInfo;\n      }\n    | {\n          ok: false;\n          owner: string;\n          repo: string;\n          baseBranch: string;\n          newBranch: string;\n          status: number;\n          message: string;\n          samlRequired?: boolean;\n          noPushPermission?: boolean;\n          rate?: GhRateInfo;\n      };\n\n/** Create a branch from the chosen base ref when the user requests a fork. */\nexport async function ghCreateBranch(\n    token: string,\n    owner: string,\n    repo: string,\n    newBranch: string,\n    baseBranch: string\n): Promise<GhCreateBranchResult> {\n    const baseRepoUrl = `https://api.github.com/repos/${owner}/${repo}`;\n    const headers = {\n        Authorization: `Bearer ${token}`,\n        Accept: \"application/vnd.github+json\",\n        \"X-GitHub-Api-Version\": \"2022-11-28\",\n    } as const;\n\n    const branchName = String(newBranch || \"\")\n        .trim()\n        .replace(/^refs\\/heads\\//, \"\");\n    const baseName = String(baseBranch || \"\")\n        .trim()\n        .replace(/^refs\\/heads\\//, \"\");\n    if (!branchName || !baseName) {\n        return {\n            ok: false,\n            owner,\n            repo,\n            baseBranch: baseName,\n            newBranch: branchName,\n            status: 400,\n            message: \"empty branch name(s)\",\n        };\n    }\n\n    try {\n        // Preflight: push permission & SAML hints\n        try {\n            const repoRes = await fetch(baseRepoUrl, { headers });\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const rate0 = parseRate((repoRes as any)?.headers);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const saml0 = headerGet((repoRes as any)?.headers, \"x-github-saml\");\n            if (repoRes.status === 403 && saml0) {\n                return {\n                    ok: false,\n                    owner,\n                    repo,\n                    baseBranch: baseName,\n                    newBranch: branchName,\n                    status: 403,\n                    message: \"SAML/SSO required\",\n                    samlRequired: true,\n                    rate: rate0,\n                };\n            }\n            if (!repoRes.ok) {\n                const text = await safeText(repoRes);\n                return {\n                    ok: false,\n                    owner,\n                    repo,\n                    baseBranch: baseName,\n                    newBranch: branchName,\n                    status: repoRes.status,\n                    message: text || `HTTP ${repoRes.status}`,\n                };\n            }\n            const repoJson = await repoRes.json();\n            const pushAllowed = !!repoJson?.permissions?.push;\n            if (repoJson?.permissions && pushAllowed !== true) {\n                return {\n                    ok: false,\n                    owner,\n                    repo,\n                    baseBranch: baseName,\n                    newBranch: branchName,\n                    status: 403,\n                    message:\n                        \"Token/user lacks push permission to this repository\",\n                    noPushPermission: true,\n                    rate: rate0,\n                };\n            }\n        } catch {\n            /* ignore */\n        }\n\n        // Resolve base \u2192 SHA\n        const refUrl = `${baseRepoUrl}/git/ref/heads/${encodeURIComponent(\n            baseName\n        )}`;\n        const refRes = await fetch(refUrl, { headers });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const rate1 = parseRate((refRes as any)?.headers);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const saml1 = headerGet((refRes as any)?.headers, \"x-github-saml\");\n\n        if (refRes.status === 403 && saml1) {\n            return {\n                ok: false,\n                owner,\n                repo,\n                baseBranch: baseName,\n                newBranch: branchName,\n                status: 403,\n                message: \"SAML/SSO required\",\n                samlRequired: true,\n                rate: rate1,\n            };\n        }\n        if (!refRes.ok) {\n            const text = await safeText(refRes);\n            return {\n                ok: false,\n                owner,\n                repo,\n                baseBranch: baseName,\n                newBranch: branchName,\n                status: refRes.status,\n                message: text || `HTTP ${refRes.status}`,\n                rate: rate1,\n            };\n        }\n\n        const refJson = await refRes.json();\n        const sha = (refJson?.object?.sha || refJson?.sha || \"\").trim();\n        if (!sha) {\n            return {\n                ok: false,\n                owner,\n                repo,\n                baseBranch: baseName,\n                newBranch: branchName,\n                status: 500,\n                message: \"could not resolve base SHA\",\n            };\n        }\n\n        // Create ref\n        const createUrl = `${baseRepoUrl}/git/refs`;\n        const body = JSON.stringify({ ref: `refs/heads/${branchName}`, sha });\n        const createRes = await fetch(createUrl, {\n            method: \"POST\",\n            headers,\n            body,\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const rate2 = parseRate((createRes as any)?.headers);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const saml2 = headerGet((createRes as any)?.headers, \"x-github-saml\");\n\n        if (createRes.status === 403 && saml2) {\n            return {\n                ok: false,\n                owner,\n                repo,\n                baseBranch: baseName,\n                newBranch: branchName,\n                status: 403,\n                message: \"SAML/SSO required\",\n                samlRequired: true,\n                rate: rate2,\n            };\n        }\n        if (!createRes.ok) {\n            const text = await safeText(createRes);\n            return {\n                ok: false,\n                owner,\n                repo,\n                baseBranch: baseName,\n                newBranch: branchName,\n                status: createRes.status,\n                message: text || `HTTP ${createRes.status}`,\n                rate: rate2,\n            };\n        }\n\n        const html_url = `https://github.com/${owner}/${repo}/tree/${encodeURIComponent(\n            branchName\n        )}`;\n        return {\n            ok: true,\n            owner,\n            repo,\n            baseBranch: baseName,\n            newBranch: branchName,\n            sha,\n            html_url,\n            rate: rate2,\n        };\n    } catch (e) {\n        return {\n            ok: false,\n            owner,\n            repo,\n            baseBranch: baseName,\n            newBranch: branchName,\n            status: 0,\n            message: (e as Error)?.message || \"network error\",\n        };\n    }\n}\n\n/* =========================\n * Contents API: list & ensure folder\n * ========================= */\n\nexport type GhDirEntry = {\n    type: \"dir\" | \"file\";\n    name: string;\n    path: string;\n};\n\nexport type GhListDirResult =\n    | {\n          ok: true;\n          owner: string;\n          repo: string;\n          ref: string;\n          path: string;\n          entries: GhDirEntry[];\n          rate?: GhRateInfo;\n      }\n    | {\n          ok: false;\n          owner: string;\n          repo: string;\n          ref: string;\n          path: string;\n          status: number;\n          message: string;\n          rate?: GhRateInfo;\n      };\n\n/** GET /repos/{owner}/{repo}/contents/{path}?ref={ref} */\n/** List a single directory in a repo, returning both dir and file entries. */\nexport async function ghListDir(\n    token: string,\n    owner: string,\n    repo: string,\n    path: string,\n    ref: string\n): Promise<GhListDirResult> {\n    const baseRepoUrl = `https://api.github.com/repos/${owner}/${repo}`;\n    const sanitized = sanitizeRepoPathInput(path);\n    if (!sanitized.ok) {\n        return {\n            ok: false,\n            owner,\n            repo,\n            ref,\n            path: String(path || \"\").replace(/^\\/+|\\/+$/g, \"\"),\n            status: 400,\n            message: sanitized.message,\n        };\n    }\n    const rel = sanitized.path\n        ? sanitized.path.split(\"/\").map(encodeURIComponent).join(\"/\")\n        : \"\";\n    const canonicalPath = sanitized.path;\n    const url = rel\n        ? `${baseRepoUrl}/contents/${rel}?ref=${encodeURIComponent(\n              ref\n          )}&_ts=${Date.now()}`\n        : `${baseRepoUrl}/contents?ref=${encodeURIComponent(\n              ref\n          )}&_ts=${Date.now()}`;\n    const headers = {\n        Authorization: `Bearer ${token}`,\n        Accept: \"application/vnd.github+json\",\n        \"X-GitHub-Api-Version\": \"2022-11-28\",\n    } as const;\n\n    try {\n        const res = await fetch(url, { headers });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const rate = parseRate((res as any)?.headers);\n        if (!res.ok) {\n            const msg = await safeText(res);\n            return {\n                ok: false,\n                owner,\n                repo,\n                ref,\n                path: canonicalPath,\n                status: res.status,\n                message: msg || `HTTP ${res.status}`,\n                rate,\n            };\n        }\n        const json = await res.json();\n        if (!Array.isArray(json)) {\n            const type = typeof json?.type === \"string\" ? json.type : \"\";\n            const status = type === \"file\" ? 409 : 400;\n            const message =\n                type === \"file\"\n                    ? \"GitHub: Path is a file, not a folder.\"\n                    : \"GitHub: Unable to list path as a folder.\";\n            return {\n                ok: false,\n                owner,\n                repo,\n                ref,\n                path: canonicalPath,\n                status,\n                message,\n                rate,\n            };\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const entries: GhDirEntry[] = json.map((it: any) => ({\n            type: it?.type === \"dir\" ? \"dir\" : \"file\",\n            name: String(it?.name || \"\"),\n            path: String(it?.path || \"\"),\n        }));\n        return {\n            ok: true,\n            owner,\n            repo,\n            ref,\n            path: canonicalPath,\n            entries,\n            rate,\n        };\n    } catch (e) {\n        return {\n            ok: false,\n            owner,\n            repo,\n            ref,\n            path: canonicalPath,\n            status: 0,\n            message: (e as Error)?.message || \"network error\",\n        };\n    }\n}\n\n/** Wrapper that returns ONLY directories (keeps a legacy `dirs` array). */\nexport type GhListDirsResult =\n    | {\n          ok: true;\n          owner: string;\n          repo: string;\n          branch: string;\n          path: string;\n          entries: GhDirEntry[]; // dirs only\n          dirs: Array<{ name: string; path: string }>;\n          rate?: GhRateInfo;\n      }\n    | {\n          ok: false;\n          owner: string;\n          repo: string;\n          branch: string;\n          path: string;\n          status: number;\n          message: string;\n          samlRequired?: boolean;\n          rate?: GhRateInfo;\n      };\n\n/** Walk paginated folder listings and stream results back to the caller. */\nexport async function ghListDirs(\n    token: string,\n    owner: string,\n    repo: string,\n    branch: string,\n    path = \"\"\n): Promise<GhListDirsResult> {\n    const res = await ghListDir(token, owner, repo, path, branch);\n    if (!res.ok) {\n        return {\n            ok: false,\n            owner,\n            repo,\n            branch,\n            path: res.path,\n            status: res.status,\n            message: res.message,\n            samlRequired:\n                /SAML|SSO/i.test(res.message || \"\") || res.status === 403,\n        };\n    }\n    const onlyDirs = res.entries.filter((e) => e.type === \"dir\");\n    return {\n        ok: true,\n        owner,\n        repo,\n        branch,\n        path: res.path,\n        entries: onlyDirs,\n        dirs: onlyDirs.map((d) => ({ name: d.name, path: d.path })),\n        rate: res.rate,\n    };\n}\n\n/* ---------- Ensure folder (materialize if empty) ---------- */\n\nexport type GhEnsureFolderResult =\n    | {\n          ok: true;\n          owner: string;\n          repo: string;\n          branch: string;\n          folderPath: string; // normalized\n          created: boolean; // true if a placeholder commit was needed\n          fileSha?: string;\n          html_url?: string;\n          rate?: GhRateInfo;\n      }\n    | {\n          ok: false;\n          owner: string;\n          repo: string;\n          branch: string;\n          folderPath: string;\n          status: number;\n          message: string;\n          samlRequired?: boolean;\n          noPushPermission?: boolean;\n          rate?: GhRateInfo;\n      };\n\n/** Create nested folders by committing empty `.keep` blobs as needed. */\nexport async function ghEnsureFolder(\n    token: string,\n    owner: string,\n    repo: string,\n    branch: string,\n    folderPath: string\n): Promise<GhEnsureFolderResult> {\n    const baseRepoUrl = `https://api.github.com/repos/${owner}/${repo}`;\n    const headers = {\n        Authorization: `Bearer ${token}`,\n        Accept: \"application/vnd.github+json\",\n        \"X-GitHub-Api-Version\": \"2022-11-28\",\n    } as const;\n\n    const sanitized = sanitizeRepoPathInput(folderPath);\n    if (!sanitized.ok) {\n        return {\n            ok: false,\n            owner,\n            repo,\n            branch,\n            folderPath: \"\",\n            status: 400,\n            message: sanitized.message,\n        };\n    }\n    const norm = sanitized.path;\n    if (!norm) {\n        return {\n            ok: false,\n            owner,\n            repo,\n            branch,\n            folderPath: norm,\n            status: 400,\n            message: \"empty folder path\",\n        };\n    }\n\n    try {\n        // Exists already?\n        {\n            const rel = encodePathSegments(norm);\n            const url = `${baseRepoUrl}/contents/${rel}?ref=${encodeURIComponent(\n                branch\n            )}&_ts=${Date.now()}`;\n            const res = await fetch(url, { headers });\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const rate = parseRate((res as any)?.headers);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const saml = headerGet((res as any)?.headers, \"x-github-saml\");\n\n            if (res.status === 403 && saml) {\n                return {\n                    ok: false,\n                    owner,\n                    repo,\n                    branch,\n                    folderPath: norm,\n                    status: 403,\n                    message: \"SAML/SSO required\",\n                    samlRequired: true,\n                    rate,\n                };\n            }\n\n            if (res.ok) {\n                return {\n                    ok: true,\n                    owner,\n                    repo,\n                    branch,\n                    folderPath: norm,\n                    created: false,\n                    html_url: `https://github.com/${owner}/${repo}/tree/${encodeURIComponent(\n                        branch\n                    )}/${encodePathSegments(norm)}`,\n                    rate,\n                };\n            }\n            if (res.status !== 404) {\n                const text = await safeText(res);\n                return {\n                    ok: false,\n                    owner,\n                    repo,\n                    branch,\n                    folderPath: norm,\n                    status: res.status,\n                    message: text || `HTTP ${res.status}`,\n                    rate,\n                };\n            }\n        }\n\n        // Materialize with .gitkeep\n        const placeholderRel = `${norm}/.gitkeep`;\n        const putUrl = `${baseRepoUrl}/contents/${encodePathSegments(\n            placeholderRel\n        )}`;\n        const body = JSON.stringify({\n            message: `chore: create folder ${norm}`,\n            content: b64(\".\"),\n            branch,\n        });\n\n        const putRes = await fetch(putUrl, { method: \"PUT\", headers, body });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const rate2 = parseRate((putRes as any)?.headers);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const saml2 = headerGet((putRes as any)?.headers, \"x-github-saml\");\n\n        if (putRes.status === 403 && saml2) {\n            return {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                folderPath: norm,\n                status: 403,\n                message: \"SAML/SSO required\",\n                samlRequired: true,\n                rate: rate2,\n            };\n        }\n        if (!putRes.ok) {\n            const text = await safeText(putRes);\n            return {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                folderPath: norm,\n                status: putRes.status,\n                message: text || `HTTP ${putRes.status}`,\n                rate: rate2,\n            };\n        }\n\n        const j = await putRes.json();\n        const fileSha = j?.content?.sha || j?.commit?.sha || \"\";\n\n        return {\n            ok: true,\n            owner,\n            repo,\n            branch,\n            folderPath: norm,\n            created: true,\n            fileSha,\n            html_url: `https://github.com/${owner}/${repo}/tree/${encodeURIComponent(\n                branch\n            )}/${encodePathSegments(norm)}`,\n            rate: rate2,\n        };\n    } catch (e) {\n        return {\n            ok: false,\n            owner,\n            repo,\n            branch,\n            folderPath: norm,\n            status: 0,\n            message: (e as Error)?.message || \"network error\",\n        };\n    }\n}\n\n// ---------- Single-commit file writer (Git Data API) ----------\n\nexport type GhCommitFile = {\n    path: string; // e.g., \"tokens/My File.json\" (may include subfolders)\n    content: string; // file contents as UTF-8 text (we use blobs with encoding: 'utf-8')\n    mode?: \"100644\"; // normal file; left optional\n};\n\nexport type GhCommitFilesResult =\n    | {\n          ok: true;\n          owner: string;\n          repo: string;\n          branch: string;\n          commitSha: string;\n          commitUrl: string; // https://github.com/{owner}/{repo}/commit/{sha}\n          treeUrl?: string;\n          rate?: GhRateInfo;\n      }\n    | {\n          ok: false;\n          owner: string;\n          repo: string;\n          branch: string;\n          status: number;\n          message: string;\n          rate?: GhRateInfo;\n      };\n\n/**\n * Writes one or more files to a repo as a single commit on a branch.\n * Uses Git Data API: blobs \u2192 tree \u2192 commit \u2192 update ref.\n * No extra commits to \"create folders\"; tree paths handle that.\n */\n/** Create or update a commit containing the provided files on the target branch. */\nexport async function ghCommitFiles(\n    token: string,\n    owner: string,\n    repo: string,\n    branch: string,\n    message: string,\n    files: GhCommitFile[]\n): Promise<GhCommitFilesResult> {\n    const base = `https://api.github.com/repos/${owner}/${repo}`;\n    const headers = {\n        Authorization: `Bearer ${token}`,\n        Accept: \"application/vnd.github+json\",\n        \"X-GitHub-Api-Version\": \"2022-11-28\",\n    } as const;\n\n    function normPath(p: string): string {\n        const sanitized = sanitizeRepoPathInput(p);\n        if (!sanitized.ok) throw new Error(sanitized.message);\n        return sanitized.path;\n    }\n\n    const cleaned: GhCommitFile[] = [];\n    for (let i = 0; i < files.length; i++) {\n        const src = files[i];\n        let normalizedPath: string;\n        try {\n            normalizedPath = normPath(src.path);\n        } catch (err) {\n            return {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                status: 400,\n                message: (err as Error)?.message || \"invalid path\",\n            };\n        }\n        if (!normalizedPath) continue;\n        if (typeof src.content !== \"string\") continue;\n        cleaned.push({\n            path: normalizedPath,\n            content: src.content,\n            mode: src.mode || \"100644\",\n        });\n    }\n\n    if (cleaned.length === 0) {\n        return {\n            ok: false,\n            owner,\n            repo,\n            branch,\n            status: 400,\n            message: \"no files to commit\",\n        };\n    }\n\n    try {\n        // 1) Resolve branch \u2192 commit SHA\n        const cacheBust = `_ts=${Date.now()}`;\n        const refRes = await fetch(\n            `${base}/git/ref/heads/${encodeURIComponent(branch)}?${cacheBust}`,\n            { headers }\n        );\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const rate1 = parseRate((refRes as any)?.headers);\n        if (!refRes.ok) {\n            const text = await safeText(refRes);\n            return {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                status: refRes.status,\n                message: text || `HTTP ${refRes.status}`,\n                rate: rate1,\n            };\n        }\n        const refJson = await refRes.json();\n        const baseCommitSha: string = (\n            refJson?.object?.sha ||\n            refJson?.sha ||\n            \"\"\n        ).trim();\n        if (!baseCommitSha) {\n            return {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                status: 500,\n                message: \"could not resolve branch commit sha\",\n                rate: rate1,\n            };\n        }\n\n        // 2) Resolve base commit \u2192 tree SHA\n        const commitRes = await fetch(\n            `${base}/git/commits/${baseCommitSha}?${cacheBust}`,\n            { headers }\n        );\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const rate2 = parseRate((commitRes as any)?.headers);\n        if (!commitRes.ok) {\n            const text = await safeText(commitRes);\n            return {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                status: commitRes.status,\n                message: text || `HTTP ${commitRes.status}`,\n                rate: rate2,\n            };\n        }\n        const commitJson = await commitRes.json();\n        const baseTreeSha: string = (commitJson?.tree?.sha || \"\").trim();\n        if (!baseTreeSha) {\n            return {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                status: 500,\n                message: \"could not resolve base tree sha\",\n                rate: rate2,\n            };\n        }\n\n        // 3) Create blobs for each file\n        const blobShas: string[] = [];\n        for (let i = 0; i < cleaned.length; i++) {\n            const blobRes = await fetch(`${base}/git/blobs`, {\n                method: \"POST\",\n                headers,\n                body: JSON.stringify({\n                    content: cleaned[i].content,\n                    encoding: \"utf-8\",\n                }),\n            });\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const rateB = parseRate((blobRes as any)?.headers);\n            if (!blobRes.ok) {\n                const text = await safeText(blobRes);\n                return {\n                    ok: false,\n                    owner,\n                    repo,\n                    branch,\n                    status: blobRes.status,\n                    message: text || `HTTP ${blobRes.status}`,\n                    rate: rateB,\n                };\n            }\n            const blobJson = await blobRes.json();\n            const blobSha: string = (blobJson?.sha || \"\").trim();\n            if (!blobSha) {\n                return {\n                    ok: false,\n                    owner,\n                    repo,\n                    branch,\n                    status: 500,\n                    message: \"failed to create blob sha\",\n                };\n            }\n            blobShas.push(blobSha);\n        }\n\n        // 4) Create a new tree using those blobs at the desired paths\n        const treeEntries = cleaned.map((f, idx) => ({\n            path: f.path,\n            type: \"blob\",\n            mode: f.mode!,\n            sha: blobShas[idx],\n        }));\n        const treeRes = await fetch(`${base}/git/trees`, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify({ base_tree: baseTreeSha, tree: treeEntries }),\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const rate3 = parseRate((treeRes as any)?.headers);\n        if (!treeRes.ok) {\n            const text = await safeText(treeRes);\n            return {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                status: treeRes.status,\n                message: text || `HTTP ${treeRes.status}`,\n                rate: rate3,\n            };\n        }\n        const treeJson = await treeRes.json();\n        const newTreeSha: string = (treeJson?.sha || \"\").trim();\n        if (!newTreeSha) {\n            return {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                status: 500,\n                message: \"failed to create tree sha\",\n            };\n        }\n\n        // 5) Create a commit with that tree and parent = current branch commit\n        const commitCreateRes = await fetch(`${base}/git/commits`, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify({\n                message,\n                tree: newTreeSha,\n                parents: [baseCommitSha],\n            }),\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const rate4 = parseRate((commitCreateRes as any)?.headers);\n        if (!commitCreateRes.ok) {\n            const text = await safeText(commitCreateRes);\n            return {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                status: commitCreateRes.status,\n                message: text || `HTTP ${commitCreateRes.status}`,\n                rate: rate4,\n            };\n        }\n        const newCommit = await commitCreateRes.json();\n        const newCommitSha: string = (newCommit?.sha || \"\").trim();\n        if (!newCommitSha) {\n            return {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                status: 500,\n                message: \"failed to create commit sha\",\n            };\n        }\n\n        // 6) Fast-forward the branch to the new commit\n        const updateRefRes = await fetch(\n            `${base}/git/refs/heads/${encodeURIComponent(branch)}`,\n            {\n                method: \"PATCH\",\n                headers,\n                body: JSON.stringify({ sha: newCommitSha, force: false }),\n            }\n        );\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const rate5 = parseRate((updateRefRes as any)?.headers);\n        if (!updateRefRes.ok) {\n            const text = await safeText(updateRefRes);\n            return {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                status: updateRefRes.status,\n                message: text || `HTTP ${updateRefRes.status}`,\n                rate: rate5,\n            };\n        }\n\n        return {\n            ok: true,\n            owner,\n            repo,\n            branch,\n            commitSha: newCommitSha,\n            commitUrl: `https://github.com/${owner}/${repo}/commit/${newCommitSha}`,\n            treeUrl: `https://github.com/${owner}/${repo}/tree/${encodeURIComponent(\n                branch\n            )}`,\n            rate: rate5,\n        };\n    } catch (e) {\n        return {\n            ok: false,\n            owner,\n            repo,\n            branch,\n            status: 0,\n            message: (e as Error)?.message || \"network error\",\n        };\n    }\n}\n\n/* =========================\n * File contents\n * ========================= */\n\nexport type GhGetFileContentsResult =\n    | {\n          ok: true;\n          owner: string;\n          repo: string;\n          branch: string;\n          path: string;\n          sha: string;\n          size?: number;\n          contentText: string;\n          encoding: string;\n          rate?: GhRateInfo;\n      }\n    | {\n          ok: false;\n          owner: string;\n          repo: string;\n          branch: string;\n          path: string;\n          status: number;\n          message: string;\n          rate?: GhRateInfo;\n          isDirectory?: boolean;\n          samlRequired?: boolean;\n      };\n\n/** Fetch a file and decode it to UTF-8 so previews can render cleanly. */\nexport async function ghGetFileContents(\n    token: string,\n    owner: string,\n    repo: string,\n    branch: string,\n    path: string\n): Promise<GhGetFileContentsResult> {\n    const sanitized = sanitizeRepoPathInput(path);\n    if (!sanitized.ok) {\n        return {\n            ok: false,\n            owner,\n            repo,\n            branch,\n            path: \"\",\n            status: 400,\n            message: sanitized.message,\n        };\n    }\n    if (!sanitized.path) {\n        return {\n            ok: false,\n            owner,\n            repo,\n            branch,\n            path: \"\",\n            status: 400,\n            message: \"Empty path\",\n        };\n    }\n    const cleanPath = sanitized.path;\n    const base = `https://api.github.com/repos/${owner}/${repo}/contents/${cleanPath\n        .split(\"/\")\n        .map(encodeURIComponent)\n        .join(\"/\")}`;\n    const url = `${base}?ref=${encodeURIComponent(branch)}`;\n    const headers = {\n        Authorization: `Bearer ${token}`,\n        Accept: \"application/vnd.github+json\",\n        \"X-GitHub-Api-Version\": \"2022-11-28\",\n    } as const;\n\n    try {\n        const res = await fetch(url, { headers });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const rate = parseRate((res as any)?.headers);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const saml = headerGet((res as any)?.headers, \"x-github-saml\");\n\n        if (res.status === 403 && saml) {\n            return {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                path: cleanPath,\n                status: 403,\n                message: \"SAML/SSO required\",\n                samlRequired: true,\n                rate,\n            };\n        }\n\n        if (!res.ok) {\n            const text = await safeText(res);\n            return {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                path: cleanPath,\n                status: res.status,\n                message: text || `HTTP ${res.status}`,\n                rate,\n            };\n        }\n\n        const json = await res.json();\n        if (Array.isArray(json)) {\n            return {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                path: cleanPath,\n                status: 409,\n                message: \"Path refers to a directory. Provide a file path.\",\n                rate,\n                isDirectory: true,\n            };\n        }\n\n        const encoding =\n            typeof json?.encoding === \"string\" ? json.encoding : \"\";\n        const content = typeof json?.content === \"string\" ? json.content : \"\";\n        const sha = typeof json?.sha === \"string\" ? json.sha : \"\";\n        const size = typeof json?.size === \"number\" ? json.size : undefined;\n\n        if (!content) {\n            return {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                path: cleanPath,\n                status: 422,\n                message: \"File had no content\",\n                rate,\n            };\n        }\n\n        let text = content;\n        if (encoding === \"base64\") {\n            text = decodeBase64ToUtf8(content.replace(/\\s+/g, \"\"));\n        }\n\n        return {\n            ok: true,\n            owner,\n            repo,\n            branch,\n            path: cleanPath,\n            sha,\n            size,\n            contentText: text,\n            encoding,\n            rate,\n        };\n    } catch (e) {\n        return {\n            ok: false,\n            owner,\n            repo,\n            branch,\n            path: cleanPath,\n            status: 0,\n            message: (e as Error)?.message || \"network error\",\n        };\n    }\n}\n\n/* =========================\n * Pull requests\n * ========================= */\n\nexport type GhCreatePullRequestResult =\n    | {\n          ok: true;\n          owner: string;\n          repo: string;\n          base: string;\n          head: string;\n          number: number;\n          url: string;\n          rate?: GhRateInfo;\n          alreadyExists?: false;\n      }\n    | {\n          ok: false;\n          owner: string;\n          repo: string;\n          base: string;\n          head: string;\n          status: number;\n          message: string;\n          rate?: GhRateInfo;\n          alreadyExists?: boolean;\n          samlRequired?: boolean;\n      };\n\n/** Create a draft or regular pull request against the selected repository. */\nexport async function ghCreatePullRequest(\n    token: string,\n    owner: string,\n    repo: string,\n    params: { title: string; head: string; base: string; body?: string }\n): Promise<GhCreatePullRequestResult> {\n    const url = `https://api.github.com/repos/${owner}/${repo}/pulls`;\n    const headers = {\n        Authorization: `Bearer ${token}`,\n        Accept: \"application/vnd.github+json\",\n        \"X-GitHub-Api-Version\": \"2022-11-28\",\n    } as const;\n\n    const title = String(params.title || \"\").trim();\n    const head = String(params.head || \"\").trim();\n    const base = String(params.base || \"\").trim();\n    const body =\n        typeof params.body === \"string\" && params.body.length\n            ? params.body\n            : undefined;\n\n    if (!title || !head || !base) {\n        return {\n            ok: false,\n            owner,\n            repo,\n            base,\n            head,\n            status: 400,\n            message: \"missing PR parameters\",\n        };\n    }\n\n    try {\n        const res = await fetch(url, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify({ title, head, base, body }),\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const rate = parseRate((res as any)?.headers);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const saml = headerGet((res as any)?.headers, \"x-github-saml\");\n\n        if (res.status === 403 && saml) {\n            return {\n                ok: false,\n                owner,\n                repo,\n                base,\n                head,\n                status: 403,\n                message: \"SAML/SSO required\",\n                samlRequired: true,\n                rate,\n            };\n        }\n\n        if (!res.ok) {\n            const text = await safeText(res);\n            const msg = text || `HTTP ${res.status}`;\n            const already = res.status === 422 && /already exists/i.test(msg);\n            return {\n                ok: false,\n                owner,\n                repo,\n                base,\n                head,\n                status: res.status,\n                message: msg,\n                rate,\n                alreadyExists: already,\n            };\n        }\n\n        const json = await res.json();\n        const number = typeof json?.number === \"number\" ? json.number : 0;\n        const prUrl = typeof json?.html_url === \"string\" ? json.html_url : \"\";\n\n        if (!number || !prUrl) {\n            return {\n                ok: false,\n                owner,\n                repo,\n                base,\n                head,\n                status: 500,\n                message: \"invalid PR response\",\n                rate,\n            };\n        }\n\n        return { ok: true, owner, repo, base, head, number, url: prUrl, rate };\n    } catch (e) {\n        return {\n            ok: false,\n            owner,\n            repo,\n            base,\n            head,\n            status: 0,\n            message: (e as Error)?.message || \"network error\",\n        };\n    }\n}\n", "// src/app/github/folders.ts\n// Shared helpers for normalizing GitHub folder inputs.\n\n/**\n * Regex to detect invalid characters in GitHub folder path segments.\n * Includes ASCII control characters (\\u0000-\\u001F) which are not allowed in\n * folder paths and could cause filesystem or security issues.\n */\n// eslint-disable-next-line no-control-regex -- Intentionally filtering control characters for path safety\nconst INVALID_FOLDER_SEGMENT = /[<>:\"\\\\|?*\\u0000-\\u001F]/;\n\ntype FolderNormalization =\n    | { ok: true; storage: string }\n    | { ok: false; message: string };\n\ntype FolderCommitPath =\n    | { ok: true; path: string }\n    | { ok: false; message: string };\n\nfunction validateFolderSegments(segments: string[]): string | null {\n    for (let i = 0; i < segments.length; i++) {\n        const seg = segments[i];\n        if (!seg) return \"GitHub: Folder path has an empty segment.\";\n        if (seg === \".\" || seg === \"..\") {\n            return 'GitHub: Folder path cannot include \".\" or \"..\" segments.';\n        }\n        if (INVALID_FOLDER_SEGMENT.test(seg)) {\n            return `GitHub: Folder segment \"${seg}\" contains invalid characters.`;\n        }\n    }\n    return null;\n}\n\nexport function normalizeFolderForStorage(raw: string): FolderNormalization {\n    const trimmed = (raw ?? \"\").trim();\n    if (!trimmed) return { ok: true, storage: \"\" };\n    if (trimmed === \"/\" || trimmed === \"./\" || trimmed === \".\")\n        return { ok: true, storage: \"/\" };\n\n    const collapsed = trimmed.replace(/\\\\/g, \"/\").replace(/\\/{2,}/g, \"/\");\n    const stripped = collapsed.replace(/^\\/+/, \"\").replace(/\\/+$/, \"\");\n    if (!stripped) return { ok: true, storage: \"/\" };\n\n    const segments = stripped.split(\"/\").filter(Boolean);\n    const err = validateFolderSegments(segments);\n    if (err) return { ok: false, message: err };\n    return { ok: true, storage: segments.join(\"/\") };\n}\n\nexport function folderStorageToCommitPath(stored: string): FolderCommitPath {\n    if (!stored) return { ok: true, path: \"\" };\n    if (stored === \"/\" || stored === \"./\" || stored === \".\")\n        return { ok: true, path: \"\" };\n\n    const collapsed = stored.replace(/\\\\/g, \"/\").replace(/\\/{2,}/g, \"/\");\n    const stripped = collapsed.replace(/^\\/+/, \"\").replace(/\\/+$/, \"\");\n    if (!stripped) return { ok: true, path: \"\" };\n\n    const segments = stripped.split(\"/\").filter(Boolean);\n    const err = validateFolderSegments(segments);\n    if (err) return { ok: false, message: err };\n    return { ok: true, path: segments.join(\"/\") };\n}\n", "import type { DispatcherContext, GhSelected } from \"./types\";\nimport { normalizeFolderForStorage } from \"../folders\";\nimport type { GithubScope } from \"../../messages\";\n\nconst GH_SELECTED_KEY = \"gh.selected\";\nconst GH_LAST_COMMIT_KEY = \"gh.lastCommitSignature\";\n\nexport async function getSelected(): Promise<GhSelected> {\n    try {\n        return (await figma.clientStorage.getAsync(GH_SELECTED_KEY)) ?? {};\n    } catch {\n        return {};\n    }\n}\n\nexport async function setSelected(sel: GhSelected): Promise<void> {\n    try {\n        await figma.clientStorage.setAsync(GH_SELECTED_KEY, sel);\n    } catch {\n        /* ignore */\n    }\n}\n\nexport async function mergeSelected(\n    partial: Partial<GhSelected>\n): Promise<GhSelected> {\n    const current = await getSelected();\n    const merged = { ...current, ...partial };\n    await setSelected(merged);\n    return merged;\n}\n\nexport type CommitSignature = {\n    branch: string;\n    fullPath: string;\n    scope: GithubScope;\n};\n\nexport async function getLastCommitSignature(): Promise<CommitSignature | null> {\n    try {\n        const stored = await figma.clientStorage.getAsync(GH_LAST_COMMIT_KEY);\n        if (\n            stored &&\n            typeof stored === \"object\" &&\n            typeof (stored as { branch?: unknown }).branch === \"string\" &&\n            typeof (stored as { fullPath?: unknown }).fullPath === \"string\"\n        ) {\n            return {\n                branch: (stored as { branch: string }).branch,\n                fullPath: (stored as { fullPath: string }).fullPath,\n                scope:\n                    typeof (stored as { scope?: unknown }).scope === \"string\" &&\n                    ((stored as { scope?: unknown }).scope === \"all\" ||\n                        (stored as { scope?: unknown }).scope === \"selected\" ||\n                        (stored as { scope?: unknown }).scope === \"typography\")\n                        ? ((stored as { scope: GithubScope })\n                              .scope as GithubScope)\n                        : \"selected\",\n            };\n        }\n    } catch {\n        /* ignore */\n    }\n    return null;\n}\n\nexport async function setLastCommitSignature(\n    sig: CommitSignature\n): Promise<void> {\n    try {\n        await figma.clientStorage.setAsync(GH_LAST_COMMIT_KEY, sig);\n    } catch {\n        /* ignore */\n    }\n}\n\nexport async function handleSaveState(\n    ctx: DispatcherContext,\n    payload: any\n): Promise<void> {\n    const update: Partial<GhSelected> = {};\n    if (typeof payload.owner === \"string\") update.owner = payload.owner;\n    if (typeof payload.repo === \"string\") update.repo = payload.repo;\n    if (typeof payload.branch === \"string\") update.branch = payload.branch;\n    if (typeof payload.folder === \"string\") {\n        const folderResult = normalizeFolderForStorage(payload.folder);\n        if (folderResult.ok) update.folder = folderResult.storage;\n        else\n            ctx.deps.send({\n                type: \"ERROR\",\n                payload: { message: folderResult.message },\n            });\n    }\n    if (typeof payload.filename === \"string\")\n        update.filename = payload.filename.trim();\n    if (typeof payload.commitMessage === \"string\")\n        update.commitMessage = payload.commitMessage;\n    if (\n        payload.scope === \"all\" ||\n        payload.scope === \"selected\" ||\n        payload.scope === \"typography\"\n    ) {\n        update.scope = payload.scope;\n    }\n    if (typeof payload.collection === \"string\")\n        update.collection = payload.collection;\n    if (typeof payload.mode === \"string\") update.mode = payload.mode;\n    if (typeof payload.styleDictionary === \"boolean\")\n        update.styleDictionary = payload.styleDictionary;\n    if (typeof payload.flatTokens === \"boolean\")\n        update.flatTokens = payload.flatTokens;\n    if (typeof payload.createPr === \"boolean\")\n        update.createPr = payload.createPr;\n    if (typeof payload.prBase === \"string\") update.prBase = payload.prBase;\n    if (typeof payload.prTitle === \"string\") update.prTitle = payload.prTitle;\n    if (typeof payload.prBody === \"string\") update.prBody = payload.prBody;\n    await mergeSelected(update);\n}\n", "import { ghListRepos } from \"../../../core/github/api\";\nimport type { DispatcherContext } from \"./types\";\nimport { getSelected, setSelected } from \"./state\";\n\nfunction sleep(ms: number) {\n    return new Promise<void>((resolve) => setTimeout(resolve, ms));\n}\n\nexport async function listAndSendRepos(\n    ctx: DispatcherContext,\n    token: string\n): Promise<void> {\n    await sleep(75);\n    let repos = await ghListRepos(token);\n    if (!repos.ok && /Failed to fetch|network error/i.test(repos.error || \"\")) {\n        await sleep(200);\n        repos = await ghListRepos(token);\n    }\n    if (repos.ok) {\n        const minimal = repos.repos.map((r) => ({\n            full_name: r.full_name,\n            default_branch: r.default_branch,\n            private: !!r.private,\n        }));\n        ctx.deps.send({ type: \"GITHUB_REPOS\", payload: { repos: minimal } });\n    } else {\n        ctx.deps.send({\n            type: \"ERROR\",\n            payload: {\n                message: `GitHub: Could not list repos: ${repos.error}`,\n            },\n        });\n        ctx.deps.send({ type: \"GITHUB_REPOS\", payload: { repos: [] } });\n    }\n}\n\nexport async function handleSelectRepo(\n    ctx: DispatcherContext,\n    payload: any\n): Promise<void> {\n    const sel = await getSelected();\n    await setSelected({\n        owner: payload.owner,\n        repo: payload.repo,\n        branch: sel.branch,\n        folder: undefined,\n        filename: sel.filename,\n        commitMessage: sel.commitMessage,\n        scope: sel.scope,\n        collection: sel.collection,\n        mode: sel.mode,\n        createPr: sel.createPr,\n        prBase: sel.prBase,\n        prTitle: sel.prTitle,\n        prBody: sel.prBody,\n    });\n}\n", "import { ghGetUser } from \"../../../core/github/api\";\nimport type { DispatcherContext } from \"./types\";\nimport { listAndSendRepos } from \"./repos\";\n\nfunction encodeToken(s: string): string {\n    try {\n        return btoa(s);\n    } catch {\n        return s;\n    }\n}\n\nfunction decodeToken(s: string): string {\n    try {\n        return atob(s);\n    } catch {\n        return s;\n    }\n}\n\nexport async function restoreGithubTokenAndVerify(\n    ctx: DispatcherContext\n): Promise<void> {\n    try {\n        const rememberPrefStored = await figma.clientStorage\n            .getAsync(\"githubRememberPref\")\n            .catch(() => null);\n        const rememberPref =\n            typeof rememberPrefStored === \"boolean\" ? rememberPrefStored : true;\n        if (!rememberPref) {\n            await figma.clientStorage\n                .deleteAsync(\"github_token_b64\")\n                .catch(() => {});\n            return;\n        }\n\n        const stored = await figma.clientStorage\n            .getAsync(\"github_token_b64\")\n            .catch(() => null);\n        if (!stored || typeof stored !== \"string\" || stored.length === 0)\n            return;\n\n        const decoded = decodeToken(stored);\n        ctx.state.token = decoded;\n\n        const who = await ghGetUser(decoded);\n        if (who.ok) {\n            ctx.deps.send({\n                type: \"GITHUB_AUTH_RESULT\",\n                payload: {\n                    ok: true,\n                    login: who.user.login,\n                    name: who.user.name,\n                    remember: true,\n                },\n            });\n            await listAndSendRepos(ctx, decoded);\n        } else {\n            ctx.deps.send({\n                type: \"ERROR\",\n                payload: {\n                    message: `GitHub: Authentication failed (stored token): ${who.error}.`,\n                },\n            });\n            ctx.deps.send({\n                type: \"GITHUB_AUTH_RESULT\",\n                payload: { ok: false, error: who.error, remember: false },\n            });\n        }\n    } catch {\n        // ignore\n    }\n}\n\nexport async function handleSetToken(\n    ctx: DispatcherContext,\n    payload: { token?: string; remember?: boolean }\n): Promise<void> {\n    const token = String(payload.token || \"\").trim();\n    const remember = !!payload.remember;\n\n    if (!token) {\n        ctx.deps.send({\n            type: \"ERROR\",\n            payload: { message: \"GitHub: Empty token.\" },\n        });\n        ctx.deps.send({\n            type: \"GITHUB_AUTH_RESULT\",\n            payload: {\n                ok: false,\n                error: \"empty token\",\n                remember: false,\n            },\n        });\n        return;\n    }\n\n    ctx.state.token = token;\n    if (remember) {\n        await figma.clientStorage\n            .setAsync(\"github_token_b64\", encodeToken(token))\n            .catch(() => {});\n    } else {\n        await figma.clientStorage\n            .deleteAsync(\"github_token_b64\")\n            .catch(() => {});\n    }\n\n    const who = await ghGetUser(token);\n    if (who.ok) {\n        ctx.deps.send({\n            type: \"GITHUB_AUTH_RESULT\",\n            payload: {\n                ok: true,\n                login: who.user.login,\n                name: who.user.name,\n                remember,\n            },\n        });\n        await listAndSendRepos(ctx, token);\n    } else {\n        ctx.deps.send({\n            type: \"ERROR\",\n            payload: {\n                message: `GitHub: Authentication failed: ${who.error}.`,\n            },\n        });\n        ctx.deps.send({\n            type: \"GITHUB_AUTH_RESULT\",\n            payload: {\n                ok: false,\n                error: who.error,\n                remember: false,\n            },\n        });\n        ctx.deps.send({ type: \"GITHUB_REPOS\", payload: { repos: [] } });\n    }\n}\n\nexport async function handleForgetToken(ctx: DispatcherContext): Promise<void> {\n    ctx.state.token = null;\n    await figma.clientStorage.deleteAsync(\"github_token_b64\").catch(() => {\n        /* ignore */\n    });\n    ctx.deps.send({\n        type: \"INFO\",\n        payload: { message: \"GitHub: Token cleared.\" },\n    });\n    ctx.deps.send({\n        type: \"GITHUB_AUTH_RESULT\",\n        payload: { ok: false, remember: false },\n    });\n    ctx.deps.send({ type: \"GITHUB_REPOS\", payload: { repos: [] } });\n}\n", "import { ghListBranches, ghCreateBranch } from \"../../../core/github/api\";\nimport type { DispatcherContext } from \"./types\";\nimport { mergeSelected, getSelected, setSelected } from \"./state\";\n\nexport async function handleFetchBranches(\n    ctx: DispatcherContext,\n    payload: any\n): Promise<void> {\n    const owner = String(payload.owner || \"\");\n    const repo = String(payload.repo || \"\");\n    const page = Number.isFinite(payload.page) ? Number(payload.page) : 1;\n    const force = !!payload.force;\n\n    if (!ctx.state.token) {\n        ctx.deps.send({\n            type: \"GITHUB_BRANCHES_ERROR\",\n            payload: {\n                owner,\n                repo,\n                status: 401,\n                message: \"No token\",\n            },\n        });\n        return;\n    }\n\n    const res = await ghListBranches(ctx.state.token, owner, repo, page, force);\n    if (res.ok) {\n        ctx.deps.send({ type: \"GITHUB_BRANCHES\", payload: res });\n        if (page === 1 && res.defaultBranch) {\n            await mergeSelected({\n                owner,\n                repo,\n                branch: res.defaultBranch,\n                prBase: res.defaultBranch,\n            });\n        }\n    } else {\n        ctx.deps.send({ type: \"GITHUB_BRANCHES_ERROR\", payload: res });\n    }\n}\n\nexport async function handleSelectBranch(\n    ctx: DispatcherContext,\n    payload: any\n): Promise<void> {\n    const sel = await getSelected();\n    await setSelected({\n        owner: payload.owner || sel.owner,\n        repo: payload.repo || sel.repo,\n        branch: payload.branch,\n        folder: undefined,\n        filename: sel.filename,\n        commitMessage: sel.commitMessage,\n        scope: sel.scope,\n        collection: sel.collection,\n        mode: sel.mode,\n        createPr: sel.createPr,\n        prBase: sel.prBase,\n        prTitle: sel.prTitle,\n        prBody: sel.prBody,\n    });\n}\n\nexport async function handleCreateBranch(\n    ctx: DispatcherContext,\n    payload: any\n): Promise<void> {\n    const owner = String(payload.owner || \"\");\n    const repo = String(payload.repo || \"\");\n    const baseBranch = String(payload.baseBranch || \"\");\n    const newBranch = String(payload.newBranch || \"\");\n\n    if (!ctx.state.token) {\n        ctx.deps.send({\n            type: \"GITHUB_CREATE_BRANCH_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                baseBranch,\n                newBranch,\n                status: 401,\n                message: \"No token\",\n            },\n        });\n        return;\n    }\n    if (!owner || !repo || !baseBranch || !newBranch) {\n        ctx.deps.send({\n            type: \"GITHUB_CREATE_BRANCH_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                baseBranch,\n                newBranch,\n                status: 400,\n                message: \"Missing owner/repo/base/new\",\n            },\n        });\n        return;\n    }\n\n    const res = await ghCreateBranch(\n        ctx.state.token,\n        owner,\n        repo,\n        newBranch,\n        baseBranch\n    );\n    if (res.ok) {\n        await mergeSelected({ owner, repo, branch: newBranch });\n    }\n    ctx.deps.send({\n        type: \"GITHUB_CREATE_BRANCH_RESULT\",\n        payload: res,\n    });\n}\n", "import { ghListDirs, ghEnsureFolder } from \"../../../core/github/api\";\nimport type { DispatcherContext } from \"./types\";\nimport {\n    normalizeFolderForStorage,\n    folderStorageToCommitPath,\n} from \"../folders\";\nimport { getSelected, setSelected } from \"./state\";\n\nasync function ensureFolderPathWritable(\n    token: string,\n    owner: string,\n    repo: string,\n    branch: string,\n    folderPath: string\n): Promise<{ ok: true } | { ok: false; status: number; message: string }> {\n    if (!folderPath) return { ok: true };\n    const segments = folderPath.split(\"/\").filter(Boolean);\n    let prefix = \"\";\n    for (let i = 0; i < segments.length; i++) {\n        prefix = prefix ? `${prefix}/${segments[i]}` : segments[i];\n        const res = await ghListDirs(token, owner, repo, branch, prefix);\n        if (res.ok) continue;\n        const status = typeof res.status === \"number\" ? res.status : 0;\n        if (status === 404) break;\n        if (status === 409) {\n            return {\n                ok: false,\n                status: 409,\n                message: `GitHub: \"${prefix}\" is already a file. Choose a different export folder.`,\n            };\n        }\n        if (res.samlRequired) {\n            return {\n                ok: false,\n                status: 403,\n                message:\n                    \"GitHub: Authorize SSO for this repository to export into that folder.\",\n            };\n        }\n        const message = res.message || `HTTP ${status}`;\n        return { ok: false, status: status || 400, message };\n    }\n    return { ok: true };\n}\n\nexport async function getSelectedFolderForCommit(folderRaw: string) {\n    const folderStoredResult = normalizeFolderForStorage(folderRaw);\n    if (!folderStoredResult.ok) {\n        return folderStoredResult;\n    }\n    const folderCommitResult = folderStorageToCommitPath(\n        folderStoredResult.storage\n    );\n    if (!folderCommitResult.ok) {\n        return folderCommitResult;\n    }\n    return {\n        ok: true as const,\n        storage: folderStoredResult.storage,\n        path: folderCommitResult.path,\n    };\n}\n\nexport { ensureFolderPathWritable }; // Export for use in commits.ts if needed\n\nexport async function handleSetFolder(\n    ctx: DispatcherContext,\n    payload: any\n): Promise<void> {\n    const folderResult = normalizeFolderForStorage(\n        String(payload.folder ?? \"\")\n    );\n    if (!folderResult.ok) {\n        ctx.deps.send({\n            type: \"ERROR\",\n            payload: { message: folderResult.message },\n        });\n        return;\n    }\n    const folder = folderResult.storage;\n    const sel = await getSelected();\n    await setSelected({\n        owner: payload.owner || sel.owner,\n        repo: payload.repo || sel.repo,\n        branch: sel.branch,\n        folder,\n        filename: sel.filename,\n        commitMessage: sel.commitMessage,\n        scope: sel.scope,\n        collection: sel.collection,\n        mode: sel.mode,\n        createPr: sel.createPr,\n        prBase: sel.prBase,\n        prTitle: sel.prTitle,\n        prBody: sel.prBody,\n    });\n}\n\nexport async function handleFolderList(\n    ctx: DispatcherContext,\n    payload: any\n): Promise<void> {\n    const owner = String(payload.owner || \"\");\n    const repo = String(payload.repo || \"\");\n    const branch = String(payload.branch || \"\");\n    const pathRaw = String(payload.path || \"\");\n\n    if (!ctx.state.token) {\n        ctx.deps.send({\n            type: \"GITHUB_FOLDER_LIST_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                path: pathRaw,\n                status: 401,\n                message: \"No token\",\n            },\n        });\n        return;\n    }\n\n    const normalizedPath = normalizeFolderForStorage(pathRaw);\n    if (!normalizedPath.ok) {\n        ctx.deps.send({\n            type: \"GITHUB_FOLDER_LIST_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                path: pathRaw,\n                status: 400,\n                message: normalizedPath.message,\n            },\n        });\n        return;\n    }\n    const commitPathResult = folderStorageToCommitPath(normalizedPath.storage);\n    if (!commitPathResult.ok) {\n        ctx.deps.send({\n            type: \"GITHUB_FOLDER_LIST_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                path: pathRaw,\n                status: 400,\n                message: commitPathResult.message,\n            },\n        });\n        return;\n    }\n\n    const folderPath = commitPathResult.path;\n    if (folderPath) {\n        const collision = await ensureFolderPathWritable(\n            ctx.state.token,\n            owner,\n            repo,\n            branch,\n            folderPath\n        );\n        if (!collision.ok) {\n            ctx.deps.send({\n                type: \"GITHUB_FOLDER_LIST_RESULT\",\n                payload: {\n                    ok: false,\n                    owner,\n                    repo,\n                    branch,\n                    path: folderPath,\n                    status: collision.status,\n                    message: collision.message,\n                },\n            });\n            return;\n        }\n    }\n\n    const res = await ghListDirs(\n        ctx.state.token,\n        owner,\n        repo,\n        branch,\n        commitPathResult.path\n    );\n    if (res.ok) {\n        ctx.deps.send({\n            type: \"GITHUB_FOLDER_LIST_RESULT\",\n            payload: {\n                ok: true,\n                owner,\n                repo,\n                branch,\n                path: res.path,\n                entries: res.dirs.map((d) => ({\n                    type: \"dir\",\n                    name: d.name,\n                    path: d.path,\n                })),\n                rate: res.rate,\n            },\n        });\n    } else {\n        ctx.deps.send({\n            type: \"GITHUB_FOLDER_LIST_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                path: res.path,\n                status: res.status,\n                message: res.message,\n                rate: res.rate,\n            },\n        });\n    }\n}\n\nexport async function handleCreateFolder(\n    ctx: DispatcherContext,\n    payload: any\n): Promise<void> {\n    const owner = String(payload.owner || \"\");\n    const repo = String(payload.repo || \"\");\n    const branch = String(payload.branch || \"\");\n    const folderPathRaw = String(\n        (payload as any).folderPath || payload.path || \"\"\n    ).trim();\n\n    if (!ctx.state.token) {\n        ctx.deps.send({\n            type: \"GITHUB_CREATE_FOLDER_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                folderPath: folderPathRaw,\n                status: 401,\n                message: \"No token\",\n            },\n        });\n        return;\n    }\n\n    const folderNormalized = normalizeFolderForStorage(folderPathRaw);\n    if (!folderNormalized.ok) {\n        ctx.deps.send({\n            type: \"GITHUB_CREATE_FOLDER_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                folderPath: folderPathRaw,\n                status: 400,\n                message: folderNormalized.message,\n            },\n        });\n        return;\n    }\n\n    const folderCommit = folderStorageToCommitPath(folderNormalized.storage);\n    if (!folderCommit.ok) {\n        ctx.deps.send({\n            type: \"GITHUB_CREATE_FOLDER_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                folderPath: folderPathRaw,\n                status: 400,\n                message: folderCommit.message,\n            },\n        });\n        return;\n    }\n    if (!folderCommit.path) {\n        ctx.deps.send({\n            type: \"GITHUB_CREATE_FOLDER_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                folderPath: folderPathRaw,\n                status: 400,\n                message: \"GitHub: Choose a subfolder name.\",\n            },\n        });\n        return;\n    }\n\n    const res = await ghEnsureFolder(\n        ctx.state.token,\n        owner,\n        repo,\n        branch,\n        folderCommit.path\n    );\n    ctx.deps.send({\n        type: \"GITHUB_CREATE_FOLDER_RESULT\",\n        payload: res,\n    });\n}\n", "// src/app/github/filenames.ts\n// Shared helpers for validating GitHub export filenames so UI and plugin stay in sync.\n\nexport const DEFAULT_GITHUB_FILENAME = \"tokens.json\";\n/**\n * Regex to detect invalid characters in GitHub filenames.\n * Includes ASCII control characters (\\u0000-\\u001F) which are not allowed in\n * filenames and could cause filesystem or security issues.\n */\n// eslint-disable-next-line no-control-regex -- Intentionally filtering control characters for filename safety\nconst INVALID_FILENAME_CHARS = /[<>:\"/\\\\|?*\\u0000-\\u001F]/;\nconst MAX_FILENAME_LENGTH = 128;\n\nexport type GithubFilenameValidation =\n    | { ok: true; filename: string }\n    | { ok: false; message: string };\n\nexport function validateGithubFilename(\n    raw: string | null | undefined\n): GithubFilenameValidation {\n    const initial = typeof raw === \"string\" ? raw : DEFAULT_GITHUB_FILENAME;\n    const trimmed = initial.trim();\n    if (!trimmed) {\n        return {\n            ok: false,\n            message: \"GitHub: Enter a filename (e.g., tokens.json).\",\n        };\n    }\n    if (trimmed === \".\" || trimmed === \"..\") {\n        return {\n            ok: false,\n            message: 'GitHub: Filename cannot be \".\" or \"..\".',\n        };\n    }\n    if (trimmed.length > MAX_FILENAME_LENGTH) {\n        return {\n            ok: false,\n            message: `GitHub: Filename must be ${MAX_FILENAME_LENGTH} characters or fewer.`,\n        };\n    }\n    if (INVALID_FILENAME_CHARS.test(trimmed)) {\n        return {\n            ok: false,\n            message:\n                'GitHub: Filename contains unsupported characters like / \\\\ : * ? \" < > |.',\n        };\n    }\n    if (!/\\.json$/i.test(trimmed)) {\n        return { ok: false, message: \"GitHub: Filename must end with .json.\" };\n    }\n    return { ok: true, filename: trimmed };\n}\n", "import {\n    ghGetFileContents,\n    ghCommitFiles,\n    ghCreatePullRequest,\n} from \"../../../core/github/api\";\nimport type { DispatcherContext, GhSelected } from \"./types\";\nimport { validateGithubFilename, DEFAULT_GITHUB_FILENAME } from \"../filenames\";\nimport {\n    getSelected,\n    mergeSelected,\n    getLastCommitSignature,\n    setLastCommitSignature,\n} from \"./state\";\nimport {\n    ensureFolderPathWritable,\n    getSelectedFolderForCommit,\n} from \"./folders\";\nimport type { GithubScope } from \"../../messages\";\n\nfunction sleep(ms: number) {\n    return new Promise<void>((resolve) => setTimeout(resolve, ms));\n}\n\nfunction pickPerModeFile(\n    files: Array<{ name: string; json: unknown }>,\n    collectionName: string,\n    modeName: string,\n    safeKeyFn: (c: string, m: string) => string\n): { name: string; json: unknown } | null {\n    const prettyExact = `${collectionName} - ${modeName}.json`;\n    const prettyLoose = `${collectionName} - ${modeName}`;\n    const legacy1 = `${collectionName}_mode=${modeName}`;\n    const legacy2 = `${collectionName}/mode=${modeName}`;\n    const legacy3 = safeKeyFn(collectionName, modeName);\n\n    let picked = files.find((f) => {\n        const n = String(f?.name || \"\");\n        return (\n            n === prettyExact ||\n            n === prettyLoose ||\n            n.includes(`${collectionName} - ${modeName}`)\n        );\n    });\n    if (!picked) {\n        picked = files.find((f) => {\n            const n = String(f?.name || \"\");\n            return (\n                n.includes(legacy1) ||\n                n.includes(legacy2) ||\n                n.includes(legacy3)\n            );\n        });\n    }\n    return picked || null;\n}\n\nexport async function handleExportFiles(\n    ctx: DispatcherContext,\n    payload: any\n): Promise<void> {\n    const scope: GithubScope =\n        payload.scope === \"all\"\n            ? \"all\"\n            : payload.scope === \"typography\"\n            ? \"typography\"\n            : \"selected\";\n    const collection = String(payload.collection || \"\");\n    const mode = String(payload.mode || \"\");\n    const styleDictionary = !!payload.styleDictionary;\n    const flatTokens = !!payload.flatTokens;\n\n    try {\n        if (scope === \"all\") {\n            const all = await ctx.deps.exportDtcg({\n                format: \"single\",\n                styleDictionary,\n                flatTokens,\n            });\n            ctx.deps.send({\n                type: \"GITHUB_EXPORT_FILES_RESULT\",\n                payload: { files: all.files },\n            });\n        } else if (scope === \"typography\") {\n            const typo = await ctx.deps.exportDtcg({\n                format: \"typography\",\n            });\n            ctx.deps.send({\n                type: \"GITHUB_EXPORT_FILES_RESULT\",\n                payload: { files: typo.files },\n            });\n        } else {\n            if (!collection || !mode) {\n                ctx.deps.send({\n                    type: \"GITHUB_EXPORT_FILES_RESULT\",\n                    payload: { files: [] },\n                });\n                ctx.deps.send({\n                    type: \"ERROR\",\n                    payload: {\n                        message:\n                            \"GitHub: choose collection and mode before exporting.\",\n                    },\n                });\n                return;\n            }\n            const per = await ctx.deps.exportDtcg({\n                format: \"perMode\",\n                styleDictionary,\n                flatTokens,\n            });\n            const picked = pickPerModeFile(\n                per.files,\n                collection,\n                mode,\n                ctx.deps.safeKeyFromCollectionAndMode\n            );\n            const files = picked ? [picked] : per.files;\n            ctx.deps.send({\n                type: \"GITHUB_EXPORT_FILES_RESULT\",\n                payload: { files },\n            });\n        }\n    } catch (err) {\n        const msgText = (err as Error)?.message || \"Failed to export\";\n        ctx.deps.send({\n            type: \"ERROR\",\n            payload: {\n                message: `GitHub export failed: ${msgText}`,\n            },\n        });\n        ctx.deps.send({\n            type: \"GITHUB_EXPORT_FILES_RESULT\",\n            payload: { files: [] },\n        });\n    }\n}\n\nexport async function handleExportAndCommit(\n    ctx: DispatcherContext,\n    payload: any\n): Promise<void> {\n    const owner = String(payload.owner || \"\");\n    const repo = String(payload.repo || \"\");\n    const baseBranch = String(payload.branch || \"\");\n    const folderRaw = typeof payload.folder === \"string\" ? payload.folder : \"\";\n    const commitMessage = (\n        String(payload.commitMessage || \"\") || \"Update tokens from Figma\"\n    ).trim();\n    const requestedScope: GithubScope =\n        payload.scope === \"all\"\n            ? \"all\"\n            : payload.scope === \"typography\"\n            ? \"typography\"\n            : \"selected\";\n    const scope: GithubScope = requestedScope;\n    const collection = String(payload.collection || \"\");\n    const mode = String(payload.mode || \"\");\n    const styleDictionary = !!payload.styleDictionary;\n    const flatTokens = !!payload.flatTokens;\n    const createPr = !!payload.createPr;\n    const prBaseBranch = createPr ? String(payload.prBase || \"\") : \"\";\n    const prTitle =\n        String(payload.prTitle || commitMessage).trim() || commitMessage;\n    const prBody =\n        typeof payload.prBody === \"string\" ? payload.prBody : undefined;\n    const storedSelection = await getSelected();\n    const selectionCollection =\n        collection ||\n        (typeof storedSelection.collection === \"string\"\n            ? storedSelection.collection\n            : \"\");\n    const selectionMode =\n        mode ||\n        (typeof storedSelection.mode === \"string\" ? storedSelection.mode : \"\");\n    const filenameCandidate =\n        typeof payload.filename === \"string\"\n            ? payload.filename\n            : typeof storedSelection.filename === \"string\"\n            ? storedSelection.filename\n            : undefined;\n    const filenameCheck = validateGithubFilename(\n        filenameCandidate ?? DEFAULT_GITHUB_FILENAME\n    );\n    if (!filenameCheck.ok) {\n        ctx.deps.send({\n            type: \"GITHUB_COMMIT_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch: baseBranch,\n                status: 400,\n                message: filenameCheck.message,\n                folder: folderRaw || \"\",\n                filename: filenameCandidate,\n            },\n        });\n        return;\n    }\n    const filenameToCommit = filenameCheck.filename;\n\n    if (!ctx.state.token) {\n        ctx.deps.send({\n            type: \"GITHUB_COMMIT_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch: baseBranch,\n                status: 401,\n                message: \"No token\",\n                folder: folderRaw || \"\",\n                filename: filenameToCommit,\n            },\n        });\n        return;\n    }\n    if (!owner || !repo || !baseBranch) {\n        ctx.deps.send({\n            type: \"GITHUB_COMMIT_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch: baseBranch,\n                status: 400,\n                message: \"Missing owner/repo/branch\",\n                folder: folderRaw || \"\",\n                filename: filenameToCommit,\n            },\n        });\n        return;\n    }\n    if (!commitMessage) {\n        ctx.deps.send({\n            type: \"GITHUB_COMMIT_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch: baseBranch,\n                status: 400,\n                message: \"Empty commit message\",\n                folder: folderRaw || \"\",\n                filename: filenameToCommit,\n            },\n        });\n        return;\n    }\n\n    const folderInfo = await getSelectedFolderForCommit(folderRaw);\n    if (!folderInfo.ok) {\n        ctx.deps.send({\n            type: \"GITHUB_COMMIT_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch: baseBranch,\n                status: 400,\n                message: folderInfo.message,\n                folder: folderRaw || \"\",\n                filename: filenameToCommit,\n            },\n        });\n        return;\n    }\n\n    if (folderInfo.path) {\n        const folderCheck = await ensureFolderPathWritable(\n            ctx.state.token,\n            owner,\n            repo,\n            baseBranch,\n            folderInfo.path\n        );\n        if (!folderCheck.ok) {\n            ctx.deps.send({\n                type: \"GITHUB_COMMIT_RESULT\",\n                payload: {\n                    ok: false,\n                    owner,\n                    repo,\n                    branch: baseBranch,\n                    status: folderCheck.status,\n                    message: folderCheck.message,\n                    folder: folderInfo.storage,\n                    filename: filenameToCommit,\n                },\n            });\n            return;\n        }\n    }\n\n    if (createPr && !prBaseBranch) {\n        ctx.deps.send({\n            type: \"GITHUB_COMMIT_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch: baseBranch,\n                status: 400,\n                message: \"Unable to determine target branch for pull request.\",\n                folder: folderInfo.storage,\n                filename: filenameToCommit,\n            },\n        });\n        return;\n    }\n    if (createPr && prBaseBranch === baseBranch) {\n        ctx.deps.send({\n            type: \"GITHUB_COMMIT_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch: baseBranch,\n                status: 400,\n                message:\n                    \"Selected branch matches PR target branch. Choose a different branch before creating a PR.\",\n                folder: folderInfo.storage,\n                filename: filenameToCommit,\n            },\n        });\n        return;\n    }\n\n    const folderStorageValue = folderInfo.storage;\n    const folderCommitPath = folderInfo.path;\n    const fullPathForCommit = folderCommitPath\n        ? `${folderCommitPath}/${filenameToCommit}`\n        : filenameToCommit;\n    const lastCommitSignature = (await getLastCommitSignature()) || null;\n    const sameTargetAsLastCommit =\n        !!lastCommitSignature &&\n        lastCommitSignature.branch === baseBranch &&\n        lastCommitSignature.fullPath === fullPathForCommit &&\n        lastCommitSignature.scope === scope;\n\n    const selectionState: Partial<GhSelected> = {\n        owner,\n        repo,\n        branch: baseBranch,\n        folder: folderInfo.storage,\n        filename: filenameToCommit,\n        commitMessage,\n        scope,\n        styleDictionary: payload.styleDictionary,\n        flatTokens: payload.flatTokens,\n        createPr,\n        prBase: createPr ? prBaseBranch : undefined,\n        prTitle: createPr ? prTitle : undefined,\n        prBody: createPr ? prBody : undefined,\n    };\n    if (selectionCollection) selectionState.collection = selectionCollection;\n    if (selectionMode) selectionState.mode = selectionMode;\n    await mergeSelected(selectionState);\n    await ctx.deps.broadcastLocalCollections({ force: true });\n\n    try {\n        const files: Array<{ name: string; json: unknown }> = [];\n\n        if (scope === \"all\") {\n            const all = await ctx.deps.exportDtcg({\n                format: \"single\",\n                styleDictionary,\n                flatTokens,\n            });\n            for (const f of all.files)\n                files.push({ name: f.name, json: f.json });\n        } else if (scope === \"typography\") {\n            const typo = await ctx.deps.exportDtcg({\n                format: \"typography\",\n            });\n            for (const f of typo.files)\n                files.push({ name: f.name, json: f.json });\n        } else {\n            if (!selectionCollection || !selectionMode) {\n                ctx.deps.send({\n                    type: \"GITHUB_COMMIT_RESULT\",\n                    payload: {\n                        ok: false,\n                        owner,\n                        repo,\n                        branch: baseBranch,\n                        status: 400,\n                        message: \"Pick a collection and a mode.\",\n                        folder: folderStorageValue,\n                        filename: filenameToCommit,\n                        fullPath: fullPathForCommit,\n                    },\n                });\n                return;\n            }\n            const per = await ctx.deps.exportDtcg({\n                format: \"perMode\",\n                styleDictionary,\n                flatTokens,\n            });\n            const picked = pickPerModeFile(\n                per.files,\n                selectionCollection,\n                selectionMode,\n                ctx.deps.safeKeyFromCollectionAndMode\n            );\n            if (!picked) {\n                const available = per.files.map((f) => f.name).join(\", \");\n                ctx.deps.send({\n                    type: \"GITHUB_COMMIT_RESULT\",\n                    payload: {\n                        ok: false,\n                        owner,\n                        repo,\n                        branch: baseBranch,\n                        status: 404,\n                        message: `No export found for \"${selectionCollection}\" / \"${selectionMode}\". Available: [${available}]`,\n                        folder: folderStorageValue,\n                        filename: filenameToCommit,\n                        fullPath: fullPathForCommit,\n                    },\n                });\n                return;\n            }\n            files.push({ name: picked.name, json: picked.json });\n        }\n\n        if (files.length > 1) {\n            ctx.deps.send({\n                type: \"GITHUB_COMMIT_RESULT\",\n                payload: {\n                    ok: false,\n                    owner,\n                    repo,\n                    branch: baseBranch,\n                    status: 400,\n                    message:\n                        \"GitHub: Custom filename requires a single export file. Adjust scope or disable extra formats.\",\n                    folder: folderStorageValue,\n                    filename: filenameToCommit,\n                    fullPath: fullPathForCommit,\n                },\n            });\n            return;\n        }\n\n        const isPlainEmptyObject = (v: any) =>\n            v &&\n            typeof v === \"object\" &&\n            !Array.isArray(v) &&\n            Object.keys(v).length === 0;\n        const exportLooksEmpty =\n            files.length === 0 ||\n            files.every((f) => isPlainEmptyObject(f.json));\n\n        if (exportLooksEmpty) {\n            if (scope === \"typography\") {\n                const warningMessage =\n                    \"GitHub export warning: typography.json is empty (no local text styles). Nothing to commit.\";\n                ctx.deps.send({\n                    type: \"GITHUB_COMMIT_RESULT\",\n                    payload: {\n                        ok: false,\n                        owner,\n                        repo,\n                        branch: baseBranch,\n                        status: 412,\n                        message: warningMessage,\n                        folder: folderStorageValue,\n                        filename: filenameToCommit,\n                        fullPath: fullPathForCommit,\n                    },\n                });\n                return;\n            }\n            if (exportLooksEmpty && scope === \"selected\") {\n                const diag = await ctx.deps.analyzeSelectionState(\n                    selectionCollection,\n                    selectionMode\n                );\n                const tail = diag.ok\n                    ? `Found ${\n                          diag.variableCount\n                      } variable(s) in \"${selectionCollection}\", but ${\n                          diag.variablesWithValues ?? 0\n                      } with a value in \"${selectionMode}\".`\n                    : diag.message || \"No values present.\";\n                ctx.deps.send({\n                    type: \"GITHUB_COMMIT_RESULT\",\n                    payload: {\n                        ok: false,\n                        owner,\n                        repo,\n                        branch: baseBranch,\n                        status: 412,\n                        message: `Export for \"${selectionCollection}\" / \"${selectionMode}\" produced an empty tokens file. ${tail}`,\n                        folder: folderStorageValue,\n                        filename: filenameToCommit,\n                        fullPath: fullPathForCommit,\n                    },\n                });\n                return;\n            }\n            if (exportLooksEmpty) {\n                ctx.deps.send({\n                    type: \"GITHUB_COMMIT_RESULT\",\n                    payload: {\n                        ok: false,\n                        owner,\n                        repo,\n                        branch: baseBranch,\n                        status: 412,\n                        message:\n                            \"Export produced an empty tokens file. Ensure this file contains local Variables with values.\",\n                        folder: folderStorageValue,\n                        filename: filenameToCommit,\n                        fullPath: fullPathForCommit,\n                    },\n                });\n                return;\n            }\n        }\n\n        const prettyExportName = (\n            original: string | undefined | null\n        ): string => {\n            const name =\n                original && typeof original === \"string\"\n                    ? original\n                    : \"tokens.json\";\n            const m = name.match(/^(.*)_mode=(.*)\\.tokens\\.json$/);\n            if (m) return `${m[1].trim()} - ${m[2].trim()}.json`;\n            return name.endsWith(\".json\") ? name : name + \".json\";\n        };\n        const prefix = folderCommitPath ? folderCommitPath + \"/\" : \"\";\n        const commitFiles = files.map((f) => {\n            const resolvedName =\n                files.length === 1\n                    ? filenameToCommit\n                    : prettyExportName(f.name);\n            return {\n                path: prefix + resolvedName,\n                content: JSON.stringify(f.json, null, 2) + \"\\n\",\n            };\n        });\n\n        const normalizeForCompare = (text: string): string =>\n            text.replace(/\\r\\n/g, \"\\n\").trimEnd();\n        const tryParseJson = (text: string): unknown | undefined => {\n            try {\n                return JSON.parse(text);\n            } catch {\n                return undefined;\n            }\n        };\n        const canonicalizeJson = (value: unknown): unknown => {\n            if (Array.isArray(value)) {\n                return value.map((item) => canonicalizeJson(item));\n            }\n            if (value && typeof value === \"object\") {\n                const proto = Object.getPrototypeOf(value);\n                if (proto === Object.prototype || proto === null) {\n                    const record = value as Record<string, unknown>;\n                    const sortedKeys = Object.keys(record).sort();\n                    const canonical: Record<string, unknown> = {};\n                    for (const key of sortedKeys)\n                        canonical[key] = canonicalizeJson(record[key]);\n                    return canonical;\n                }\n            }\n            return value;\n        };\n        const containsTypographyTokens = (text: string): boolean => {\n            const parsed = tryParseJson(text);\n            const hasTypography = (value: unknown): boolean => {\n                if (!value) return false;\n                if (typeof value === \"string\") {\n                    return value.toLowerCase() === \"typography\";\n                }\n                if (typeof value === \"object\") {\n                    if (Object.prototype.hasOwnProperty.call(value, \"$type\")) {\n                        const t = (\n                            value as {\n                                [k: string]: unknown;\n                            }\n                        )[\"$type\"];\n                        if (\n                            typeof t === \"string\" &&\n                            t.toLowerCase() === \"typography\"\n                        ) {\n                            return true;\n                        }\n                    }\n                    for (const key in value as {\n                        [k: string]: unknown;\n                    }) {\n                        if (\n                            Object.prototype.hasOwnProperty.call(value, key) &&\n                            hasTypography(\n                                (\n                                    value as {\n                                        [k: string]: unknown;\n                                    }\n                                )[key]\n                            )\n                        ) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            };\n            if (parsed !== undefined) {\n                return hasTypography(parsed);\n            }\n            return /\"\\$type\"\\s*:\\s*\"typography\"/i.test(text);\n        };\n        const contentsMatch = (\n            existing: string,\n            nextContent: string\n        ): boolean => {\n            if (existing === nextContent) return true;\n            if (\n                normalizeForCompare(existing) ===\n                normalizeForCompare(nextContent)\n            )\n                return true;\n            const existingJson = tryParseJson(existing);\n            const nextJson = tryParseJson(nextContent);\n            if (existingJson !== undefined && nextJson !== undefined) {\n                return (\n                    JSON.stringify(canonicalizeJson(existingJson)) ===\n                    JSON.stringify(canonicalizeJson(nextJson))\n                );\n            }\n            return false;\n        };\n\n        let allFilesIdentical = commitFiles.length > 0;\n        for (const file of commitFiles) {\n            const current = await ghGetFileContents(\n                ctx.state.token!,\n                owner,\n                repo,\n                baseBranch,\n                file.path\n            );\n            if (!current.ok) {\n                if (current.status === 404) {\n                    allFilesIdentical = false;\n                    break;\n                }\n                // If we cannot read the current file (permissions, SAML, etc.), assume changes are needed.\n                allFilesIdentical = false;\n                break;\n            }\n            if (\n                scope === \"typography\" &&\n                containsTypographyTokens(file.content) &&\n                !containsTypographyTokens(current.contentText)\n            ) {\n                allFilesIdentical = false;\n                break;\n            }\n            if (!contentsMatch(current.contentText, file.content)) {\n                allFilesIdentical = false;\n                break;\n            }\n        }\n\n        if (allFilesIdentical && !sameTargetAsLastCommit) {\n            allFilesIdentical = false;\n        }\n\n        if (allFilesIdentical) {\n            const noChangeMessage =\n                scope === \"selected\"\n                    ? `No token values changed for \"${selectionCollection}\" / \"${selectionMode}\"; repository already matches the current export.`\n                    : \"No token values changed; repository already matches the current export.\";\n            ctx.deps.send({\n                type: \"GITHUB_COMMIT_RESULT\",\n                payload: {\n                    ok: false,\n                    owner,\n                    repo,\n                    branch: baseBranch,\n                    status: 304,\n                    message: noChangeMessage,\n                    folder: folderStorageValue,\n                    filename: filenameToCommit,\n                    fullPath: fullPathForCommit,\n                },\n            });\n            return;\n        }\n\n        const attemptCommit = async () =>\n            ghCommitFiles(\n                ctx.state.token!,\n                owner,\n                repo,\n                baseBranch,\n                commitMessage,\n                commitFiles\n            );\n        let commitRes = await attemptCommit();\n        let fastForwardRetry = false;\n        if (\n            !commitRes.ok &&\n            commitRes.status === 422 &&\n            typeof commitRes.message === \"string\" &&\n            /not a fast forward/i.test(commitRes.message)\n        ) {\n            await sleep(200);\n            commitRes = await attemptCommit();\n            fastForwardRetry = true;\n        }\n        if (!commitRes.ok) {\n            const looksLikeFastForwardRace =\n                commitRes.status === 422 &&\n                typeof commitRes.message === \"string\" &&\n                /not a fast forward/i.test(commitRes.message);\n            if (looksLikeFastForwardRace && sameTargetAsLastCommit) {\n                const noChangeMessage =\n                    scope === \"selected\"\n                        ? `No token values changed for \"${selectionCollection}\" / \"${selectionMode}\"; repository already matches the current export.`\n                        : \"No token values changed; repository already matches the current export.\";\n                ctx.deps.send({\n                    type: \"GITHUB_COMMIT_RESULT\",\n                    payload: {\n                        ok: false,\n                        owner,\n                        repo,\n                        branch: baseBranch,\n                        status: 304,\n                        message: noChangeMessage,\n                        folder: folderStorageValue,\n                        filename: filenameToCommit,\n                        fullPath: fullPathForCommit,\n                    },\n                });\n                return;\n            }\n            ctx.deps.send({\n                type: \"GITHUB_COMMIT_RESULT\",\n                payload: {\n                    ...commitRes,\n                    folder: folderStorageValue,\n                    filename: filenameToCommit,\n                    fullPath: fullPathForCommit,\n                },\n            });\n            ctx.deps.send({\n                type: \"ERROR\",\n                payload: {\n                    message: `GitHub: Commit failed (${commitRes.status}): ${\n                        commitRes.message\n                    }${fastForwardRetry ? \" (after retry)\" : \"\"}`,\n                },\n            });\n            return;\n        }\n\n        await setLastCommitSignature({\n            branch: baseBranch,\n            fullPath: fullPathForCommit,\n            scope,\n        });\n\n        let prResult:\n            | Awaited<ReturnType<typeof ghCreatePullRequest>>\n            | undefined;\n        if (createPr) {\n            prResult = await ghCreatePullRequest(\n                ctx.state.token!,\n                owner,\n                repo,\n                {\n                    title: prTitle,\n                    head: baseBranch,\n                    base: prBaseBranch,\n                    body: prBody,\n                }\n            );\n        }\n\n        const commitOkPayload = {\n            ok: true as const,\n            owner,\n            repo,\n            branch: baseBranch,\n            folder: folderStorageValue,\n            filename: filenameToCommit,\n            fullPath: fullPathForCommit,\n            commitSha: commitRes.commitSha,\n            commitUrl: commitRes.commitUrl,\n            treeUrl: commitRes.treeUrl,\n            rate: commitRes.rate,\n            createdPr:\n                prResult && prResult.ok\n                    ? {\n                          number: prResult.number,\n                          url: prResult.url,\n                          base: prResult.base,\n                          head: prResult.head,\n                      }\n                    : undefined,\n        };\n        ctx.deps.send({\n            type: \"GITHUB_COMMIT_RESULT\",\n            payload: commitOkPayload,\n        });\n\n        ctx.deps.send({\n            type: \"INFO\",\n            payload: {\n                message: `Committed ${commitFiles.length} file(s) to ${owner}/${repo}@${baseBranch}`,\n            },\n        });\n        if (createPr) {\n            if (prResult && prResult.ok) {\n                ctx.deps.send({\n                    type: \"GITHUB_PR_RESULT\",\n                    payload: prResult,\n                });\n                ctx.deps.send({\n                    type: \"INFO\",\n                    payload: {\n                        message: `PR created: ${prResult.url}`,\n                    },\n                });\n            } else if (prResult) {\n                ctx.deps.send({\n                    type: \"GITHUB_PR_RESULT\",\n                    payload: prResult,\n                });\n                ctx.deps.send({\n                    type: \"ERROR\",\n                    payload: {\n                        message: `GitHub: PR creation failed (${prResult.status}): ${prResult.message}`,\n                    },\n                });\n            }\n        }\n    } catch (e) {\n        const msgText = (e as Error)?.message || \"unknown error\";\n        ctx.deps.send({\n            type: \"GITHUB_COMMIT_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch: baseBranch,\n                status: 0,\n                message: msgText,\n                folder: folderStorageValue,\n                filename: filenameToCommit,\n                fullPath: fullPathForCommit,\n            },\n        });\n    }\n}\n", "import { ghGetFileContents } from \"../../../core/github/api\";\nimport type { DispatcherContext } from \"./types\";\nimport {\n    normalizeFolderForStorage,\n    folderStorageToCommitPath,\n} from \"../folders\";\n\nexport async function handleFetchTokens(\n    ctx: DispatcherContext,\n    payload: any\n): Promise<void> {\n    const owner = String(payload.owner || \"\");\n    const repo = String(payload.repo || \"\");\n    const branch = String(payload.branch || \"\");\n    const pathRaw = String(payload.path || \"\");\n    const allowHex = !!payload.allowHexStrings;\n\n    if (!ctx.state.token) {\n        ctx.deps.send({\n            type: \"GITHUB_FETCH_TOKENS_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                path: pathRaw,\n                status: 401,\n                message: \"No token\",\n            },\n        });\n        return;\n    }\n    if (!owner || !repo || !branch || !pathRaw.trim()) {\n        ctx.deps.send({\n            type: \"GITHUB_FETCH_TOKENS_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                path: pathRaw,\n                status: 400,\n                message: \"Missing owner/repo/branch/path\",\n            },\n        });\n        return;\n    }\n\n    const normalizedPath = normalizeFolderForStorage(pathRaw);\n    if (!normalizedPath.ok) {\n        ctx.deps.send({\n            type: \"GITHUB_FETCH_TOKENS_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                path: pathRaw,\n                status: 400,\n                message: normalizedPath.message,\n            },\n        });\n        return;\n    }\n    const commitPathResult = folderStorageToCommitPath(normalizedPath.storage);\n    if (!commitPathResult.ok) {\n        ctx.deps.send({\n            type: \"GITHUB_FETCH_TOKENS_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                path: pathRaw,\n                status: 400,\n                message: commitPathResult.message,\n            },\n        });\n        return;\n    }\n    const path = commitPathResult.path;\n\n    const res = await ghGetFileContents(\n        ctx.state.token,\n        owner,\n        repo,\n        branch,\n        path\n    );\n    if (!res.ok) {\n        ctx.deps.send({\n            type: \"GITHUB_FETCH_TOKENS_RESULT\",\n            payload: res,\n        });\n        if (res.samlRequired) {\n            ctx.deps.send({\n                type: \"ERROR\",\n                payload: {\n                    message:\n                        \"GitHub: SSO required for this repository. Authorize your PAT and try again.\",\n                },\n            });\n        }\n        return;\n    }\n\n    try {\n        const json = JSON.parse(res.contentText || \"{}\");\n        const contexts = Array.isArray(payload.contexts)\n            ? payload.contexts.map((c: any) => String(c))\n            : [];\n        const summary = await ctx.deps.importDtcg(json, {\n            allowHexStrings: allowHex,\n            contexts,\n        });\n        ctx.deps.send({\n            type: \"GITHUB_FETCH_TOKENS_RESULT\",\n            payload: { ok: true, owner, repo, branch, path, json },\n        });\n        ctx.deps.send({\n            type: \"INFO\",\n            payload: {\n                message: `Imported tokens from ${owner}/${repo}@${branch}:${path}`,\n            },\n        });\n        ctx.deps.send({\n            type: \"IMPORT_SUMMARY\",\n            payload: {\n                summary,\n                timestamp: Date.now(),\n                source: \"github\",\n            },\n        });\n    } catch (err) {\n        const msgText = (err as Error)?.message || \"Invalid JSON\";\n        ctx.deps.send({\n            type: \"GITHUB_FETCH_TOKENS_RESULT\",\n            payload: {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                path,\n                status: 422,\n                message: msgText,\n            },\n        });\n        ctx.deps.send({\n            type: \"ERROR\",\n            payload: {\n                message: `GitHub import failed: ${msgText}`,\n            },\n        });\n        return;\n    }\n\n    // Refresh UI safely after import\n    try {\n        await ctx.deps.broadcastLocalCollections({ force: true });\n    } catch {\n        // ignore refresh errors, import succeeded\n    }\n}\n", "import type { UiToPlugin } from \"../messages\";\nimport type {\n    HandlerDeps,\n    DispatcherState,\n    DispatcherContext,\n} from \"./handlers/types\";\nimport {\n    handleSetToken,\n    handleForgetToken,\n    restoreGithubTokenAndVerify,\n} from \"./handlers/auth\";\nimport { handleSelectRepo } from \"./handlers/repos\";\nimport {\n    handleFetchBranches,\n    handleSelectBranch,\n    handleCreateBranch,\n} from \"./handlers/branches\";\nimport {\n    handleFolderList,\n    handleCreateFolder,\n    handleSetFolder,\n} from \"./handlers/folders\";\nimport { handleSaveState, getSelected } from \"./handlers/state\";\nimport { handleExportFiles, handleExportAndCommit } from \"./handlers/commits\";\nimport { handleFetchTokens } from \"./handlers/import\";\n\ntype GithubDispatcher = {\n    handle: (msg: UiToPlugin) => Promise<boolean>;\n    onUiReady: () => Promise<void>;\n};\n\nexport function createGithubDispatcher(deps: HandlerDeps): GithubDispatcher {\n    const state: DispatcherState = {\n        token: null,\n    };\n\n    const ctx: DispatcherContext = {\n        deps,\n        state,\n    };\n\n    async function handle(msg: UiToPlugin): Promise<boolean> {\n        switch (msg.type) {\n            case \"GITHUB_SET_TOKEN\":\n                await handleSetToken(ctx, msg.payload);\n                return true;\n            case \"GITHUB_FORGET_TOKEN\":\n                await handleForgetToken(ctx);\n                return true;\n            case \"GITHUB_SELECT_REPO\":\n                await handleSelectRepo(ctx, msg.payload);\n                return true;\n            case \"GITHUB_FETCH_BRANCHES\":\n                await handleFetchBranches(ctx, msg.payload);\n                return true;\n            case \"GITHUB_SELECT_BRANCH\":\n                await handleSelectBranch(ctx, msg.payload);\n                return true;\n            case \"GITHUB_CREATE_BRANCH\":\n                await handleCreateBranch(ctx, msg.payload);\n                return true;\n            case \"GITHUB_FOLDER_LIST\":\n                await handleFolderList(ctx, msg.payload);\n                return true;\n            case \"GITHUB_CREATE_FOLDER\":\n                await handleCreateFolder(ctx, msg.payload);\n                return true;\n            case \"GITHUB_SET_FOLDER\":\n                await handleSetFolder(ctx, msg.payload);\n                return true;\n            case \"GITHUB_SAVE_STATE\":\n                await handleSaveState(ctx, msg.payload);\n                return true;\n            case \"GITHUB_EXPORT_FILES\":\n                await handleExportFiles(ctx, msg.payload);\n                return true;\n            case \"GITHUB_EXPORT_AND_COMMIT\":\n                await handleExportAndCommit(ctx, msg.payload);\n                return true;\n            case \"GITHUB_FETCH_TOKENS\":\n                await handleFetchTokens(ctx, msg.payload);\n                return true;\n            default:\n                return false;\n        }\n    }\n\n    async function onUiReady(): Promise<void> {\n        await restoreGithubTokenAndVerify(ctx);\n        const sel = await getSelected();\n        if (sel.owner && sel.repo) {\n            deps.send({ type: \"GITHUB_RESTORE_SELECTED\", payload: sel });\n        }\n    }\n\n    return { handle, onUiReady };\n}\n", "// src/app/main.ts\n// Main-thread controller: wires UI messages into Figma APIs and GitHub helpers.\n// - Handles persistence so the iframe can reload without losing settings\n// - Wraps GitHub flows with retries and gentle error surfaces\n\nimport type { UiToPlugin, PluginToUi } from \"./messages\";\nimport {\n    snapshotCollectionsForUi,\n    analyzeSelectionState,\n    safeKeyFromCollectionAndMode,\n} from \"./collections\";\nimport { importDtcg, exportDtcg } from \"../core/pipeline\";\n\nimport { createGithubDispatcher } from \"./github/dispatcher\";\n\n// __html__ is injected by your build (esbuild) from dist/ui.html with ui.js inlined.\ndeclare const __html__: string;\n\n// Use saved size if available; fall back to 960\u00D7540.\n(async function initUI() {\n    let w = 1200,\n        h = 675;\n    try {\n        const saved = await figma.clientStorage.getAsync(\"uiSize\");\n        if (\n            saved &&\n            typeof saved.width === \"number\" &&\n            typeof saved.height === \"number\"\n        ) {\n            const sw = Math.floor(saved.width);\n            const sh = Math.floor(saved.height);\n            w = Math.max(720, Math.min(1600, sw));\n            h = Math.max(420, Math.min(1200, sh));\n        }\n    } catch {\n        /* ignore */\n    }\n    figma.showUI(__html__, { width: w, height: h });\n})();\n\nfunction send(msg: PluginToUi): void {\n    figma.ui.postMessage(msg);\n}\n\nlet lastChecksum = \"\";\n\nasync function broadcastLocalCollections(\n    opts: { force?: boolean; silent?: boolean } = {}\n): Promise<void> {\n    const snap = await snapshotCollectionsForUi();\n\n    // If not forced, check if meaningful change occurred\n    if (!opts.force && snap.checksum === lastChecksum) {\n        return;\n    }\n\n    lastChecksum = snap.checksum;\n\n    const last = await figma.clientStorage\n        .getAsync(\"lastSelection\")\n        .catch(() => null);\n    const exportAllPrefVal = await figma.clientStorage\n        .getAsync(\"exportAllPref\")\n        .catch(() => false);\n    const styleDictionaryPrefVal = await figma.clientStorage\n        .getAsync(\"styleDictionaryPref\")\n        .catch(() => false);\n    const flatTokensPrefVal = await figma.clientStorage\n        .getAsync(\"flatTokensPref\")\n        .catch(() => false);\n    const allowHexPrefStored = await figma.clientStorage\n        .getAsync(\"allowHexPref\")\n        .catch(() => null);\n    const githubRememberPrefStored = await figma.clientStorage\n        .getAsync(\"githubRememberPref\")\n        .catch(() => null);\n    const allowHexPrefVal =\n        typeof allowHexPrefStored === \"boolean\" ? allowHexPrefStored : true;\n    const githubRememberPrefVal =\n        typeof githubRememberPrefStored === \"boolean\"\n            ? githubRememberPrefStored\n            : true;\n    const lastOrNull =\n        last &&\n        typeof last.collection === \"string\" &&\n        typeof last.mode === \"string\"\n            ? last\n            : null;\n\n    if (!opts.silent) {\n        send({\n            type: \"INFO\",\n            payload: {\n                message:\n                    \"Fetched \" +\n                    String(snap.collections.length) +\n                    \" collections\" +\n                    (opts.force ? \"\" : \" (auto)\"),\n            },\n        });\n    }\n\n    send({\n        type: \"COLLECTIONS_DATA\",\n        payload: {\n            collections: snap.collections,\n            last: lastOrNull,\n            exportAllPref: !!exportAllPrefVal,\n            styleDictionaryPref: !!styleDictionaryPrefVal,\n            flatTokensPref: !!flatTokensPrefVal,\n            allowHexPref: allowHexPrefVal,\n            githubRememberPref: githubRememberPrefVal,\n            textStylesCount: snap.textStylesCount,\n        },\n    });\n    send({ type: \"RAW_COLLECTIONS_TEXT\", payload: { text: snap.rawText } });\n}\n\nfunction startPolling() {\n    // Listen for style changes (immediate)\n    figma.on(\"documentchange\", (event) => {\n        const styleChanges = event.documentChanges.filter(\n            (c) =>\n                c.type === \"STYLE_CREATE\" ||\n                c.type === \"STYLE_DELETE\" ||\n                c.type === \"STYLE_PROPERTY_CHANGE\"\n        );\n        if (styleChanges.length > 0) {\n            const createdIds = new Set(\n                styleChanges\n                    .filter((c) => c.type === \"STYLE_CREATE\")\n                    .map((c) => c.id)\n            );\n            const deletedIds = new Set(\n                styleChanges\n                    .filter((c) => c.type === \"STYLE_DELETE\")\n                    .map((c) => c.id)\n            );\n\n            // Ignore styles that were created and deleted in the same batch (ghosts)\n            const ghostIds = new Set(\n                [...createdIds].filter((id) => deletedIds.has(id))\n            );\n\n            for (const change of styleChanges) {\n                if (ghostIds.has(change.id)) continue;\n\n                if (change.type === \"STYLE_CREATE\") {\n                    const style = figma.getStyleById(change.id);\n                    // If style is null, it might be a ghost that wasn't caught or an internal error. Skip it.\n                    if (style) {\n                        send({\n                            type: \"INFO\",\n                            payload: {\n                                message: `Style Created: ${style.name}`,\n                            },\n                        });\n                    }\n                } else if (change.type === \"STYLE_DELETE\") {\n                    // We can't get the name of a deleted style, so just log a generic message.\n                    send({\n                        type: \"INFO\",\n                        payload: { message: \"Style Deleted\" },\n                    });\n                } else if (change.type === \"STYLE_PROPERTY_CHANGE\") {\n                    // If the style was created in this batch, the CREATE event (with final state) is sufficient.\n                    // Suppress the update to avoid \"Updated then Created\" noise.\n                    if (createdIds.has(change.id)) continue;\n\n                    const style = figma.getStyleById(change.id);\n                    if (style) {\n                        send({\n                            type: \"INFO\",\n                            payload: {\n                                message: `Style Updated: ${\n                                    style.name\n                                } (Properties: ${change.properties.join(\n                                    \", \"\n                                )})`,\n                            },\n                        });\n                    }\n                }\n            }\n            broadcastLocalCollections({ force: true, silent: true }).catch(\n                (err) => console.error(err)\n            );\n        }\n    });\n\n    // Also check on selection/page change as a heuristic\n    figma.on(\"selectionchange\", () => {\n        broadcastLocalCollections({ force: false, silent: true }).catch((err) =>\n            console.error(err)\n        );\n    });\n    figma.on(\"currentpagechange\", () => {\n        broadcastLocalCollections({ force: false, silent: true }).catch((err) =>\n            console.error(err)\n        );\n    });\n}\n\nconst github = createGithubDispatcher({\n    send,\n    snapshotCollectionsForUi,\n    analyzeSelectionState,\n    safeKeyFromCollectionAndMode,\n    importDtcg,\n    exportDtcg,\n    broadcastLocalCollections,\n});\n\ntype MessageOfType<T extends UiToPlugin[\"type\"]> = Extract<\n    UiToPlugin,\n    { type: T }\n>;\ntype Handler = (msg: UiToPlugin) => Promise<void> | void;\n\n// Prime the UI with cached state and fresh collections so the iframe can render immediately.\nasync function handleUiReady(_msg: UiToPlugin): Promise<void> {\n    await broadcastLocalCollections({ force: true, silent: false });\n    await github.onUiReady();\n    startPolling();\n}\n\n// Refresh the collection snapshot on demand, mirroring the bootstrap payload.\nasync function handleFetchCollections(_msg: UiToPlugin): Promise<void> {\n    await broadcastLocalCollections({ force: true, silent: false });\n}\n\n// Respond to PING by checking for changes silently\nasync function handlePing(_msg: UiToPlugin): Promise<void> {\n    await broadcastLocalCollections({ force: false, silent: true });\n}\n\n// Apply an uploaded DTCG payload to the document and broadcast the resulting summary back to the UI.\nasync function handleImportDtcg(msg: UiToPlugin): Promise<void> {\n    const payload = (msg as MessageOfType<\"IMPORT_DTCG\">).payload;\n    const contexts = Array.isArray(payload.contexts)\n        ? payload.contexts.map((c) => String(c))\n        : [];\n    const summary = await importDtcg(payload.json, {\n        allowHexStrings: !!payload.allowHexStrings,\n        contexts,\n    });\n\n    const skippedCount = summary.skippedContexts.length;\n    if (skippedCount > 0) {\n        send({\n            type: \"INFO\",\n            payload: {\n                message: `Import completed. Applied ${summary.appliedContexts.length} context(s); skipped ${skippedCount}.`,\n            },\n        });\n    } else {\n        send({ type: \"INFO\", payload: { message: \"Import completed.\" } });\n    }\n\n    send({\n        type: \"IMPORT_SUMMARY\",\n        payload: { summary, timestamp: Date.now(), source: \"local\" },\n    });\n\n    await broadcastLocalCollections({ force: true, silent: true });\n}\n\n// Export tokens either per mode or as a single bundle, matching the UI's requested scope.\nasync function handleExportDtcg(msg: UiToPlugin): Promise<void> {\n    const payload = (msg as MessageOfType<\"EXPORT_DTCG\">).payload;\n    const exportAll = !!payload.exportAll;\n    const styleDictionary = !!payload.styleDictionary;\n    const flatTokens = !!payload.flatTokens;\n    if (exportAll) {\n        const all = await exportDtcg({\n            format: \"single\",\n            styleDictionary,\n            flatTokens,\n        });\n        send({ type: \"EXPORT_RESULT\", payload: { files: all.files } });\n        return;\n    }\n\n    const collectionName = payload.collection ? payload.collection : \"\";\n    const modeName = payload.mode ? payload.mode : \"\";\n    const per = await exportDtcg({\n        format: \"perMode\",\n        styleDictionary,\n        flatTokens,\n    });\n\n    const prettyExact = `${collectionName} - ${modeName}.json`;\n    const prettyLoose = `${collectionName} - ${modeName}`;\n    const legacy1 = `${collectionName}_mode=${modeName}`;\n    const legacy2 = `${collectionName}/mode=${modeName}`;\n    const legacy3 = safeKeyFromCollectionAndMode(collectionName, modeName);\n\n    let picked = per.files.find((f) => {\n        const n = String(f?.name || \"\");\n        return (\n            n === prettyExact ||\n            n === prettyLoose ||\n            n.includes(`${collectionName} - ${modeName}`)\n        );\n    });\n    if (!picked) {\n        picked = per.files.find((f) => {\n            const n = String(f?.name || \"\");\n            return (\n                n.includes(legacy1) ||\n                n.includes(legacy2) ||\n                n.includes(legacy3)\n            );\n        });\n    }\n\n    const filesToSend = picked ? [picked] : per.files;\n    if (!picked) {\n        send({\n            type: \"INFO\",\n            payload: {\n                message: `Export: pretty file not found for \"${collectionName}\" / \"${modeName}\". Falling back to all per-mode files.`,\n            },\n        });\n    }\n    send({ type: \"EXPORT_RESULT\", payload: { files: filesToSend } });\n}\n\n// Convert local text styles into typography tokens and surface the preview payload to the UI.\nasync function handleExportTypography(_msg: UiToPlugin): Promise<void> {\n    const result = await exportDtcg({ format: \"typography\" });\n    send({ type: \"EXPORT_RESULT\", payload: { files: result.files } });\n    if (result.files.length > 0) {\n        const first = result.files[0];\n        send({\n            type: \"W3C_PREVIEW\",\n            payload: { name: first.name, json: first.json },\n        });\n    }\n}\n\n// Persist the last selected collection/mode pair so the UI can restore the user's focus.\nasync function handleSaveLast(msg: UiToPlugin): Promise<void> {\n    const payload = (msg as MessageOfType<\"SAVE_LAST\">).payload;\n    if (\n        typeof payload.collection === \"string\" &&\n        typeof payload.mode === \"string\"\n    ) {\n        await figma.clientStorage.setAsync(\"lastSelection\", {\n            collection: payload.collection,\n            mode: payload.mode,\n        });\n    }\n}\n\n// Store persistent export preferences (currently the \"export all\" toggle).\nasync function handleSavePrefs(msg: UiToPlugin): Promise<void> {\n    const payload = (msg as MessageOfType<\"SAVE_PREFS\">).payload;\n    if (typeof payload.exportAll === \"boolean\") {\n        await figma.clientStorage.setAsync(\n            \"exportAllPref\",\n            !!payload.exportAll\n        );\n    }\n    if (typeof payload.styleDictionary === \"boolean\") {\n        await figma.clientStorage.setAsync(\n            \"styleDictionaryPref\",\n            !!payload.styleDictionary\n        );\n    }\n    if (typeof payload.flatTokens === \"boolean\") {\n        await figma.clientStorage.setAsync(\n            \"flatTokensPref\",\n            !!payload.flatTokens\n        );\n    }\n    if (typeof payload.allowHexStrings === \"boolean\") {\n        await figma.clientStorage.setAsync(\n            \"allowHexPref\",\n            !!payload.allowHexStrings\n        );\n    }\n    if (typeof payload.githubRememberToken === \"boolean\") {\n        const rememberPref = !!payload.githubRememberToken;\n        await figma.clientStorage.setAsync(\"githubRememberPref\", rememberPref);\n        if (!rememberPref) {\n            await figma.clientStorage\n                .deleteAsync(\"github_token_b64\")\n                .catch(() => {});\n        }\n    }\n}\n\n// Remember the iframe size so subsequent launches reopen with the user's preferred bounds.\nasync function handleUiResize(msg: UiToPlugin): Promise<void> {\n    const payload = (msg as MessageOfType<\"UI_RESIZE\">).payload;\n    const w = Math.max(720, Math.min(1600, Math.floor(payload.width)));\n    const h = Math.max(420, Math.min(1200, Math.floor(payload.height)));\n    figma.ui.resize(w, h);\n    try {\n        await figma.clientStorage.setAsync(\"uiSize\", { width: w, height: h });\n    } catch {\n        // Ignore storage errors - UI resize will still work even if we can't persist the size\n    }\n}\n\n// Respond to preview requests by exporting the closest match and pushing it to the W3C preview pane.\nasync function handlePreviewRequest(msg: UiToPlugin): Promise<void> {\n    const payload = (msg as MessageOfType<\"PREVIEW_REQUEST\">).payload;\n    const collectionName = payload.collection ? String(payload.collection) : \"\";\n    const modeName = payload.mode ? String(payload.mode) : \"\";\n    const styleDictionary = !!payload.styleDictionary;\n    const flatTokens = !!payload.flatTokens;\n\n    const per = await exportDtcg({\n        format: \"perMode\",\n        styleDictionary,\n        flatTokens,\n    });\n\n    const prettyExact = `${collectionName} - ${modeName}.json`;\n    const prettyLoose = `${collectionName} - ${modeName}`;\n    const legacy1 = `${collectionName}_mode=${modeName}`;\n    const legacy2 = `${collectionName}/mode=${modeName}`;\n    const legacy3 = safeKeyFromCollectionAndMode(collectionName, modeName);\n\n    const picked = per.files.find((f) => {\n        const n = String(f?.name || \"\");\n        return (\n            n === prettyExact ||\n            n === prettyLoose ||\n            n.includes(`${collectionName} - ${modeName}`)\n        );\n    }) ||\n        per.files.find((f) => {\n            const n = String(f?.name || \"\");\n            return (\n                n.includes(legacy1) ||\n                n.includes(legacy2) ||\n                n.includes(legacy3)\n            );\n        }) ||\n        per.files[0] || { name: \"tokens-empty.json\", json: {} };\n\n    send({\n        type: \"W3C_PREVIEW\",\n        payload: { name: picked.name, json: picked.json },\n    });\n}\n\nconst coreHandlers = new Map<UiToPlugin[\"type\"], Handler>([\n    [\"UI_READY\", handleUiReady],\n    [\"PING\", handlePing],\n    [\"FETCH_COLLECTIONS\", handleFetchCollections],\n    [\"IMPORT_DTCG\", handleImportDtcg],\n    [\"EXPORT_DTCG\", handleExportDtcg],\n    [\"EXPORT_TYPOGRAPHY\", handleExportTypography],\n    [\"SAVE_LAST\", handleSaveLast],\n    [\"SAVE_PREFS\", handleSavePrefs],\n    [\"UI_RESIZE\", handleUiResize],\n    [\"PREVIEW_REQUEST\", handlePreviewRequest],\n]);\n\nfigma.ui.onmessage = async (msg: UiToPlugin) => {\n    try {\n        const handler = coreHandlers.get(msg.type as UiToPlugin[\"type\"]);\n        if (handler) {\n            await handler(msg);\n            return;\n        }\n\n        if (await github.handle(msg)) return;\n    } catch (e) {\n        let message = \"Unknown error\";\n        if (e && (e as Error).message) message = (e as Error).message;\n        figma.notify(\"Plugin error: \" + message, { timeout: 4000 });\n        send({ type: \"ERROR\", payload: { message } });\n\n        console.error(e);\n    }\n};\n"],
  "mappings": "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",
  "names": ["figma", "clamp01", "e", "irPath", "ctx", "byCtx", "logInfo", "logWarn", "keysOf", "ctxKey", "ci", "e", "canonicalPath", "text", "sleep"]
}
