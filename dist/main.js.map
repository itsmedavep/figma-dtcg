{
  "version": 3,
  "sources": ["../src/app/collections.ts", "../src/core/normalize.ts", "../src/core/typography.ts", "../src/core/color.ts", "../src/adapters/dtcg-reader.ts", "../src/adapters/dtcg-writer.ts", "../src/core/figma-cache.ts", "../src/core/ir.ts", "../src/adapters/figma-reader.ts", "../src/adapters/figma-writer.ts", "../src/core/pipeline.ts", "../src/core/github/api.ts", "../src/app/github/folders.ts", "../src/app/github/filenames.ts", "../src/app/github/dispatcher.ts", "../src/app/main.ts"],
  "sourcesContent": ["// src/app/collections.ts\n// Helpers for enumerating variable collections and analyzing selection state.\n\nexport async function snapshotCollectionsForUi(): Promise<{\n  collections: Array<{\n    id: string;\n    name: string;\n    modes: Array<{ id: string; name: string }>;\n    variables: Array<{ id: string; name: string; type: string }>;\n  }>;\n  rawText: string;\n}> {\n  if (typeof figma.editorType !== 'string' || figma.editorType !== 'figma') {\n    return {\n      collections: [],\n      rawText:\n        'Variables API is not available in this editor.\\n' +\n        'Open a Figma Design file (not FigJam) and try again.'\n    };\n  }\n  if (\n    typeof figma.variables === 'undefined' ||\n    typeof figma.variables.getLocalVariableCollectionsAsync !== 'function' ||\n    typeof figma.variables.getVariableByIdAsync !== 'function'\n  ) {\n    return {\n      collections: [],\n      rawText:\n        'Variables API methods not found. Ensure your Figma version supports Variables and try again.'\n    };\n  }\n\n  const locals: VariableCollection[] = await figma.variables.getLocalVariableCollectionsAsync();\n\n  const out: Array<{\n    id: string;\n    name: string;\n    modes: Array<{ id: string; name: string }>;\n    variables: Array<{ id: string; name: string; type: string }>;\n  }> = [];\n  const rawLines: string[] = [];\n\n  for (let i = 0; i < locals.length; i++) {\n    const c = locals[i];\n    if (!c) continue;\n\n    const modes: Array<{ id: string; name: string }> = [];\n    for (let mi = 0; mi < c.modes.length; mi++) {\n      const m = c.modes[mi];\n      modes.push({ id: m.modeId, name: m.name });\n    }\n\n    const varsList: Array<{ id: string; name: string; type: string }> = [];\n    for (let vi = 0; vi < c.variableIds.length; vi++) {\n      const varId = c.variableIds[vi];\n      const v = await figma.variables.getVariableByIdAsync(varId);\n      if (!v) continue;\n      varsList.push({ id: v.id, name: v.name, type: v.resolvedType });\n    }\n\n    out.push({ id: c.id, name: c.name, modes: modes, variables: varsList });\n\n    rawLines.push('Collection: ' + c.name + ' (' + c.id + ')');\n    const modeNames: string[] = modes.map(m => m.name);\n    rawLines.push('  Modes: ' + (modeNames.length > 0 ? modeNames.join(', ') : '(none)'));\n    rawLines.push('  Variables (' + String(varsList.length) + '):');\n    for (let qi = 0; qi < varsList.length; qi++) {\n      rawLines.push('    - ' + varsList[qi].name + ' [' + varsList[qi].type + ']');\n    }\n    rawLines.push('');\n  }\n\n  if (out.length === 0) {\n    rawLines.push('No local Variable Collections found.');\n    rawLines.push('Create one in the Variables panel, then press Refresh.');\n  }\n\n  if (typeof figma.getLocalTextStyles === 'function') {\n    const textStyles = figma.getLocalTextStyles();\n    rawLines.push('');\n    rawLines.push('Text styles: ' + String(textStyles.length));\n    for (let si = 0; si < textStyles.length; si++) {\n      const style = textStyles[si];\n      rawLines.push('  - ' + style.name);\n    }\n    if (textStyles.length === 0) {\n      rawLines.push('  (No local text styles found.)');\n    }\n  }\n\n  return { collections: out, rawText: rawLines.join('\\n') };\n}\n\nexport function safeKeyFromCollectionAndMode(collectionName: string, modeName: string): string {\n  const base = collectionName + '/mode=' + modeName;\n  let out = '';\n  for (let i = 0; i < base.length; i++) {\n    const ch = base.charAt(i);\n    out += (ch === '/' || ch === '\\\\' || ch === ':') ? '_' : ch;\n  }\n  return out;\n}\n\nexport async function analyzeSelectionState(collectionName: string, modeName: string): Promise<{\n  ok: boolean;\n  message?: string;\n  variableCount?: number;\n  variablesWithValues?: number;\n}> {\n  try {\n    const snap = await snapshotCollectionsForUi();\n    const col = snap.collections.find(c => c.name === collectionName);\n    if (!col) return { ok: false, message: `Collection \"${collectionName}\" not found in this file.` };\n    if (!col.variables || col.variables.length === 0) {\n      return { ok: false, message: `Collection \"${collectionName}\" has no local variables.` };\n    }\n    const mode = col.modes.find(m => m.name === modeName);\n    if (!mode) return { ok: false, message: `Mode \"${modeName}\" not found in collection \"${collectionName}\".` };\n\n    let withValues = 0;\n    for (const v of col.variables) {\n      const full = await figma.variables.getVariableByIdAsync(v.id);\n      if (full && full.valuesByMode && (mode.id in full.valuesByMode)) withValues++;\n    }\n    return { ok: true, variableCount: col.variables.length, variablesWithValues: withValues };\n  } catch (e) {\n    return { ok: false, message: (e as Error)?.message || 'Analysis failed' };\n  }\n}\n", "// src/core/normalize.ts\n// Shared helpers for names, paths, alias parsing, and graph checks.\n// - Normalizes paths so adapters stay in sync\n// - Provides alias analysis utilities for validation and exports\n\nimport type { TokenGraph, TokenNode, ValueOrAlias } from './ir';\n\n/* =========================\n   Naming & Path Utilities\n   ========================= */\n/** Slug a single path segment for lookup (never for emission). */\nexport function slugSegment(s: string): string {\n  return String(s)\n    .trim()\n    .replace(/\\s+/g, '-')  // collapse whitespace to '-'\n    .replace(/-+/g, '-')   // collapse runs of '-'\n    .toLowerCase();\n}\n\n/**\n * Return a canonical token path using Figma's display names.\n * Always splits variable names on '/', trims segments, and removes empties.\n */\nexport function canonicalPath(collection: string, variableName: string): string[] {\n  const segs = String(variableName)\n    .split('/')\n    .map(s => s.trim())\n    .filter(Boolean);\n  return [collection, ...segs];\n}\n\nexport function toDot(path: string[]): string {\n  var i = 0, s = '';\n  for (i = 0; i < path.length; i++) {\n    if (i > 0) s += '.';\n    s += path[i];\n  }\n  return s;\n}\n\nexport function toAliasString(path: string[]): string {\n  return '{' + toDot(path) + '}';\n}\n\nexport function parseAliasString(s: string): string[] | null {\n  if (typeof s !== 'string') return null;\n  if (s.length < 3) return null;\n  if (s.charAt(0) !== '{' || s.charAt(s.length - 1) !== '}') return null;\n  var inner = s.substring(1, s.length - 1);\n  if (!inner) return null;\n  return inner.split('.');\n}\n\n/* =========================\n   Graph Utilities\n   ========================= */\n\n/**\n * Deduplicate tokens by slash path and sort them for stable comparisons.\n * Keeps adapters from reordering content across reads/writes.\n */\nexport function normalize(graph: TokenGraph): TokenGraph {\n  var seen: { [k: string]: 1 } = {};\n  var copy: TokenNode[] = [];\n  var i = 0;\n  for (i = 0; i < graph.tokens.length; i++) {\n    var t = graph.tokens[i];\n    var key = slashPath(t.path);\n    if (!seen[key]) {\n      seen[key] = 1;\n      copy.push(t);\n    }\n  }\n  copy.sort(function (a, b) {\n    var da = toDot(a.path);\n    var db = toDot(b.path);\n    if (da < db) return -1;\n    if (da > db) return 1;\n    return 0;\n  });\n  return { tokens: copy };\n}\n\nfunction slashPath(path: string[]): string {\n  var i = 0, s = '';\n  for (i = 0; i < path.length; i++) {\n    if (i > 0) s += '/';\n    s += path[i];\n  }\n  return s;\n}\n\n/** Build a dot-path index for quick alias resolution. */\nexport function indexByDotPath(graph: TokenGraph): { [dot: string]: TokenNode } {\n  var idx: { [dot: string]: TokenNode } = {};\n  var i = 0;\n  for (i = 0; i < graph.tokens.length; i++) {\n    var t = graph.tokens[i];\n    idx[toDot(t.path)] = t;\n  }\n  return idx;\n}\n\n/** Type guard: true if the value is an alias entry. */\nexport function isAlias(v: ValueOrAlias): v is { kind: 'alias'; path: string[] } {\n  return !!v && v.kind === 'alias';\n}\n\n/**\n * Walk alias edges to find missing references and cycles.\n * Useful for validation before exporting or writing to Figma.\n */\nexport function analyzeAliases(graph: TokenGraph): { missing: string[]; cycles: string[][] } {\n  var idx = indexByDotPath(graph);\n  var edges: { [from: string]: string[] } = {};\n  var nodes: string[] = [];\n\n  var i = 0;\n  for (i = 0; i < graph.tokens.length; i++) {\n    var t = graph.tokens[i];\n    var from = toDot(t.path);\n    nodes.push(from);\n    edges[from] = [];\n    var ctxKeys = keysOf(t.byContext);\n    var k = 0;\n    for (k = 0; k < ctxKeys.length; k++) {\n      var ctx = ctxKeys[k];\n      var val = t.byContext[ctx];\n      if (isAlias(val)) {\n        var to = toDot(val.path);\n        edges[from].push(to);\n      }\n    }\n  }\n\n  var missing: string[] = [];\n  var u = 0;\n  for (u = 0; u < nodes.length; u++) {\n    var n = nodes[u];\n    var outs = edges[n];\n    var j = 0;\n    for (j = 0; j < outs.length; j++) {\n      var target = outs[j];\n      if (!idx[target]) {\n        var seen = false;\n        var m = 0;\n        for (m = 0; m < missing.length; m++) if (missing[m] === target) { seen = true; break; }\n        if (!seen) missing.push(target);\n      }\n    }\n  }\n\n  var WHITE = 0, GRAY = 1, BLACK = 2;\n  var color: { [node: string]: number } = {};\n  for (u = 0; u < nodes.length; u++) color[nodes[u]] = WHITE;\n\n  var cycles: string[][] = [];\n\n  function dfs(start: string, stack: string[]): boolean {\n    color[start] = GRAY;\n    stack.push(start);\n    var arr = edges[start];\n    var p = 0;\n    for (p = 0; p < arr.length; p++) {\n      var v = arr[p];\n      if (color[v] === WHITE) {\n        if (dfs(v, stack)) return true;\n      } else if (color[v] === GRAY) {\n        var ci = stack.length - 1;\n        var cyc: string[] = [];\n        while (ci >= 0 && stack[ci] !== v) { ci--; }\n        if (ci >= 0) {\n          var w = ci;\n          for (w = ci; w < stack.length; w++) cyc.push(stack[w]);\n          cyc.push(v);\n        }\n        cycles.push(cyc);\n        return true;\n      }\n    }\n    stack.pop();\n    color[start] = BLACK;\n    return false;\n  }\n\n  for (u = 0; u < nodes.length; u++) {\n    var node = nodes[u];\n    if (color[node] === WHITE) {\n      var stack: string[] = [];\n      dfs(node, stack);\n    }\n  }\n\n  return { missing: missing, cycles: cycles };\n}\n\nfunction keysOf<T>(obj: { [k: string]: T }): string[] {\n  var keys: string[] = [];\n  var k: string;\n  for (k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) keys.push(k);\n  return keys;\n}\n", "// src/core/typography.ts\n// Shared helpers for representing typography tokens and converting Figma text styles.\n\nexport type DimensionUnit = 'pixel' | 'percent';\n\nexport interface DimensionValue {\n  value: number;\n  unit: DimensionUnit;\n}\n\ntype SerializedDimensionUnit = 'px' | 'percent';\n\ninterface SerializedDimensionValue {\n  value: number;\n  unit: SerializedDimensionUnit;\n}\n\nexport type LineHeightValue = DimensionValue | 'auto';\n\nexport type FigmaDimensionUnit = 'PIXELS' | 'PERCENT';\n\nexport interface FigmaDimensionValue {\n  value: number;\n  unit: FigmaDimensionUnit;\n}\n\nexport type FigmaLineHeightValue =\n  | { unit: 'AUTO' }\n  | { unit: FigmaDimensionUnit; value: number };\n\nexport interface TypographyFigmaExtension {\n  fontStyle?: string;\n  fontVariant?: string;\n  letterSpacing?: FigmaDimensionValue;\n  lineHeight?: FigmaLineHeightValue;\n  paragraphSpacing?: number;\n  paragraphIndent?: number;\n  listSpacing?: number;\n  hangingPunctuation?: boolean;\n  hangingList?: boolean;\n  leadingTrim?: unknown;\n  textCase?: string;\n  textDecoration?: string;\n  textAlignHorizontal?: string;\n  textAlignVertical?: string;\n  textAutoResize?: string;\n  fills?: unknown;\n  strokes?: unknown;\n  [key: string]: unknown;\n}\n\nexport interface TypographyValue {\n  fontFamily?: string;\n  fontStyle?: string;\n  fontWeight?: string;\n  fontSize?: DimensionValue;\n  lineHeight?: LineHeightValue;\n  letterSpacing?: DimensionValue;\n  paragraphSpacing?: DimensionValue;\n  paragraphIndent?: DimensionValue;\n  textCase?: string;\n  textDecoration?: string;\n  textAlignHorizontal?: string;\n  textAlignVertical?: string;\n  fontVariant?: string;\n  [key: string]: unknown;\n}\n\nexport interface TypographyFromTextStyleResult {\n  value: TypographyValue;\n  figma: TypographyFigmaExtension;\n}\n\nconst KNOWN_KEYS: { [k: string]: true } = {\n  fontFamily: true,\n  fontStyle: true,\n  fontWeight: true,\n  fontSize: true,\n  lineHeight: true,\n  letterSpacing: true,\n  paragraphSpacing: true,\n  paragraphIndent: true,\n  textCase: true,\n  textDecoration: true,\n  textAlignHorizontal: true,\n  textAlignVertical: true,\n  fontVariant: true,\n};\n\nfunction isFiniteNumber(v: unknown): v is number {\n  return typeof v === 'number' && isFinite(v);\n}\n\nfunction normalizeUnit(raw: unknown): DimensionUnit | null {\n  if (typeof raw !== 'string') return null;\n  const lower = raw.trim().toLowerCase();\n  if (lower === 'pixel' || lower === 'pixels' || lower === 'px') return 'pixel';\n  if (lower === 'percent' || lower === 'percentage' || lower === '%') return 'percent';\n  return null;\n}\n\nfunction parseDimension(raw: unknown): DimensionValue | null {\n  if (!raw || typeof raw !== 'object') return null;\n  const obj = raw as Record<string, unknown>;\n  const value = obj.value;\n  const unit = normalizeUnit(obj.unit);\n  if (!isFiniteNumber(value) || !unit) return null;\n  return { value, unit };\n}\n\nfunction parsePixelDimension(raw: unknown): DimensionValue | null {\n  if (raw && typeof raw === 'object' && !Array.isArray(raw)) {\n    return parseDimension(raw);\n  }\n  if (isFiniteNumber(raw)) {\n    return { value: raw, unit: 'pixel' };\n  }\n  return null;\n}\n\n// Parse a JSON-friendly payload into the normalized typography value shape expected by the pipeline.\nexport function parseTypographyValue(raw: unknown): TypographyValue | null {\n  if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return null;\n  const obj = raw as Record<string, unknown>;\n  const value: TypographyValue = {};\n  let recognized = false;\n\n  if (typeof obj.fontFamily === 'string' && obj.fontFamily.trim().length > 0) {\n    value.fontFamily = obj.fontFamily;\n    recognized = true;\n  }\n  if (typeof obj.fontStyle === 'string' && obj.fontStyle.trim().length > 0) {\n    value.fontStyle = obj.fontStyle;\n    recognized = true;\n  }\n  if (typeof obj.fontWeight === 'string' && obj.fontWeight.trim().length > 0) {\n    value.fontWeight = obj.fontWeight;\n    recognized = true;\n  }\n  if (typeof obj.fontVariant === 'string' && obj.fontVariant.trim().length > 0) {\n    value.fontVariant = obj.fontVariant;\n    recognized = true;\n  }\n\n  const fontSize = parseDimension(obj.fontSize);\n  if (fontSize) {\n    value.fontSize = fontSize;\n    recognized = true;\n  }\n\n  const rawLineHeight = obj.lineHeight;\n  if (typeof rawLineHeight === 'number') {\n    if (isFiniteNumber(rawLineHeight)) {\n      value.lineHeight = { value: rawLineHeight * 100, unit: 'percent' };\n      recognized = true;\n    }\n  } else if (typeof rawLineHeight === 'string') {\n    if (rawLineHeight.trim().toLowerCase() === 'auto') {\n      value.lineHeight = 'auto';\n      recognized = true;\n    }\n  } else {\n    const lineHeight = parseDimension(rawLineHeight);\n    if (lineHeight) {\n      value.lineHeight = lineHeight;\n      recognized = true;\n    }\n  }\n\n  const letterSpacing = parseDimension(obj.letterSpacing);\n  if (letterSpacing) {\n    value.letterSpacing = letterSpacing;\n    recognized = true;\n  }\n\n  const paragraphSpacing = parsePixelDimension(obj.paragraphSpacing);\n  if (paragraphSpacing) {\n    value.paragraphSpacing = paragraphSpacing;\n    recognized = true;\n  }\n\n  const paragraphIndent = parsePixelDimension(obj.paragraphIndent);\n  if (paragraphIndent) {\n    value.paragraphIndent = paragraphIndent;\n    recognized = true;\n  }\n\n  if (typeof obj.textCase === 'string' && obj.textCase.trim().length > 0) {\n    value.textCase = obj.textCase;\n    recognized = true;\n  }\n\n  if (typeof obj.textDecoration === 'string' && obj.textDecoration.trim().length > 0) {\n    value.textDecoration = obj.textDecoration;\n    recognized = true;\n  }\n\n  if (typeof obj.textAlignHorizontal === 'string' && obj.textAlignHorizontal.trim().length > 0) {\n    value.textAlignHorizontal = obj.textAlignHorizontal;\n    recognized = true;\n  }\n\n  if (typeof obj.textAlignVertical === 'string' && obj.textAlignVertical.trim().length > 0) {\n    value.textAlignVertical = obj.textAlignVertical;\n    recognized = true;\n  }\n\n  // Preserve additional custom fields to avoid data loss.\n  for (const key of Object.keys(obj)) {\n    if (KNOWN_KEYS[key]) continue;\n    const v = obj[key];\n    if (typeof v === 'undefined') continue;\n    (value as Record<string, unknown>)[key] = v;\n  }\n\n  return recognized ? value : null;\n}\n\nfunction normalizeLetterSpacingForSerialization(\n  letterSpacing: DimensionValue | undefined,\n  fontSizePx: number | undefined\n): SerializedDimensionValue | undefined {\n  if (!letterSpacing) return undefined;\n  if (letterSpacing.unit === 'pixel') {\n    return { value: letterSpacing.value, unit: 'px' };\n  }\n  if (letterSpacing.unit === 'percent' && typeof fontSizePx === 'number') {\n    return { value: (letterSpacing.value / 100) * fontSizePx, unit: 'px' };\n  }\n  return undefined;\n}\n\nfunction normalizeLineHeightForSerialization(\n  lineHeight: LineHeightValue | undefined,\n  fontSizePx: number | undefined\n): number | 'auto' | undefined {\n  if (!lineHeight) return undefined;\n  if (lineHeight === 'auto') return 'auto';\n  if (lineHeight.unit === 'percent') {\n    return lineHeight.value / 100;\n  }\n  if (lineHeight.unit === 'pixel' && typeof fontSizePx === 'number' && fontSizePx !== 0) {\n    return lineHeight.value / fontSizePx;\n  }\n  return undefined;\n}\n\n// Convert a normalized typography value into a DTCG-compliant fragment for export.\nexport function serializeTypographyValue(value: TypographyValue): Record<string, unknown> {\n  const out: Record<string, unknown> = {};\n\n  if (typeof value.fontFamily === 'string') out.fontFamily = value.fontFamily;\n  if (typeof value.fontWeight === 'string') out.fontWeight = value.fontWeight;\n\n  const fontSizePx = ((): number | undefined => {\n    if (!value.fontSize) return undefined;\n    if (value.fontSize.unit === 'pixel') {\n      const serialized: SerializedDimensionValue = { value: value.fontSize.value, unit: 'px' };\n      out.fontSize = serialized;\n      return value.fontSize.value;\n    }\n    return undefined;\n  })();\n\n  const normalizedLetterSpacing = normalizeLetterSpacingForSerialization(value.letterSpacing, fontSizePx);\n  if (normalizedLetterSpacing) {\n    out.letterSpacing = normalizedLetterSpacing;\n  }\n\n  const normalizedLineHeight = normalizeLineHeightForSerialization(value.lineHeight, fontSizePx);\n  if (typeof normalizedLineHeight !== 'undefined') {\n    out.lineHeight = normalizedLineHeight;\n  }\n\n  return out;\n}\n\nfunction cloneDimensionIfFinite(num: number | undefined): DimensionValue | undefined {\n  if (!isFiniteNumber(num)) return undefined;\n  return { value: num, unit: 'pixel' };\n}\n\nconst TEXT_CASE_MAP: { [key: string]: string } = {\n  ORIGINAL: 'none',\n  UPPER: 'uppercase',\n  LOWER: 'lowercase',\n  TITLE: 'capitalize',\n  SMALL_CAPS: 'smallCaps',\n  SMALL_CAPS_FORCED: 'smallCapsForced',\n};\n\nconst TEXT_DECORATION_MAP: { [key: string]: string } = {\n  NONE: 'none',\n  UNDERLINE: 'underline',\n  STRIKETHROUGH: 'lineThrough',\n};\n\nconst TEXT_ALIGN_HORIZONTAL_MAP: { [key: string]: string } = {\n  LEFT: 'left',\n  RIGHT: 'right',\n  CENTER: 'center',\n  JUSTIFIED: 'justify',\n};\n\nconst TEXT_ALIGN_VERTICAL_MAP: { [key: string]: string } = {\n  TOP: 'top',\n  CENTER: 'center',\n  BOTTOM: 'bottom',\n};\n\nfunction inferFontStyle(style: string | undefined): string | undefined {\n  if (!style) return undefined;\n  const lower = style.trim().toLowerCase();\n  if (lower.includes('italic') || lower.includes('oblique')) return 'italic';\n  return 'normal';\n}\n\n// Read a Figma text style and produce the token value plus the Figma-specific extension metadata.\nexport function typographyValueFromTextStyle(style: TextStyle): TypographyFromTextStyleResult {\n  const value: TypographyValue = {};\n  const figma: TypographyFigmaExtension = {};\n\n  const assignFigma = <K extends keyof TypographyFigmaExtension>(\n    key: K,\n    val: TypographyFigmaExtension[K]\n  ): void => {\n    if (typeof val === 'undefined') return;\n    figma[key] = val;\n  };\n\n  const fontName = style.fontName as { family?: string; style?: string } | undefined;\n  if (fontName && typeof fontName.family === 'string') {\n    value.fontFamily = fontName.family;\n  }\n  if (fontName && typeof fontName.style === 'string') {\n    value.fontWeight = fontName.style;\n    value.fontVariant = fontName.style;\n    value.fontStyle = inferFontStyle(fontName.style);\n    assignFigma('fontVariant', fontName.style);\n    assignFigma('fontStyle', fontName.style);\n  }\n\n  if (isFiniteNumber(style.fontSize)) {\n    value.fontSize = { value: style.fontSize, unit: 'pixel' };\n  }\n\n  const lineHeight = style.lineHeight as { unit?: string; value?: number } | undefined;\n  if (lineHeight && typeof lineHeight.unit === 'string') {\n    const unit = lineHeight.unit;\n    if (unit === 'AUTO') {\n      value.lineHeight = 'auto';\n      assignFigma('lineHeight', { unit: 'AUTO' });\n    } else if (unit === 'PIXELS' && isFiniteNumber(lineHeight.value)) {\n      value.lineHeight = { value: lineHeight.value, unit: 'pixel' };\n      assignFigma('lineHeight', { unit: 'PIXELS', value: lineHeight.value });\n    } else if (unit === 'PERCENT' && isFiniteNumber(lineHeight.value)) {\n      value.lineHeight = { value: lineHeight.value, unit: 'percent' };\n      assignFigma('lineHeight', { unit: 'PERCENT', value: lineHeight.value });\n    }\n  }\n\n  const letterSpacing = style.letterSpacing as { unit?: string; value?: number } | undefined;\n  if (letterSpacing && typeof letterSpacing.unit === 'string' && isFiniteNumber(letterSpacing.value)) {\n    if (letterSpacing.unit === 'PIXELS') {\n      value.letterSpacing = { value: letterSpacing.value, unit: 'pixel' };\n      assignFigma('letterSpacing', { unit: 'PIXELS', value: letterSpacing.value });\n    } else if (letterSpacing.unit === 'PERCENT') {\n      value.letterSpacing = { value: letterSpacing.value, unit: 'percent' };\n      assignFigma('letterSpacing', { unit: 'PERCENT', value: letterSpacing.value });\n    }\n  }\n\n  const paragraphSpacing = cloneDimensionIfFinite(style.paragraphSpacing);\n  if (paragraphSpacing) {\n    value.paragraphSpacing = paragraphSpacing;\n    assignFigma('paragraphSpacing', paragraphSpacing.value);\n  }\n\n  const paragraphIndent = cloneDimensionIfFinite(style.paragraphIndent);\n  if (paragraphIndent) {\n    value.paragraphIndent = paragraphIndent;\n    assignFigma('paragraphIndent', paragraphIndent.value);\n  }\n\n  const textCase = (style as { textCase?: string }).textCase;\n  if (textCase && typeof textCase === 'string') {\n    value.textCase = TEXT_CASE_MAP[textCase] || textCase.toLowerCase();\n    assignFigma('textCase', textCase);\n  }\n\n  const textDecoration = (style as { textDecoration?: string }).textDecoration;\n  if (textDecoration && typeof textDecoration === 'string') {\n    value.textDecoration = TEXT_DECORATION_MAP[textDecoration] || textDecoration.toLowerCase();\n    assignFigma('textDecoration', textDecoration);\n  }\n\n  const textAlignHorizontal = (style as { textAlignHorizontal?: string }).textAlignHorizontal;\n  if (textAlignHorizontal && typeof textAlignHorizontal === 'string') {\n    value.textAlignHorizontal = TEXT_ALIGN_HORIZONTAL_MAP[textAlignHorizontal] || textAlignHorizontal.toLowerCase();\n    assignFigma('textAlignHorizontal', textAlignHorizontal);\n  }\n\n  const textAlignVertical = (style as { textAlignVertical?: string }).textAlignVertical;\n  if (textAlignVertical && typeof textAlignVertical === 'string') {\n    value.textAlignVertical = TEXT_ALIGN_VERTICAL_MAP[textAlignVertical] || textAlignVertical.toLowerCase();\n    assignFigma('textAlignVertical', textAlignVertical);\n  }\n\n  const leadingTrim = (style as { leadingTrim?: unknown }).leadingTrim;\n  if (typeof leadingTrim !== 'undefined') assignFigma('leadingTrim', leadingTrim);\n\n  const listSpacing = (style as { listSpacing?: number }).listSpacing;\n  if (isFiniteNumber(listSpacing)) assignFigma('listSpacing', listSpacing);\n\n  const hangingPunctuation = (style as { hangingPunctuation?: boolean }).hangingPunctuation;\n  if (typeof hangingPunctuation === 'boolean') assignFigma('hangingPunctuation', hangingPunctuation);\n\n  const hangingList = (style as { hangingList?: boolean }).hangingList;\n  if (typeof hangingList === 'boolean') assignFigma('hangingList', hangingList);\n\n  const textAutoResize = (style as { textAutoResize?: string }).textAutoResize;\n  if (typeof textAutoResize === 'string') assignFigma('textAutoResize', textAutoResize);\n\n  const fills = (style as { fills?: unknown }).fills;\n  if (typeof fills !== 'undefined') assignFigma('fills', fills);\n\n  const strokes = (style as { strokes?: unknown }).strokes;\n  if (typeof strokes !== 'undefined') assignFigma('strokes', strokes);\n\n  // Drop undefined entries to keep payload compact.\n  const cleaned: TypographyValue = {};\n  for (const key of Object.keys(value)) {\n    const v = (value as Record<string, unknown>)[key];\n    if (typeof v === 'undefined') continue;\n    cleaned[key] = v;\n  }\n\n  return { value: cleaned, figma };\n}\n\nfunction normalizeFontVariantName(style: string | undefined): string | null {\n  if (typeof style !== 'string') return null;\n  const trimmed = style.trim();\n  if (!trimmed) return null;\n  const lower = trimmed.toLowerCase();\n  if (lower === 'italic') return 'Italic';\n  if (lower === 'normal') return 'Regular';\n  if (lower === 'oblique') return 'Oblique';\n  return trimmed;\n}\n\nexport interface TypographyFontNameResult {\n  fontName: FontName | null;\n  usedFallback: boolean;\n}\n\nexport function typographyFontNameFromValue(value: TypographyValue): TypographyFontNameResult {\n  const family = typeof value.fontFamily === 'string' ? value.fontFamily.trim() : '';\n  if (!family) {\n    return { fontName: null, usedFallback: false };\n  }\n\n  const candidates: (string | null | undefined)[] = [\n    value.fontVariant,\n    value.fontWeight,\n    normalizeFontVariantName(value.fontStyle),\n  ];\n\n  for (const cand of candidates) {\n    if (typeof cand !== 'string') continue;\n    const trimmed = cand.trim();\n    if (trimmed.length === 0) continue;\n    return { fontName: { family, style: trimmed }, usedFallback: false };\n  }\n\n  return { fontName: { family, style: 'Regular' }, usedFallback: true };\n}\n\nfunction normalizeKey(raw: string | undefined): string | null {\n  if (typeof raw !== 'string') return null;\n  const trimmed = raw.trim();\n  if (!trimmed) return null;\n  return trimmed.toLowerCase();\n}\n\nconst TEXT_CASE_REVERSE_MAP: { [key: string]: TextCase } = {\n  none: 'ORIGINAL',\n  original: 'ORIGINAL',\n  uppercase: 'UPPER',\n  upper: 'UPPER',\n  lowercase: 'LOWER',\n  lower: 'LOWER',\n  capitalize: 'TITLE',\n  title: 'TITLE',\n  smallcaps: 'SMALL_CAPS',\n  'small-caps': 'SMALL_CAPS',\n  smallcapsforced: 'SMALL_CAPS_FORCED',\n  'small-caps-forced': 'SMALL_CAPS_FORCED',\n};\n\nconst TEXT_DECORATION_REVERSE_MAP: { [key: string]: TextDecoration } = {\n  none: 'NONE',\n  underline: 'UNDERLINE',\n  strikethrough: 'STRIKETHROUGH',\n  'strike-through': 'STRIKETHROUGH',\n  linethrough: 'STRIKETHROUGH',\n  'line-through': 'STRIKETHROUGH',\n};\n\ntype FigmaTextAlignHorizontal = 'LEFT' | 'CENTER' | 'RIGHT' | 'JUSTIFIED';\ntype FigmaTextAlignVertical = 'TOP' | 'CENTER' | 'BOTTOM';\n\nconst TEXT_ALIGN_HORIZONTAL_REVERSE_MAP: { [key: string]: FigmaTextAlignHorizontal } = {\n  left: 'LEFT',\n  right: 'RIGHT',\n  center: 'CENTER',\n  justify: 'JUSTIFIED',\n  justified: 'JUSTIFIED',\n};\n\nconst TEXT_ALIGN_VERTICAL_REVERSE_MAP: { [key: string]: FigmaTextAlignVertical } = {\n  top: 'TOP',\n  center: 'CENTER',\n  middle: 'CENTER',\n  bottom: 'BOTTOM',\n};\n\nfunction mapTextCaseToFigma(raw: string | undefined): TextCase | null {\n  const key = normalizeKey(raw);\n  if (!key) return null;\n  return TEXT_CASE_REVERSE_MAP[key] || null;\n}\n\nfunction mapTextDecorationToFigma(raw: string | undefined): TextDecoration | null {\n  const key = normalizeKey(raw);\n  if (!key) return null;\n  return TEXT_DECORATION_REVERSE_MAP[key] || null;\n}\n\nfunction mapTextAlignHorizontalToFigma(raw: string | undefined): FigmaTextAlignHorizontal | null {\n  const key = normalizeKey(raw);\n  if (!key) return null;\n  return TEXT_ALIGN_HORIZONTAL_REVERSE_MAP[key] || null;\n}\n\nfunction mapTextAlignVerticalToFigma(raw: string | undefined): FigmaTextAlignVertical | null {\n  const key = normalizeKey(raw);\n  if (!key) return null;\n  return TEXT_ALIGN_VERTICAL_REVERSE_MAP[key] || null;\n}\n\n// Apply a typography token to a Figma text style, returning warnings when values require manual follow-up.\nexport function applyTypographyValueToTextStyle(\n  style: TextStyle,\n  value: TypographyValue,\n  opts?: { fontName?: FontName | null; figma?: TypographyFigmaExtension | null }\n): string[] {\n  const warnings: string[] = [];\n\n  if (opts && opts.fontName) {\n    style.fontName = opts.fontName;\n  }\n\n  const figmaExt = opts && opts.figma ? opts.figma : null;\n\n  if (value.fontSize) {\n    if (value.fontSize.unit === 'pixel') {\n      style.fontSize = value.fontSize.value;\n    } else {\n      warnings.push(`fontSize unit \u201C${value.fontSize.unit}\u201D is not supported. Expected \"pixel\".`);\n    }\n  }\n\n  const extLineHeight = figmaExt?.lineHeight;\n  style.lineHeight = { unit: 'AUTO' };\n  if (extLineHeight) {\n    if (extLineHeight.unit === 'AUTO') {\n      style.lineHeight = { unit: 'AUTO' };\n    } else if (\n      (extLineHeight.unit === 'PIXELS' || extLineHeight.unit === 'PERCENT') &&\n      isFiniteNumber(extLineHeight.value)\n    ) {\n      style.lineHeight = { unit: extLineHeight.unit, value: extLineHeight.value } as {\n        unit: 'PIXELS' | 'PERCENT';\n        value: number;\n      };\n    }\n  } else if (value.lineHeight) {\n    if (value.lineHeight === 'auto') {\n      style.lineHeight = { unit: 'AUTO' };\n    } else if (value.lineHeight.unit === 'pixel') {\n      style.lineHeight = { unit: 'PIXELS', value: value.lineHeight.value };\n    } else if (value.lineHeight.unit === 'percent') {\n      style.lineHeight = { unit: 'PERCENT', value: value.lineHeight.value };\n    } else {\n      warnings.push(`lineHeight unit \u201C${(value.lineHeight as DimensionValue).unit}\u201D is not supported.`);\n    }\n  }\n\n  const extLetterSpacing = figmaExt?.letterSpacing;\n  style.letterSpacing = { unit: 'PERCENT', value: 0 };\n  if (extLetterSpacing) {\n    if (\n      (extLetterSpacing.unit === 'PIXELS' || extLetterSpacing.unit === 'PERCENT') &&\n      isFiniteNumber(extLetterSpacing.value)\n    ) {\n      style.letterSpacing = { unit: extLetterSpacing.unit, value: extLetterSpacing.value };\n    }\n  } else if (value.letterSpacing) {\n    if (value.letterSpacing.unit === 'pixel') {\n      style.letterSpacing = { unit: 'PIXELS', value: value.letterSpacing.value };\n    } else if (value.letterSpacing.unit === 'percent') {\n      style.letterSpacing = { unit: 'PERCENT', value: value.letterSpacing.value };\n    } else {\n      warnings.push(`letterSpacing unit \u201C${value.letterSpacing.unit}\u201D is not supported.`);\n    }\n  }\n\n  style.paragraphSpacing = 0;\n  if (figmaExt && isFiniteNumber(figmaExt.paragraphSpacing)) {\n    style.paragraphSpacing = figmaExt.paragraphSpacing;\n  } else if (value.paragraphSpacing) {\n    if (value.paragraphSpacing.unit === 'pixel') {\n      style.paragraphSpacing = value.paragraphSpacing.value;\n    } else {\n      warnings.push(`paragraphSpacing unit \u201C${value.paragraphSpacing.unit}\u201D is not supported. Expected \"pixel\".`);\n    }\n  }\n\n  style.paragraphIndent = 0;\n  if (figmaExt && isFiniteNumber(figmaExt.paragraphIndent)) {\n    style.paragraphIndent = figmaExt.paragraphIndent;\n  } else if (value.paragraphIndent) {\n    if (value.paragraphIndent.unit === 'pixel') {\n      style.paragraphIndent = value.paragraphIndent.value;\n    } else {\n      warnings.push(`paragraphIndent unit \u201C${value.paragraphIndent.unit}\u201D is not supported. Expected \"pixel\".`);\n    }\n  }\n\n  if (figmaExt && typeof figmaExt.textCase === 'string') {\n    try { style.textCase = figmaExt.textCase as TextCase; } catch { /* ignore */ }\n  } else {\n    const textCase = mapTextCaseToFigma(value.textCase);\n    if (textCase) {\n      style.textCase = textCase;\n    } else {\n      if (value.textCase) warnings.push(`textCase \u201C${value.textCase}\u201D is not recognized. Using default.`);\n      style.textCase = 'ORIGINAL';\n    }\n  }\n\n  if (figmaExt && typeof figmaExt.textDecoration === 'string') {\n    try { style.textDecoration = figmaExt.textDecoration as TextDecoration; } catch { /* ignore */ }\n  } else {\n    const textDecoration = mapTextDecorationToFigma(value.textDecoration);\n    if (textDecoration) {\n      style.textDecoration = textDecoration;\n    } else {\n      if (value.textDecoration) warnings.push(`textDecoration \u201C${value.textDecoration}\u201D is not recognized. Using default.`);\n      style.textDecoration = 'NONE';\n    }\n  }\n\n  const anyStyle = style as any;\n  const supportsTextAlignHorizontal = typeof anyStyle.textAlignHorizontal !== 'undefined';\n  const extTextAlignHorizontal = figmaExt && typeof figmaExt.textAlignHorizontal === 'string'\n    ? (figmaExt.textAlignHorizontal as FigmaTextAlignHorizontal)\n    : null;\n  if (extTextAlignHorizontal) {\n    if (supportsTextAlignHorizontal) {\n      try { anyStyle.textAlignHorizontal = extTextAlignHorizontal; } catch { /* ignore */ }\n    } else {\n      warnings.push('textAlignHorizontal is not supported for text styles in this version of Figma.');\n    }\n  } else {\n    const textAlignHorizontal = mapTextAlignHorizontalToFigma(value.textAlignHorizontal);\n    if (textAlignHorizontal) {\n      if (supportsTextAlignHorizontal) {\n        try { anyStyle.textAlignHorizontal = textAlignHorizontal; } catch { /* ignore */ }\n      } else {\n        warnings.push('textAlignHorizontal is not supported for text styles in this version of Figma.');\n      }\n    } else if (value.textAlignHorizontal) {\n      warnings.push(`textAlignHorizontal \u201C${value.textAlignHorizontal}\u201D is not recognized. Using default.`);\n    } else if (supportsTextAlignHorizontal) {\n      try { anyStyle.textAlignHorizontal = 'LEFT'; } catch { /* ignore */ }\n    }\n  }\n\n  const supportsTextAlignVertical = typeof anyStyle.textAlignVertical !== 'undefined';\n  const extTextAlignVertical = figmaExt && typeof figmaExt.textAlignVertical === 'string'\n    ? (figmaExt.textAlignVertical as FigmaTextAlignVertical)\n    : null;\n  if (extTextAlignVertical) {\n    if (supportsTextAlignVertical) {\n      try { anyStyle.textAlignVertical = extTextAlignVertical; } catch { /* ignore */ }\n    } else {\n      warnings.push('textAlignVertical is not supported for text styles in this version of Figma.');\n    }\n  } else {\n    const textAlignVertical = mapTextAlignVerticalToFigma(value.textAlignVertical);\n    if (textAlignVertical) {\n      if (supportsTextAlignVertical) {\n        try { anyStyle.textAlignVertical = textAlignVertical; } catch { /* ignore */ }\n      } else {\n        warnings.push('textAlignVertical is not supported for text styles in this version of Figma.');\n      }\n    } else if (value.textAlignVertical) {\n      warnings.push(`textAlignVertical \u201C${value.textAlignVertical}\u201D is not recognized. Using default.`);\n    } else if (supportsTextAlignVertical) {\n      try { anyStyle.textAlignVertical = 'TOP'; } catch { /* ignore */ }\n    }\n  }\n\n  if (figmaExt) {\n    if (isFiniteNumber(figmaExt.listSpacing) && typeof anyStyle.listSpacing !== 'undefined') {\n      try { anyStyle.listSpacing = figmaExt.listSpacing; } catch { /* ignore */ }\n    }\n    if (typeof figmaExt.hangingPunctuation === 'boolean' && typeof anyStyle.hangingPunctuation !== 'undefined') {\n      try { anyStyle.hangingPunctuation = figmaExt.hangingPunctuation; } catch { /* ignore */ }\n    }\n    if (typeof figmaExt.hangingList === 'boolean' && typeof anyStyle.hangingList !== 'undefined') {\n      try { anyStyle.hangingList = figmaExt.hangingList; } catch { /* ignore */ }\n    }\n    if (typeof figmaExt.leadingTrim !== 'undefined' && typeof anyStyle.leadingTrim !== 'undefined') {\n      try { anyStyle.leadingTrim = figmaExt.leadingTrim; } catch { /* ignore */ }\n    }\n    if (typeof figmaExt.textAutoResize === 'string' && typeof anyStyle.textAutoResize !== 'undefined') {\n      try { anyStyle.textAutoResize = figmaExt.textAutoResize; } catch { /* ignore */ }\n    }\n    if (typeof figmaExt.fills !== 'undefined' && typeof anyStyle.fills !== 'undefined') {\n      try { anyStyle.fills = figmaExt.fills; } catch { /* ignore */ }\n    }\n    if (typeof figmaExt.strokes !== 'undefined' && typeof anyStyle.strokes !== 'undefined') {\n      try { anyStyle.strokes = figmaExt.strokes; } catch { /* ignore */ }\n    }\n  }\n\n  return warnings;\n}\n", "// src/core/color.ts\n// Accurate, spec-aligned color handling for DTCG <-> Figma.\n// - Validates incoming data so we never write impossible color spaces\n// - Converts between srgb/display-p3 while keeping precision intact\n\nimport type { ColorValue } from './ir';\n\n// --- ADD: supported DTCG color spaces (limited to what we\u2019ll accept) ---\nexport type DocumentProfile = 'SRGB' | 'DISPLAY_P3' | 'DOCUMENT_SRGB' | 'DOCUMENT_DISPLAY_P3'; // Figma document profiles\nexport type CanonicalDocumentProfile = 'SRGB' | 'DISPLAY_P3';\n\n/** Normalize the various document profile strings Figma can return. */\nexport function normalizeDocumentProfile(profile: DocumentProfile | string): CanonicalDocumentProfile {\n  const upper = String(profile).toUpperCase();\n  return upper.includes('DISPLAY_P3') ? 'DISPLAY_P3' : 'SRGB';\n}\n\n// Only accept these DTCG color spaces in this plugin:\nconst SUPPORTED_DTCG_COLOR_SPACES = new Set(['srgb', 'display-p3'] as const);\n\n/**\n * Strict shape validator for a DTCG color object.\n * Expects: { colorSpace: 'srgb'|'display-p3', components: [r,g,b], alpha?: number, hex?: string }\n */\nexport function isDtcgColorShapeValid(input: any): { ok: boolean; reason?: string } {\n  if (!input || typeof input !== 'object') {\n    return { ok: false, reason: 'not an object' };\n  }\n\n  const cs = String(input.colorSpace || '').toLowerCase();\n  if (!SUPPORTED_DTCG_COLOR_SPACES.has(cs as any)) {\n    return { ok: false, reason: `unsupported colorSpace (\u201C${input.colorSpace}\u201D)` };\n  }\n\n  if (!Array.isArray(input.components) || input.components.length !== 3) {\n    return { ok: false, reason: 'components must be an array of length 3' };\n  }\n\n  // components must be finite numbers in [0..1]\n  for (let i = 0; i < 3; i++) {\n    const v = input.components[i];\n    if (typeof v !== 'number' || !Number.isFinite(v)) {\n      return { ok: false, reason: `component ${i} is not a finite number` };\n    }\n    if (v < 0 || v > 1) {\n      return { ok: false, reason: `component ${i} out of range (${v})` };\n    }\n  }\n\n  // alpha, if present, must be finite number in [0..1]\n  if (typeof input.alpha !== 'undefined') {\n    if (typeof input.alpha !== 'number' || !Number.isFinite(input.alpha)) {\n      return { ok: false, reason: 'alpha is not a finite number' };\n    }\n    if (input.alpha < 0 || input.alpha > 1) {\n      return { ok: false, reason: `alpha out of range (${input.alpha})` };\n    }\n  }\n\n  return { ok: true };\n}\n\n/**\n * Gate colorSpace by document profile: SRGB docs only allow 'srgb',\n * Display-P3 docs allow both 'srgb' and 'display-p3'.\n */\nexport function isColorSpaceRepresentableInDocument(\n  colorSpace: string,\n  profile: DocumentProfile | string\n): boolean {\n  const cs = String(colorSpace).toLowerCase();\n  const normalized = normalizeDocumentProfile(profile);\n  if (normalized === 'DISPLAY_P3') return cs === 'srgb' || cs === 'display-p3';\n  return cs === 'srgb';\n}\n\nfunction clamp01(x: number): number {\n  if (x < 0) return 0;\n  if (x > 1) return 1;\n  return x;\n}\nfunction clamp01Array(v: number[]): number[] {\n  var out: number[] = [];\n  var i = 0;\n  for (i = 0; i < v.length; i++) out.push(clamp01(v[i]));\n  return out;\n}\n\n// sRGB / P3 TRC\nfunction srgbEncode(linear: number): number {\n  if (linear <= 0.0031308) return 12.92 * linear;\n  return 1.055 * Math.pow(linear, 1 / 2.4) - 0.055;\n}\nfunction srgbDecode(encoded: number): number {\n  if (encoded <= 0.04045) return encoded / 12.92;\n  return Math.pow((encoded + 0.055) / 1.055, 2.4);\n}\nvar p3Encode = srgbEncode;\nvar p3Decode = srgbDecode;\n\nfunction mul3(m: number[][], v: number[]): number[] {\n  return [\n    m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2],\n    m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2],\n    m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2],\n  ];\n}\n\n// D65 matrices\nconst M_SRGB_TO_XYZ = [\n  [0.4124564, 0.3575761, 0.1804375],\n  [0.2126729, 0.7151522, 0.0721750],\n  [0.0193339, 0.1191920, 0.9503041],\n];\nconst M_XYZ_TO_SRGB = [\n  [3.2404542, -1.5371385, -0.4985314],\n  [-0.9692660, 1.8760108, 0.0415560],\n  [0.0556434, -0.2040259, 1.0572252],\n];\n\nconst M_P3_TO_XYZ = [\n  [0.4865709486482162, 0.26566769316909306, 0.1982172852343625],\n  [0.2289745640697488, 0.6917385218365064, 0.0792869140937450],\n  [0.0000000000000000, 0.04511338185890264, 1.0439443689009760],\n];\nconst M_XYZ_TO_P3 = [\n  [2.493496911941425, -0.9313836179191239, -0.40271078445071684],\n  [-0.8294889695615747, 1.7626640603183463, 0.02362468584194358],\n  [0.03584583024378447, -0.07617238926804182, 0.9568845240076872],\n];\n\nfunction encode(space: 'srgb' | 'display-p3', linearRGB: number[]): number[] {\n  if (space === 'display-p3') return [p3Encode(linearRGB[0]), p3Encode(linearRGB[1]), p3Encode(linearRGB[2])];\n  return [srgbEncode(linearRGB[0]), srgbEncode(linearRGB[1]), srgbEncode(linearRGB[2])];\n}\nfunction decode(space: 'srgb' | 'display-p3', encodedRGB: number[]): number[] {\n  if (space === 'display-p3') return [p3Decode(encodedRGB[0]), p3Decode(encodedRGB[1]), p3Decode(encodedRGB[2])];\n  return [srgbDecode(encodedRGB[0]), srgbDecode(encodedRGB[1]), srgbDecode(encodedRGB[2])];\n}\n\nfunction convertRgbSpace(rgb: number[], src: 'srgb' | 'display-p3', dst: 'srgb' | 'display-p3'): number[] {\n  if (src === dst) return clamp01Array(rgb);\n  var lin = decode(src, clamp01Array(rgb));\n  var xyz: number[] = src === 'srgb' ? mul3(M_SRGB_TO_XYZ, lin) : mul3(M_P3_TO_XYZ, lin);\n  var linDst: number[] = dst === 'srgb' ? mul3(M_XYZ_TO_SRGB, xyz) : mul3(M_XYZ_TO_P3, xyz);\n  var enc = encode(dst, linDst);\n  return clamp01Array(enc);\n}\n\nfunction srgbToHex6(rgb: number[]): string {\n  var r = Math.round(clamp01(rgb[0]) * 255);\n  var g = Math.round(clamp01(rgb[1]) * 255);\n  var b = Math.round(clamp01(rgb[2]) * 255);\n  function to2(n: number): string { var s = n.toString(16); return s.length === 1 ? '0' + s : s; }\n  return '#' + to2(r) + to2(g) + to2(b);\n}\nfunction srgbToHex8(rgba: { r: number; g: number; b: number; a: number }): string {\n  var r = Math.round(clamp01(rgba.r) * 255);\n  var g = Math.round(clamp01(rgba.g) * 255);\n  var b = Math.round(clamp01(rgba.b) * 255);\n  var a = Math.round(clamp01(rgba.a) * 255);\n  function to2(n: number): string { var s = n.toString(16); return s.length === 1 ? '0' + s : s; }\n  return '#' + to2(r) + to2(g) + to2(b) + to2(a);\n}\n\nfunction isHexCharCode(code: number): boolean {\n  if (code >= 48 && code <= 57) return true;\n  if (code >= 65 && code <= 70) return true;\n  if (code >= 97 && code <= 102) return true;\n  return false;\n}\nfunction hexPairToByte(h1: number, h2: number): number {\n  function val(c: number): number {\n    if (c >= 48 && c <= 57) return c - 48;\n    if (c >= 65 && c <= 70) return c - 55;\n    if (c >= 97 && c <= 102) return c - 87;\n    return 0;\n  }\n  return (val(h1) << 4) | val(h2);\n}\n\nexport function parseHexToSrgbRGBA(hex: string): { r: number; g: number; b: number; a: number } {\n  var s = hex;\n  if (s.length > 0 && s.charAt(0) === '#') s = s.substring(1);\n\n  var i = 0;\n  for (i = 0; i < s.length; i++) {\n    if (!isHexCharCode(s.charCodeAt(i))) throw new Error('Invalid hex color: ' + hex);\n  }\n\n  var r = 0, g = 0, b = 0, a = 255;\n\n  if (s.length === 3 || s.length === 4) {\n    var rNib = s.charCodeAt(0);\n    var gNib = s.charCodeAt(1);\n    var bNib = s.charCodeAt(2);\n    var aNib = s.length === 4 ? s.charCodeAt(3) : 102;\n    r = hexPairToByte(rNib, rNib);\n    g = hexPairToByte(gNib, gNib);\n    b = hexPairToByte(bNib, bNib);\n    a = hexPairToByte(aNib, aNib);\n  } else if (s.length === 6 || s.length === 8) {\n    r = hexPairToByte(s.charCodeAt(0), s.charCodeAt(1));\n    g = hexPairToByte(s.charCodeAt(2), s.charCodeAt(3));\n    b = hexPairToByte(s.charCodeAt(4), s.charCodeAt(5));\n    if (s.length === 8) a = hexPairToByte(s.charCodeAt(6), s.charCodeAt(7));\n  } else {\n    throw new Error('Invalid hex length: ' + hex);\n  }\n\n  return { r: clamp01(r / 255), g: clamp01(g / 255), b: clamp01(b / 255), a: clamp01(a / 255) };\n}\n\nfunction docProfileToSpaceKey(profile: DocumentProfile | string): 'srgb' | 'display-p3' {\n  return normalizeDocumentProfile(profile) === 'DISPLAY_P3' ? 'display-p3' : 'srgb';\n}\n\n/** DTCG -> Figma RGBA in current doc profile. */\nexport function dtcgToFigmaRGBA(\n  value: ColorValue,\n  docProfile: DocumentProfile | string\n): { r: number; g: number; b: number; a: number } {\n  var alpha = typeof value.alpha === 'number' ? value.alpha : 1;\n  var dst = docProfileToSpaceKey(docProfile);\n\n  var comps = value.components;\n  if (comps && comps.length >= 3) {\n    var space = value.colorSpace;\n    if (space === 'srgb' || space === 'display-p3') {\n      var converted = convertRgbSpace([comps[0], comps[1], comps[2]], space, dst);\n      return { r: converted[0], g: converted[1], b: converted[2], a: clamp01(alpha) };\n    }\n    throw new Error('Unsupported colorSpace: ' + space + '. Supported: srgb, display-p3.');\n  }\n\n  if (value.hex && typeof value.hex === 'string') {\n    var fromHex = parseHexToSrgbRGBA(value.hex);\n    var a = typeof value.alpha === 'number' ? clamp01(value.alpha) : fromHex.a;\n    if (dst === 'srgb') return { r: fromHex.r, g: fromHex.g, b: fromHex.b, a: a };\n    var toDst = convertRgbSpace([fromHex.r, fromHex.g, fromHex.b], 'srgb', dst);\n    return { r: toDst[0], g: toDst[1], b: toDst[2], a: a };\n  }\n\n  throw new Error('Color has neither components nor hex.');\n}\n\n/** Figma -> DTCG in document-native space + sRGB hex fallback. */\nexport function figmaRGBAToDtcg(\n  rgba: { r: number; g: number; b: number; a: number },\n  docProfile: DocumentProfile | string\n): ColorValue {\n  var src = docProfileToSpaceKey(docProfile);\n  var rgb = [clamp01(rgba.r), clamp01(rgba.g), clamp01(rgba.b)];\n  var a = clamp01(rgba.a);\n\n  var colorSpace: 'srgb' | 'display-p3' = src;\n  var components: [number, number, number] = [rgb[0], rgb[1], rgb[2]];\n\n  var srgbRgb = src === 'srgb' ? rgb : convertRgbSpace(rgb, 'display-p3', 'srgb');\n  var hex = srgbToHex6(srgbRgb);\n\n  return { colorSpace: colorSpace, components: components, alpha: a, hex: hex };\n}\n\n// Legacy wrappers kept for existing callers\nexport function srgbToFigma(color: ColorValue): { r: number; g: number; b: number; a: number } {\n  return dtcgToFigmaRGBA(color, 'SRGB');\n}\nexport function figmaToSrgb(r: number, g: number, b: number, a: number): ColorValue {\n  var comps: [number, number, number] = [clamp01(r), clamp01(g), clamp01(b)];\n  return { colorSpace: 'srgb', components: comps, alpha: clamp01(a) };\n}\n\n// Hex helpers for tooling\nexport function toHex6FromSrgb(rgb: { r: number; g: number; b: number }): string {\n  return srgbToHex6([clamp01(rgb.r), clamp01(rgb.g), clamp01(rgb.b)]);\n}\nexport function toHex8FromSrgb(rgba: { r: number; g: number; b: number; a: number }): string {\n  return srgbToHex8({ r: clamp01(rgba.r), g: clamp01(rgba.g), b: clamp01(rgba.b), a: clamp01(rgba.a) });\n}\n\nexport function colorValueToHexString(value: ColorValue): string {\n  const comps = Array.isArray(value.components) ? value.components : [0, 0, 0];\n  const srgb = value.colorSpace === 'display-p3'\n    ? convertRgbSpace(comps, 'display-p3', 'srgb')\n    : clamp01Array(comps);\n\n  const baseHex = typeof value.hex === 'string' && value.hex.length > 0\n    ? (value.hex.charAt(0) === '#' ? value.hex : ('#' + value.hex))\n    : srgbToHex6(srgb);\n\n  if (typeof value.alpha === 'number') {\n    const alpha = clamp01(value.alpha);\n    if (alpha < 1) {\n      return srgbToHex8({ r: srgb[0], g: srgb[1], b: srgb[2], a: alpha });\n    }\n  }\n\n  return baseHex;\n}\nexport function hexToDtcgColor(hex: string): ColorValue {\n  var rgba = parseHexToSrgbRGBA(hex);\n  var comps: [number, number, number] = [rgba.r, rgba.g, rgba.b];\n  return { colorSpace: 'srgb', components: comps, alpha: rgba.a, hex: toHex6FromSrgb({ r: rgba.r, g: rgba.g, b: rgba.b }) };\n}\n\n\n// ==== DTCG color guards & normalization ===================================\n\n/**\n * Lightweight structural check for a DTCG color object.\n * Accepts { components[3], colorSpace?, alpha?, hex? }.\n * (colorSpace may be absent; we'll default it during normalization.)\n */\nexport function isValidDtcgColorValueObject(v: unknown): v is {\n  colorSpace?: string;\n  components?: unknown;\n  alpha?: unknown;\n  hex?: unknown;\n} {\n  if (!v || typeof v !== \"object\") return false;\n  const o = v as any;\n  if (!Array.isArray(o.components) || o.components.length < 3) return false;\n  if (typeof o.components[0] !== \"number\" ||\n    typeof o.components[1] !== \"number\" ||\n    typeof o.components[2] !== \"number\") return false;\n  return true;\n}\n\n/**\n * Normalize a DTCG color object into your internal ColorValue:\n * - clamps components/alpha to [0,1]\n * - preserves hex when present (no rounding/quantization)\n * - defaults missing colorSpace to \"srgb\"\n */\nexport function normalizeDtcgColorValue(input: {\n  colorSpace?: string;\n  components: [number, number, number] | number[];\n  alpha?: number;\n  hex?: string;\n}): ColorValue {\n  function clamp01(x: number): number {\n    if (!Number.isFinite(x)) return 0;\n    if (x < 0) return 0;\n    if (x > 1) return 1;\n    return x;\n  }\n  const comps = [\n    clamp01(Number(input.components[0])),\n    clamp01(Number(input.components[1])),\n    clamp01(Number(input.components[2]))\n  ] as [number, number, number];\n\n  const alpha =\n    typeof input.alpha === \"number\" ? clamp01(input.alpha) : undefined;\n\n  // Honor provided colorSpace when it's one of the supported ones; default to srgb\n  const cs = input.colorSpace === \"display-p3\" ? \"display-p3\" : \"srgb\";\n\n  return {\n    colorSpace: cs,\n    components: comps,\n    ...(alpha !== undefined ? { alpha } : {}),\n    ...(typeof input.hex === \"string\" ? { hex: input.hex } : {})\n  };\n}\n\n// STRICT range check: components and alpha must be in [0..1] with no clamping.\nexport function isDtcgColorInUnitRange(input: {\n  components?: [number, number, number] | number[];\n  alpha?: number;\n}): { ok: boolean; reason?: string } {\n  if (!input || !Array.isArray(input.components) || input.components.length < 3) {\n    return { ok: false, reason: 'components missing' };\n  }\n  for (let i = 0; i < 3; i++) {\n    const n = Number(input.components[i]);\n    if (!Number.isFinite(n) || n < 0 || n > 1) {\n      return { ok: false, reason: `component[${i}] out of range (${input.components[i]})` };\n    }\n  }\n  if (typeof input.alpha === 'number') {\n    const a = Number(input.alpha);\n    if (!Number.isFinite(a) || a < 0 || a > 1) {\n      return { ok: false, reason: `alpha out of range (${input.alpha})` };\n    }\n  }\n  return { ok: true };\n}\n", "// src/adapters/dtcg-reader.ts\n// Parse raw DTCG token JSON into our IR without losing metadata or alias structure.\n// - Validates values strictly so we fail fast on malformed input\n// - Preserves $extensions fields to keep Figma round-trips intact\n\nimport {\n  type TokenGraph,\n  type TokenNode,\n  type PrimitiveType,\n  type ValueOrAlias,\n} from '../core/ir';\nimport { parseTypographyValue } from '../core/typography';\n\n// ---------- color parsing (strict) ----------\nimport { hexToDtcgColor, isDtcgColorShapeValid } from '../core/color';\n\n// ---------- lightweight logging (console fallback outside Figma) ----------\nfunction postInfoToUi(msg: string): boolean {\n  try {\n    if (typeof figma !== 'undefined' && figma.ui?.postMessage) {\n      figma.ui.postMessage({ type: 'INFO', payload: { message: msg } });\n      return true;\n    }\n  } catch { /* ignore */ }\n  return false;\n}\n\nfunction logInfo(msg: string) {\n  if (postInfoToUi(msg)) return;\n  try { globalThis.console?.log?.(msg); } catch { /* ignore */ }\n}\n\nfunction logWarn(msg: string) {\n  const payload = 'Warning: ' + msg;\n  if (postInfoToUi(payload)) return;\n  try { globalThis.console?.warn?.(payload); }\n  catch {\n    try { globalThis.console?.log?.(payload); } catch { /* ignore */ }\n  }\n}\n\n// ---------- helpers ----------\n/** Guard for plain-object own keys without letting sneaky prototypes through. */\nfunction hasKey(o: unknown, k: string): boolean {\n  return !!o && typeof o === 'object' && Object.prototype.hasOwnProperty.call(o, k);\n}\n\n/** True when the value looks like an alias string: \"{collection.group.token}\". */\nfunction isAliasString(v: unknown): v is string {\n  return typeof v === 'string' && v.startsWith('{') && v.endsWith('}') && v.length > 2;\n}\n\n/** Split an alias string into raw segments while keeping user formatting intact. */\nfunction parseAliasToSegments(v: string): string[] {\n  // exact segments, keep spacing/punctuation as-is (only trim around the dot delimiter)\n  return v.slice(1, -1).split('.').map(s => s.trim());\n}\n\n/** Quick heuristic for hex strings so we only attempt conversions on plausible inputs. */\nfunction isLikelyHexString(v: unknown): v is string {\n  return typeof v === 'string'\n    && /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(v.trim());\n}\n\n/** Extract a trimmed $description if present; avoids emitting empty strings. */\nfunction readDescription(obj: unknown): string | undefined {\n  if (!obj || typeof obj !== 'object') return undefined;\n  const d = (obj as any)['$description'];\n  if (typeof d === 'string') {\n    const s = d.trim();\n    if (s.length > 0) return s;\n  }\n  return undefined;\n}\n\n\n/**\n * Flexible color parser:\n * - Strict by default (reject all string forms).\n * - When allowHexStrings = true, accept hex strings -> DTCG object via hexToDtcgColor (srgb).\n * - Always accept objects only if shape is valid (supported colorSpace, 3 numeric components, alpha number in [0..1] or undefined).\n * - Do NOT coerce object member types (alpha:\"1\" stays string -> rejected by validator).\n */\nfunction readColorValueFlexible(\n  raw: unknown,\n  allowHexStrings: boolean\n): { value: any; coercedFromHex: boolean } | null {\n  // String form\n  if (typeof raw === 'string') {\n    if (!allowHexStrings) return null;\n    if (!isLikelyHexString(raw)) return null;\n    try {\n      return { value: hexToDtcgColor(raw), coercedFromHex: true };\n    } catch {\n      return null;\n    }\n  }\n\n  // Object form (no coercion)\n  if (raw && typeof raw === 'object') {\n    const obj = raw as any;\n    const candidate: any = {\n      // keep as-is; validator will check allowed spaces (srgb/display-p3)\n      ...(typeof obj.colorSpace === 'string' ? { colorSpace: obj.colorSpace } : {}),\n      ...(Array.isArray(obj.components) ? { components: obj.components.slice(0, 3) } : {}),\n      // preserve provided alpha *as-is*; validator will reject non-number/out-of-range\n      ...(('alpha' in obj) ? { alpha: obj.alpha } : {}),\n      ...(typeof obj.hex === 'string' ? { hex: obj.hex } : {})\n    };\n\n    const shape = isDtcgColorShapeValid(candidate);\n    if (!shape.ok) return null;\n    return { value: candidate, coercedFromHex: false };\n  }\n\n  return null;\n}\n\n/**\n * Compute IR path and ctx for a token based on:\n *  - $extensions.com.figma.modeName (if present, use EXACT string)\n *  - otherwise the JSON group path literally (no normalization)\n *  - default Figma mode when missing = \"Mode 1\"\n */\nfunction computePathAndCtx(path: string[], obj: unknown): { irPath: string[]; ctx: string } {\n  const irPath = path.slice(); // EXACT JSON path\n  let mode = 'Mode 1';\n  const ext = hasKey(obj, '$extensions') ? (obj as any)['$extensions'] as Record<string, unknown> : undefined;\n  const cf = ext && typeof ext === 'object' ? (ext as any)['com.figma'] : undefined;\n  if (cf && typeof cf === 'object' && typeof (cf as any).modeName === 'string') {\n    mode = (cf as any).modeName as string;\n  }\n  const collection = irPath[0] ?? 'Tokens';\n  return { irPath, ctx: `${collection}/${mode}` };\n}\n\nexport interface DtcgReaderOptions {\n  /** When true, accept hex strings like \"#RRGGBB[AA]\" and coerce to a DTCG color object (srgb). Default: false (strict). */\n  allowHexStrings?: boolean;\n}\n\nexport function readDtcgToIR(root: unknown, opts: DtcgReaderOptions = {}): TokenGraph {\n  const allowHexStrings = !!opts.allowHexStrings;\n  const tokens: TokenNode[] = [];\n  const tokensByPath = new Map<string, TokenNode>();\n  const aliasTokens: Array<{ token: TokenNode; declaredType: PrimitiveType | null }> = [];\n\n  function registerToken(token: TokenNode): void {\n    tokens.push(token);\n    tokensByPath.set(token.path.join('/'), token);\n  }\n\n  function visit(obj: unknown, path: string[], inheritedType: PrimitiveType | null): void {\n    if (!obj || typeof obj !== 'object') return;\n\n    // group-level $type inheritance (DTCG)\n    let groupType: PrimitiveType | null = inheritedType;\n    if (hasKey(obj, '$type') && typeof (obj as any).$type === 'string') {\n      const t = String((obj as any).$type);\n      if (t === 'color' || t === 'number' || t === 'string' || t === 'boolean' || t === 'typography') {\n        groupType = t as PrimitiveType;\n      }\n    }\n\n    // Token node?\n    if (hasKey(obj, '$value')) {\n      const rawVal = (obj as any).$value;\n\n      // Optional $description (DTCG)\n      const desc = readDescription(obj);\n\n\n      // Aliases are always strings of the form {a.b.c}\n      if (isAliasString(rawVal)) {\n        const segs = parseAliasToSegments(rawVal);\n        const { irPath, ctx } = computePathAndCtx(path, obj);\n        const byCtx: { [k: string]: ValueOrAlias } = {};\n        byCtx[ctx] = { kind: 'alias', path: segs };\n\n        const token: TokenNode = {\n          path: irPath,\n          type: groupType ?? 'string',\n          byContext: byCtx,\n          ...(desc ? { description: desc } : {}),\n          ...(hasKey(obj, '$extensions') ? { extensions: (obj as any)['$extensions'] as Record<string, unknown> } : {})\n        };\n        registerToken(token);\n        aliasTokens.push({ token, declaredType: groupType ?? null });\n        return;\n      }\n\n      // Colors: ONLY when $type (inherited or local) is 'color'\n      if (groupType === 'color') {\n        const { irPath, ctx } = computePathAndCtx(path, obj);\n        const parsed = readColorValueFlexible(rawVal, allowHexStrings);\n\n        if (!parsed) {\n          if (typeof rawVal === 'string') {\n            if (allowHexStrings) {\n              logWarn(`Skipped invalid color for \u201C${irPath.join('/')}\u201D \u2014 expected hex string or a valid DTCG color object (srgb/display-p3, 3 numeric components, alpha in [0..1]).`);\n            } else {\n              logWarn(`Skipped invalid color for \u201C${irPath.join('/')}\u201D \u2014 expected a DTCG color object (srgb/display-p3, 3 numeric components, optional numeric alpha in [0..1]); strings like \"#RRGGBB\" are not accepted.`);\n            }\n          } else {\n            logWarn(`Skipped invalid color for \u201C${irPath.join('/')}\u201D \u2014 expected a valid DTCG color object (srgb/display-p3, 3 numeric components, alpha in [0..1]).`);\n          }\n          return;\n        }\n\n      if (parsed.coercedFromHex) {\n        logInfo(`Coerced string hex to DTCG color object for \u201C${irPath.join('/')}\u201D.`);\n      }\n\n        const byCtx: { [k: string]: ValueOrAlias } = {};\n        byCtx[ctx] = { kind: 'color', value: parsed.value };\n\n        registerToken({\n          path: irPath,\n          type: 'color',\n          byContext: byCtx,\n          ...(desc ? { description: desc } : {}),\n          ...(hasKey(obj, '$extensions') ? { extensions: (obj as any)['$extensions'] as Record<string, unknown> } : {})\n        });\n        return;\n      }\n\n      // Primitives (respect declared type; only fall back when no type was declared)\n      const declaredType = groupType;\n      if (!declaredType) {\n        logWarn(`Skipped token \u201C${path.join('/')}\u201D \u2014 no $type found in token or parent groups.`);\n        return;\n      }\n\n      let effectiveType: PrimitiveType = declaredType;\n      let valObj: ValueOrAlias | null = null;\n\n      if (declaredType === 'number' && typeof rawVal === 'number') {\n        valObj = { kind: 'number', value: rawVal };\n      } else if (declaredType === 'boolean' && typeof rawVal === 'boolean') {\n        valObj = { kind: 'boolean', value: rawVal };\n      } else if (declaredType === 'string' && typeof rawVal === 'string') {\n        valObj = { kind: 'string', value: rawVal };\n      }\n      // DTCG-compliant boolean round-trip:\n      // If $type is (or resolves to) \"string\" and $extensions.com.figma.variableType == \"BOOLEAN\"\n      // and $value is \"true\"/\"false\", coerce back to boolean with a mild note.\n      if (!valObj && (declaredType === 'string') && typeof rawVal === 'string') {\n        const ext = hasKey(obj, '$extensions') ? (obj as any)['$extensions'] as Record<string, unknown> : undefined;\n        const com = ext && typeof ext === 'object' ? (ext as any)['com.figma'] : undefined;\n        const varType = com && typeof com === 'object' ? (com as any)['variableType'] : undefined;\n        if (varType === 'BOOLEAN') {\n          const raw = rawVal.trim().toLowerCase();\n          if (raw === 'true' || raw === 'false') {\n            valObj = { kind: 'boolean', value: (raw === 'true') };\n            // mild note in the plugin log\n            logInfo(`Note: coerced string \u201C${rawVal}\u201D to boolean due to $extensions.com.figma.variableType=BOOLEAN at \u201C${path.join('/')}\u201D.`);\n            effectiveType = 'boolean';\n          }\n        }\n      }\n\n      if (!valObj && declaredType === 'typography') {\n        const parsedTypography = parseTypographyValue(rawVal);\n        if (!parsedTypography) {\n          logWarn(`Skipped token \u201C${path.join('/')}\u201D \u2014 expected a valid typography object.`);\n          return;\n        }\n\n        const { irPath, ctx } = computePathAndCtx(path, obj);\n        const byCtx: { [k: string]: ValueOrAlias } = {};\n        byCtx[ctx] = { kind: 'typography', value: parsedTypography };\n\n        registerToken({\n          path: irPath,\n          type: 'typography',\n          byContext: byCtx,\n          ...(desc ? { description: desc } : {}),\n          ...(hasKey(obj, '$extensions') ? { extensions: (obj as any)['$extensions'] as Record<string, unknown> } : {})\n        });\n        return;\n      }\n\n      if (!valObj) {\n        const observed = typeof rawVal;\n        logWarn(`Skipped token \u201C${path.join('/')}\u201D \u2014 declared $type ${declaredType} but found ${observed}.`);\n        return;\n      }\n\n      const { irPath, ctx } = computePathAndCtx(path, obj);\n      const byCtx: { [k: string]: ValueOrAlias } = {};\n      byCtx[ctx] = valObj;\n\n      registerToken({\n        path: irPath,\n        type: effectiveType,\n        byContext: byCtx,\n        ...(desc ? { description: desc } : {}),\n        ...(hasKey(obj, '$extensions') ? { extensions: (obj as any)['$extensions'] as Record<string, unknown> } : {})\n      });\n      return;\n    }\n\n    // Group: recurse children with *exact* key names (no slugging/canonicalization)\n    for (const k in obj as Record<string, unknown>) {\n      if (!Object.prototype.hasOwnProperty.call(obj, k)) continue;\n      if (k.startsWith('$')) continue; // skip metadata keys\n      const child = (obj as Record<string, unknown>)[k];\n      const newPath = path.concat([k]); // preserve key *exactly*\n      visit(child, newPath, groupType);\n    }\n  }\n\n  visit(root, [], null);\n\n  const aliasTokenSet = new Set(aliasTokens.map(a => a.token));\n  const resolvedTypeCache = new Map<string, PrimitiveType | null>();\n  const invalidTokens = new Set<TokenNode>();\n\n  function resolveTypeForPath(pathSegs: string[], stack: Set<string>): PrimitiveType | null {\n    const key = pathSegs.join('/');\n    if (resolvedTypeCache.has(key)) return resolvedTypeCache.get(key)!;\n    if (stack.has(key)) {\n      resolvedTypeCache.set(key, null);\n      return null;\n    }\n\n    const target = tokensByPath.get(key);\n    if (!target) {\n      resolvedTypeCache.set(key, null);\n      return null;\n    }\n\n    if (!aliasTokenSet.has(target)) {\n      resolvedTypeCache.set(key, target.type);\n      return target.type;\n    }\n\n    stack.add(key);\n    let detected: PrimitiveType | null = null;\n    const ctxValues = Object.values(target.byContext);\n    for (const ctxVal of ctxValues) {\n      if (!ctxVal || ctxVal.kind !== 'alias') {\n        detected = null;\n        break;\n      }\n      const nested = resolveTypeForPath(ctxVal.path, stack);\n      if (!nested) {\n        detected = null;\n        break;\n      }\n      if (!detected) detected = nested;\n      else if (detected !== nested) {\n        detected = null;\n        break;\n      }\n    }\n    stack.delete(key);\n    resolvedTypeCache.set(key, detected);\n    return detected;\n  }\n\n  for (const { token, declaredType } of aliasTokens) {\n    const tokenKey = token.path.join('/');\n    let resolvedType: PrimitiveType | null = null;\n    let unresolved = false;\n\n    for (const ctxVal of Object.values(token.byContext)) {\n      if (!ctxVal || ctxVal.kind !== 'alias') {\n        unresolved = true;\n        break;\n      }\n      const stack = new Set<string>([tokenKey]);\n      const nestedType = resolveTypeForPath(ctxVal.path, stack);\n      if (!nestedType) {\n        unresolved = true;\n        break;\n      }\n      if (!resolvedType) resolvedType = nestedType;\n      else if (resolvedType !== nestedType) {\n        unresolved = true;\n        break;\n      }\n    }\n\n    if (!resolvedType || unresolved) {\n      logWarn(`Skipped token \u201C${token.path.join('/')}\u201D \u2014 could not resolve alias type.`);\n      invalidTokens.add(token);\n      continue;\n    }\n\n    if (declaredType && declaredType !== resolvedType) {\n      logWarn(`Token \u201C${token.path.join('/')}\u201D declared $type ${declaredType} but resolves to ${resolvedType}; using resolved type.`);\n    }\n\n    token.type = resolvedType;\n    tokensByPath.set(tokenKey, token);\n  }\n\n  const finalTokens = tokens.filter(t => !invalidTokens.has(t));\n  return { tokens: finalTokens };\n}\n", "// src/adapters/dtcg-writer.ts\n// Convert the IR graph back into DTCG JSON while keeping alias strings readable.\n// - Emits groups directly from the IR path so git diffs stay predictable\n// - Uses Figma display metadata only for alias references to preserve user intent\n\nimport { type TokenGraph, type TokenNode, type ValueOrAlias } from '../core/ir';\nimport { slugSegment } from '../core/normalize';\nimport { serializeTypographyValue } from '../core/typography';\nimport { colorValueToHexString } from '../core/color';\n\n// ---------- tiny utils (lookup-only; never used for emission) ----------\n/** Join path segments with '.' for alias lookups. */\nfunction dotRaw(segs: string[]): string {\n  return segs.join('.');\n}\n\n/** Matching-only slug so aliases written in slug form still resolve (never for emission). */\nfunction slugForMatch(s: string): string {\n  return s\n    .trim()\n    .replace(/\\s+/g, '-')   // collapse whitespace to single '-'\n    .replace(/-+/g, '-')    // collapse multiple '-' to one\n    .toLowerCase();\n}\n\ntype DisplayNames = { collection: string; variable: string };\n\n/**\n * Extract Figma display names for alias emission, preferring per-context overrides.\n * NEVER used for key generation; JSON structure always follows IR paths.\n */\nfunction getFigmaDisplayNames(t: TokenNode, ctx?: string): DisplayNames {\n  const extAll = (t.extensions && typeof t.extensions === 'object')\n    ? (t.extensions as any)['com.figma'] ?? (t.extensions as any)['org.figma']\n    : undefined;\n\n  // Pull top-level first\n  let collection = (extAll && typeof (extAll as any).collectionName === 'string')\n    ? (extAll as any).collectionName\n    : undefined;\n\n  let variable = (extAll && typeof (extAll as any).variableName === 'string')\n    ? (extAll as any).variableName\n    : undefined;\n\n  // If a context is chosen, prefer perContext overrides for names\n  if (ctx && extAll && typeof extAll === 'object' && typeof (extAll as any).perContext === 'object') {\n    const ctxBlock = (extAll as any).perContext[ctx];\n    if (ctxBlock && typeof ctxBlock === 'object') {\n      if (typeof (ctxBlock as any).collectionName === 'string') collection = (ctxBlock as any).collectionName;\n      if (typeof (ctxBlock as any).variableName === 'string') variable = (ctxBlock as any).variableName;\n    }\n  }\n\n  // Final fallback to IR path (for display purposes only)\n  if (!collection) collection = t.path[0];\n  if (!variable) variable = t.path.slice(1).join('/');\n\n  return { collection, variable };\n}\n\n// ---------- Build alias resolution index (using per-context names) ----------\n/** Build a lookup map so alias emission can resolve display names quickly. */\nfunction buildDisplayNameIndex(graph: TokenGraph): Map<string, DisplayNames> {\n  const byKey = new Map<string, DisplayNames>();\n\n  for (const t of graph.tokens) {\n    const ctxKeys = keysOf(t.byContext);\n    const chosenCtx = ctxKeys.length > 0 ? ctxKeys[0] : undefined;\n\n    const { collection, variable } = getFigmaDisplayNames(t, chosenCtx);\n    const entry: DisplayNames = { collection, variable };\n\n    // 1) raw IR path key (used by some alias paths)\n    byKey.set(dotRaw(t.path), entry);\n\n    // 2) exact display key (collection + variable split)\n    const displaySegs = [collection, ...String(variable).split('/')];\n    byKey.set(dotRaw(displaySegs), entry);\n\n    // 3) slug-for-match key (lookup only)\n    const slugSegs = [slugForMatch(collection), ...String(variable).split('/').map((s: string) => slugForMatch(s))];\n    byKey.set(dotRaw(slugSegs), entry);\n  }\n\n  return byKey;\n}\n\nexport interface SerializeResult { json: unknown; }\nexport interface SerializeOptions { styleDictionary?: boolean; flatTokens?: boolean; }\n\n/**\n * Walk the token graph and emit grouped DTCG JSON.\n * Keeps all grouping logic deterministic so repeated exports diff cleanly.\n */\nexport function serialize(graph: TokenGraph, opts?: SerializeOptions): SerializeResult {\n  const root: { [k: string]: unknown } = {};\n  const displayIndex = buildDisplayNameIndex(graph);\n\n  for (const t of graph.tokens) {\n    writeTokenInto(root, t, displayIndex, opts);\n  }\n\n  return { json: root };\n}\n\n/**\n * Emit a single token into the mutable JSON root. Handles alias resolution and metadata.\n */\nfunction writeTokenInto(\n  root: { [k: string]: unknown },\n  t: TokenNode,\n  displayIndex: Map<string, DisplayNames>,\n  opts?: SerializeOptions\n): void {\n  // DTCG has no modes; pick one context just to serialize value/ids\n  const ctxKeys = keysOf(t.byContext);\n  const chosenCtx = ctxKeys.length > 0 ? ctxKeys[0] : undefined;\n\n  const chosen: ValueOrAlias | null =\n    chosenCtx !== undefined ? (t.byContext[chosenCtx] as ValueOrAlias | undefined) ?? null : null;\n\n  // ***** THE CRITICAL GUARANTEE *****\n  // Build the JSON hierarchy STRICTLY from the IR path segments:\n  //   t.path === [collection, ...variableSegments]\n  const path = Array.isArray(t.path) ? t.path : [String(t.path)];\n  const collectionSeg = path[0] ?? 'Tokens';\n  const variableSegs = path.slice(1); // [\"group1\",\"baseVar\"] etc.\n\n  // Groups are the collection + parent segments; the JSON leaf key is ALWAYS the last segment.\n  const useFlat = !!(opts && opts.flatTokens);\n  const groupSegments = useFlat\n    ? variableSegs.slice(0, -1)\n    : [collectionSeg, ...variableSegs.slice(0, -1)];\n  const leaf = variableSegs.length\n    ? variableSegs[variableSegs.length - 1]\n    : (path[path.length - 1] ?? 'token');\n\n  // Preserve the exact group hierarchy; do not strip user-authored segments\n  // like \"Collection 2\" that participate in canonical alias paths (\u00A75.1).\n\n  // Walk/build the group objects\n  let obj = root;\n  for (let i = 0; i < groupSegments.length; i++) {\n    const seg = groupSegments[i];\n    let next = obj[seg];\n    if (!next || typeof next !== 'object') {\n      next = {};\n      obj[seg] = next;\n    }\n    obj = next as { [k: string]: unknown };\n  }\n\n  // Build token payload\n  const tokenObj: { [k: string]: unknown } = {};\n  // Emit boolean as DTCG string (with a hint in $extensions for round-trip)\n  const emittedType = (t.type === 'boolean') ? 'string' : t.type;\n  tokenObj['$type'] = emittedType;\n\n  // ----- value emission -----\n  if (chosen !== null) {\n    switch (chosen.kind) {\n      case 'alias': {\n        // Resolve to display names if we can (no normalization on emitted string).\n        const segsIn: string[] = Array.isArray((chosen as any).path)\n          ? ((chosen as any).path as string[]).slice()\n          : String((chosen as any).path).split('.').map((p: string) => p.trim()).filter(Boolean);\n\n        let refDisp = displayIndex.get(dotRaw(segsIn));\n        if (!refDisp) {\n          // try slug-for-match\n          refDisp = displayIndex.get(dotRaw(segsIn.map((s: string) => slugForMatch(s))));\n        }\n\n        if (!refDisp && segsIn.length > 0) {\n          // Courtesy: try swapping a slugged collection with a matching display collection\n          const firstSlug = slugForMatch(segsIn[0]);\n          for (const [k] of displayIndex.entries()) {\n            const parts = k.split('.');\n            if (parts.length === 0) continue;\n            if (slugForMatch(parts[0]) === firstSlug) {\n              const cand1 = [parts[0], ...segsIn.slice(1)];\n              const cand2 = [parts[0], ...segsIn.slice(1).map((s: string) => slugForMatch(s))];\n              refDisp = displayIndex.get(dotRaw(cand1)) || displayIndex.get(dotRaw(cand2));\n              if (refDisp) break;\n            }\n          }\n        }\n\n        tokenObj['$value'] = refDisp\n          ? `{${[refDisp.collection, ...String(refDisp.variable).split('/')].join('.')}}`\n          : `{${segsIn.join('.')}}`;\n        break;\n      }\n\n      case 'color': {\n        const cv = chosen.value;\n        if (opts && opts.styleDictionary) {\n          tokenObj['$value'] = colorValueToHexString(cv);\n        } else {\n          const out: { [k: string]: unknown } = {\n            colorSpace: cv.colorSpace,\n            components: [cv.components[0], cv.components[1], cv.components[2]],\n          };\n          if (typeof cv.alpha === 'number') out['alpha'] = cv.alpha;\n          if (typeof cv.hex === 'string') out['hex'] = cv.hex;\n          tokenObj['$value'] = out;\n        }\n        break;\n      }\n\n      case 'number':\n      case 'string': {\n        tokenObj['$value'] = chosen.value;\n        break;\n      }\n\n      case 'boolean': {\n        // DTCG: write as string \"true\"/\"false\"\n        tokenObj['$value'] = chosen.value ? 'true' : 'false';\n        break;\n      }\n\n      case 'typography': {\n        tokenObj['$value'] = serializeTypographyValue(chosen.value);\n        break;\n      }\n    }\n  }\n\n  // Only emit non-empty descriptions\n  if (typeof t.description === 'string' && t.description.trim() !== '') {\n    tokenObj['$description'] = t.description;\n  }\n\n  // Flatten $extensions.(com|org).figma.perContext[chosenCtx] into $extensions.com.figma\n  let extOut: Record<string, unknown> | undefined;\n  if (t.extensions) {\n    const flattened = flattenFigmaExtensionsForCtx(t.extensions as Record<string, unknown>, chosenCtx);\n    extOut = (flattened ?? (t.extensions as Record<string, unknown>));\n  }\n\n  // Add boolean round-trip hint (keeps DTCG $type as \"string\")\n  if (t.type === 'boolean') {\n    if (!extOut) extOut = {};\n    const fig = (extOut['com.figma'] && typeof (extOut['com.figma']) === 'object')\n      ? (extOut['com.figma'] as Record<string, unknown>)\n      : (extOut['com.figma'] = {} as Record<string, unknown>) as Record<string, unknown>;\n    if (fig['variableType'] !== 'BOOLEAN') fig['variableType'] = 'BOOLEAN';\n  }\n\n  if (extOut) tokenObj['$extensions'] = extOut;\n\n  // ***** Final write: leaf only (NEVER the full display path) *****\n  (obj as any)[leaf] = tokenObj;\n}\n\n/**\n * Flattens either $extensions.com.figma or $extensions.org.figma.\n * - Copies all other namespaces through unchanged.\n * - Removes \"perContext\" and merges the selected context's identifiers.\n * - Always emits under \"com.figma\" to follow current DTCG guidance.\n */\nfunction flattenFigmaExtensionsForCtx(\n  ext: Record<string, unknown>,\n  ctx?: string\n): Record<string, unknown> | null {\n  if (!ext || typeof ext !== 'object') return null;\n\n  const out: Record<string, unknown> = {};\n\n  // Copy non-figma namespaces as-is\n  for (const k in ext) {\n    if (!Object.prototype.hasOwnProperty.call(ext, k)) continue;\n    if (k !== 'com.figma' && k !== 'org.figma') {\n      out[k] = (ext as any)[k];\n    }\n  }\n\n  // Prefer com.figma if present; otherwise accept org.figma for backward-compat\n  const ns = (ext as any)['com.figma']\n    ? 'com.figma'\n    : ((ext as any)['org.figma'] ? 'org.figma' : null);\n\n  if (ns) {\n    const figmaBlock = (ext as any)[ns];\n    if (figmaBlock && typeof figmaBlock === 'object') {\n      const base: Record<string, unknown> = {};\n      // copy all keys except perContext\n      for (const k of Object.keys(figmaBlock)) {\n        if (k !== 'perContext') base[k] = (figmaBlock as any)[k];\n      }\n      // merge selected context\n      const per = (figmaBlock as any)['perContext'];\n      if (ctx && per && typeof per === 'object') {\n        const ctxData = (per as any)[ctx];\n        if (ctxData && typeof ctxData === 'object') {\n          Object.assign(base, ctxData);\n        }\n      }\n      if (Object.keys(base).length > 0) {\n        // Always emit using the standardized \"com.figma\" key\n        out['com.figma'] = base;\n      }\n    }\n  }\n\n  return Object.keys(out).length > 0 ? out : null;\n}\n\nfunction keysOf<T>(o: { [k: string]: T } | undefined): string[] {\n  const out: string[] = [];\n  if (!o) return out;\n  for (const k in o) if (Object.prototype.hasOwnProperty.call(o, k)) out.push(k);\n  return out;\n}\n", "// src/core/figma-cache.ts\n// Shared helpers for loading Figma variable collections with cached Variable handles.\n// - Avoids repeated getVariableByIdAsync calls during read/write passes\n// - Supplies quick lookups for collection names so alias resolution stays fast\n\nexport interface CollectionsSnapshot {\n  collections: VariableCollection[];\n  variablesById: Map<string, Variable>;\n  collectionNameById: Map<string, string>;\n}\n\n/**\n * Load all local variable collections and hydrate a cache of Variable objects.\n * Callers can reuse the returned maps to avoid redundant async lookups.\n */\nexport async function loadCollectionsSnapshot(\n  variablesApi: PluginAPI['variables']\n): Promise<CollectionsSnapshot> {\n  const collections = await variablesApi.getLocalVariableCollectionsAsync();\n\n  const collectionNameById = new Map<string, string>();\n  for (const col of collections) {\n    collectionNameById.set(col.id, col.name);\n  }\n\n  const seenIds = new Set<string>();\n  const ids: string[] = [];\n  for (const col of collections) {\n    for (const id of col.variableIds) {\n      if (id && !seenIds.has(id)) {\n        seenIds.add(id);\n        ids.push(id);\n      }\n    }\n  }\n\n  const variablesById = new Map<string, Variable>();\n  if (ids.length > 0) {\n    const fetched = await Promise.all(ids.map(id => variablesApi.getVariableByIdAsync(id)));\n    for (let i = 0; i < ids.length; i++) {\n      const variable = fetched[i];\n      if (variable) variablesById.set(ids[i], variable);\n    }\n  }\n\n  return { collections, variablesById, collectionNameById };\n}\n", "// src/core/ir.ts\n// Central token graph types shared between adapters.\n// - Defines the minimal shape needed to round-trip DTCG and Figma\n// - Keeps primitive helpers colocated with the structural types\n\nimport type { TypographyValue } from './typography';\n\n/** Primitive kinds supported by both Figma variables and DTCG. */\nexport type PrimitiveType = 'color' | 'number' | 'string' | 'boolean' | 'typography';\n\n/** Normalized color payload aligning with DTCG's schema. */\nexport interface ColorValue {\n  colorSpace: 'srgb' | 'display-p3';\n  components: [number, number, number]; // 0..1\n  alpha?: number;                       // 0..1\n  hex?: string;                         // sRGB fallback \"#RRGGBB\"\n}\n\nexport type ValueOrAlias =\n  | { kind: 'alias'; path: string[] }\n  | { kind: 'color'; value: ColorValue }\n  | { kind: 'number'; value: number }\n  | { kind: 'string'; value: string }\n  | { kind: 'boolean'; value: boolean }\n  | { kind: 'typography'; value: TypographyValue };\n\n/** Single token entry with canonical path + per-context values. */\nexport interface TokenNode {\n  path: string[];                         // canonical path segments\n  type: PrimitiveType;\n  byContext: { [ctx: string]: ValueOrAlias }; // ctx like \"Collection/Mode\"\n  description?: string;\n  extensions?: { [k: string]: unknown };\n}\n\n/** Container for all tokens we imported or plan to export. */\nexport interface TokenGraph {\n  tokens: TokenNode[];\n}\n\n/** Build a context key like `Collection/Mode`. */\nexport function ctxKey(collection: string, mode: string): string {\n  return collection + '/' + mode;\n}\n", "// src/adapters/figma-reader.ts\n// Convert live Figma variables into the IR token graph shape used everywhere else.\n// - Preserves canonical path splitting for consistent lookups\n// - Captures per-mode metadata so exports can round-trip Figma specifics\n\nimport { figmaRGBAToDtcg, type DocumentProfile } from '../core/color';\nimport { canonicalPath } from '../core/normalize';\nimport { loadCollectionsSnapshot } from '../core/figma-cache';\nimport { typographyValueFromTextStyle } from '../core/typography';\nimport { ctxKey, type TokenGraph, type TokenNode, type PrimitiveType, type ValueOrAlias } from '../core/ir';\n\n/** Translate Figma's resolved type into the primitive kinds our IR expects. */\nfunction mapType(t: VariableResolvedDataType): PrimitiveType {\n  if (t === 'COLOR') return 'color';\n  if (t === 'FLOAT') return 'number';\n  if (t === 'STRING') return 'string';\n  return 'boolean';\n}\n\n/** Guard for Figma alias payloads so we can branch without optional chaining chains. */\nfunction isAliasValue(v: unknown): v is { type: 'VARIABLE_ALIAS'; id: string } {\n  return !!v && typeof v === 'object' && (v as { type?: string }).type === 'VARIABLE_ALIAS' && typeof (v as { id?: unknown }).id === 'string';\n}\n\n/** Guard raw color values while staying defensive about nullish placeholders. */\nfunction isRGBA(v: unknown): v is { r: number; g: number; b: number; a: number } {\n  return !!v && typeof v === 'object' &&\n    typeof (v as { r?: unknown }).r === 'number' &&\n    typeof (v as { g?: unknown }).g === 'number' &&\n    typeof (v as { b?: unknown }).b === 'number' &&\n    typeof (v as { a?: unknown }).a === 'number';\n}\n\n/**\n * Snapshot every local variable into TokenGraph form while annotating per-mode metadata.\n * We favor direct reads from figma.variables so the IR mirrors whatever is live in the document.\n */\nexport async function readFigmaToIR(): Promise<TokenGraph> {\n  const profile = figma.root.documentColorProfile as DocumentProfile;\n  const variablesApi = figma.variables;\n\n  const { collections, variablesById, collectionNameById } = await loadCollectionsSnapshot(variablesApi);\n\n  const tokens: TokenNode[] = [];\n\n  for (const c of collections) {\n    // Mode name lookup\n    const modeNameById: { [id: string]: string } = {};\n    for (const m of c.modes) modeNameById[m.modeId] = m.name;\n\n    for (const vid of c.variableIds) {\n      const v2 = variablesById.get(vid) || await variablesApi.getVariableByIdAsync(vid);\n      if (v2 && !variablesById.has(vid)) variablesById.set(vid, v2);\n      if (!v2) continue;\n\n      // ***** CRITICAL: always split variable name by '/' into path segments *****\n      const path = canonicalPath(c.name, v2.name);\n\n      const type = mapType(v2.resolvedType);\n      const byContext: { [ctx: string]: ValueOrAlias } = {};\n\n      // Collect per-context figma metadata (stored under $extensions.com.figma.perContext)\n      const perContext: {\n        [ctx: string]: {\n          collectionName: string; collectionID: string;\n          modeName: string; modeID: string;\n          variableName: string; variableID: string;\n        }\n      } = {};\n\n      // For each mode, collect value\n      for (const md of c.modes) {\n        const ctx = ctxKey(c.name, md.name);\n        const mv = v2.valuesByMode[md.modeId];\n\n        // Always record per-context figma metadata\n        perContext[ctx] = {\n          collectionName: c.name,\n          collectionID: c.id,\n          modeName: md.name,\n          modeID: md.modeId,\n          variableName: v2.name,\n          variableID: v2.id,\n        };\n\n        if (isAliasValue(mv)) {\n          const target = variablesById.get(mv.id) || await variablesApi.getVariableByIdAsync(mv.id);\n          if (target && !variablesById.has(target.id)) variablesById.set(target.id, target);\n          if (target) {\n            const collName = collectionNameById.get(target.variableCollectionId) || c.name;\n            const aPath = canonicalPath(collName, target.name);\n            byContext[ctx] = { kind: 'alias', path: aPath };\n          }\n          continue;\n        }\n\n        if (type === 'color' && isRGBA(mv)) {\n          const cv = figmaRGBAToDtcg({ r: mv.r, g: mv.g, b: mv.b, a: mv.a }, profile);\n          byContext[ctx] = { kind: 'color', value: cv };\n          continue;\n        }\n\n        if (typeof mv === 'number') { byContext[ctx] = { kind: 'number', value: mv }; continue; }\n        if (typeof mv === 'boolean') { byContext[ctx] = { kind: 'boolean', value: mv }; continue; }\n        if (typeof mv === 'string') { byContext[ctx] = { kind: 'string', value: mv }; continue; }\n        // else unhandled null/undefined -> skip\n      }\n\n      const figmaExt: Record<string, unknown> = { perContext };\n      if (type === 'boolean') {\n        // Hint for round-tripping booleans while staying DTCG-compliant (\"string\" on write)\n        figmaExt['variableType'] = 'BOOLEAN';\n      }\n\n      const token: TokenNode = {\n        path,\n        type,\n        byContext,\n        ...(v2.description && v2.description.length > 0 ? { description: v2.description } : {}),\n        extensions: {\n          'com.figma': figmaExt\n        }\n      };\n\n      tokens.push(token);\n    }\n  }\n\n  if (typeof figma.getLocalTextStyles === 'function') {\n    const textStyles = figma.getLocalTextStyles();\n    const defaultCollection = 'typography';\n    const defaultMode = 'Mode 1';\n    for (const style of textStyles) {\n      const { value, figma: typographyFigma } = typographyValueFromTextStyle(style);\n      const path = canonicalPath(defaultCollection, style.name);\n      const ctx = ctxKey(defaultCollection, defaultMode);\n      const byContext: { [ctx: string]: ValueOrAlias } = {};\n      byContext[ctx] = { kind: 'typography', value };\n\n      const perContext: {\n        [ctx: string]: {\n          styleID: string;\n          styleName: string;\n        };\n      } = {};\n      perContext[ctx] = {\n        styleID: style.id,\n        styleName: style.name,\n      };\n\n      const extensions: Record<string, unknown> = {\n        'com.figma': {\n          styleType: 'TEXT',\n          styleID: style.id,\n          styleName: style.name,\n          typography: typographyFigma,\n          perContext,\n        }\n      };\n\n      tokens.push({\n        path,\n        type: 'typography',\n        byContext,\n        ...(style.description && style.description.length > 0 ? { description: style.description } : {}),\n        extensions,\n      });\n    }\n  }\n\n  return { tokens };\n}\n", "// src/adapters/figma-writer.ts\n// Apply TokenGraph changes back into Figma's variables API safely and predictably.\n// - Buckets tokens so we only mutate what the document can represent\n// - Preserves figma-specific metadata hints to keep round trips stable\n\nimport { slugSegment } from '../core/normalize';\nimport { type TokenGraph, type TokenNode, type PrimitiveType } from '../core/ir';\nimport { loadCollectionsSnapshot } from '../core/figma-cache';\n\nimport {\n  dtcgToFigmaRGBA,\n  normalizeDocumentProfile,\n  type DocumentProfile,\n  isValidDtcgColorValueObject, // kept for bucketing parity\n  normalizeDtcgColorValue,\n  isDtcgColorInUnitRange,       // kept because tokenHasDirectValue already uses it; harmless to retain\n  isDtcgColorShapeValid,\n  isColorSpaceRepresentableInDocument\n} from '../core/color';\nimport {\n  applyTypographyValueToTextStyle,\n  typographyFontNameFromValue,\n  type TypographyFigmaExtension,\n  type TypographyValue,\n} from '../core/typography';\n\nexport interface WriteResult {\n  createdTextStyles: number;\n}\n\n// ---------- logging to UI (no toasts) ----------\n/** Post a quiet log line to the UI without risking plugin runtime errors. */\nfunction logInfo(msg: string) {\n  try { figma.ui?.postMessage({ type: 'INFO', payload: { message: msg } }); } catch { /* ignore */ }\n}\nfunction logWarn(msg: string) { logInfo('Warning: ' + msg); }\nfunction logError(msg: string) { logInfo('Error: ' + msg); }\n\n// ---------- helpers ----------\n\n// ---------- boolean import helpers (hint + mild note) ----------\n\n/** Read the explicit figma type hint from $extensions.com.figma.variableType. */\nfunction readFigmaVariableTypeHint(t: TokenNode): 'BOOLEAN' | undefined {\n  try {\n    const ext = t.extensions && typeof t.extensions === 'object'\n      ? (t.extensions as any)['com.figma']\n      : undefined;\n    const vt = ext && typeof ext === 'object' ? (ext as any).variableType : undefined;\n    return vt === 'BOOLEAN' ? 'BOOLEAN' : undefined;\n  } catch { return undefined; }\n}\n\n/** Detect string payloads that look like boolean literals so we can warn users. */\nfunction looksBooleanString(s: unknown): s is string {\n  return typeof s === 'string' && /^(true|false)$/i.test(s.trim());\n}\n\n/** Identify tokens that store booleans-as-strings so we can hint at safer conversion. */\nfunction tokenHasBooleanLikeString(t: TokenNode): boolean {\n  const byCtx = t.byContext || {};\n  for (const k in byCtx) {\n    const v = (byCtx as any)[k];\n    if (!v || v.kind === 'alias') continue;\n    if (v.kind === 'string' && looksBooleanString(v.value)) return true;\n  }\n  return false;\n}\n\n/** Token has at least one non-alias, correctly-typed value in any context. */\nfunction tokenHasDirectValue(t: TokenNode): boolean {\n  const byCtx = t.byContext || {};\n  for (const k in byCtx) {\n    const v = byCtx[k] as any;\n    if (!v) continue;\n\n    if (t.type === 'color') {\n      // Bucketing heuristic only \u2014 Pass 1a will do the strict checks.\n      if (v.kind === 'color' && isValidDtcgColorValueObject(v.value)) return true;\n    } else {\n      // number/string/boolean must match kind exactly\n      if (v.kind === t.type) return true;\n    }\n  }\n  return false;\n}\n\n/**\n * True if the token has a direct value that we can safely write for at least one context.\n * Colors require strict validation and profile checks; other primitives just need correct kind.\n */\ntype DirectValueCheck = { ok: true } | { ok: false; reason?: string; suppressWarn?: boolean };\n\nfunction tokenHasAtLeastOneValidDirectValue(t: TokenNode, profile: DocumentProfile | string): DirectValueCheck {\n  const canonicalProfile = normalizeDocumentProfile(profile);\n  const byCtx = t.byContext || {};\n  let lastReason: string | undefined;\n  let reasonAlreadyLogged = false;\n  for (const ctx in byCtx) {\n    const v = (byCtx as any)[ctx];\n    if (!v || v.kind === 'alias') continue;\n\n    if (t.type === 'color') {\n      if (v.kind !== 'color') continue;\n\n      // STRICT 1: shape (supported colorSpace; 3 numeric components; alpha number in [0..1] or undefined)\n      const shape = isDtcgColorShapeValid(v.value);\n      if (!shape.ok) {\n        lastReason = `color in ${ctx} is invalid: ${shape.reason}`;\n        continue;\n      }\n\n      // STRICT 2: representable in this document profile (sRGB doc: only 'srgb'; P3 doc: 'srgb' and 'display-p3')\n      const cs = (v.value.colorSpace || 'srgb').toLowerCase();\n      if (!isColorSpaceRepresentableInDocument(cs, canonicalProfile)) {\n        lastReason = `colorSpace \u201C${cs}\u201D isn\u2019t representable in this document (${canonicalProfile}).`;\n        if (!reasonAlreadyLogged) {\n          logWarn(`Skipped creating direct color at \u201C${t.path.join('/')}\u201D in ${ctx} \u2014 ${lastReason}`);\n          reasonAlreadyLogged = true;\n        }\n        continue;\n      }\n\n      return { ok: true };\n    } else if (t.type === 'number' || t.type === 'string' || t.type === 'boolean') {\n      if (v.kind === t.type) return { ok: true };\n    }\n  }\n  if (t.type === 'number' || t.type === 'string' || t.type === 'boolean') {\n    return { ok: false };\n  }\n  if (reasonAlreadyLogged) {\n    return { ok: false, suppressWarn: true };\n  }\n  return { ok: false, reason: lastReason || 'no valid color values in any context; not creating variable or collection.' };\n}\n\n/** Convert our primitive type into the Figma enum that createVariable expects. */\nfunction resolvedTypeFor(t: PrimitiveType): VariableResolvedDataType {\n  if (t === 'color') return 'COLOR';\n  if (t === 'number') return 'FLOAT';\n  if (t === 'string') return 'STRING';\n  return 'BOOLEAN';\n}\n/** Enumerate own-string keys without trusting prototype state. */\nfunction forEachKey<T>(obj: { [k: string]: T } | undefined): string[] {\n  const out: string[] = [];\n  if (!obj) return out;\n  for (const k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) out.push(k);\n  return out;\n}\n\n/** Token has at least one alias among its contexts. */\nfunction tokenHasAlias(t: TokenNode): boolean {\n  const byCtx = t.byContext || {};\n  for (const k in byCtx) {\n    const v = byCtx[k] as any;\n    if (v && v.kind === 'alias') return true;\n  }\n  return false;\n}\n\n/** Compare imported hex values against stored metadata and raise a gentle warning if they diverge. */\nfunction maybeWarnColorMismatch(t: TokenNode, ctx: string, importedHexOrNull: string | null): void {\n  try {\n    const extAll = t.extensions && typeof t.extensions === 'object' ? (t.extensions as any)['com.figma'] : undefined;\n    if (!extAll || typeof extAll !== 'object') return;\n\n    let hintHex: string | undefined;\n    if (typeof extAll.hex === 'string') hintHex = extAll.hex;\n    const pc = extAll.perContext && typeof extAll.perContext === 'object' ? extAll.perContext : undefined;\n    if (!hintHex && pc && pc[ctx] && typeof pc[ctx].hex === 'string') hintHex = pc[ctx].hex;\n\n    if (!hintHex || !importedHexOrNull) return;\n    const a = hintHex.trim().toLowerCase();\n    const b = importedHexOrNull.trim().toLowerCase();\n    if (a !== b) logWarn(`color mismatch for \u201C${t.path.join('/')}\u201D in ${ctx}. Using $value over $extensions.`);\n  } catch { /* never throw from logging */ }\n}\n\n/** Normalize alias path segments and map collection slugs back to display names when possible. */\nfunction normalizeAliasSegments(\n  rawPath: string[] | string,\n  currentCollection: string,\n  displayBySlug: { [slug: string]: string },\n  knownCollections: Set<string>\n): string[] {\n  const segs = Array.isArray(rawPath)\n    ? rawPath.slice()\n    : String(rawPath).split('.').map(s => s.trim()).filter(Boolean);\n\n  if (segs.length === 0) return [currentCollection];\n\n  const first = segs[0];\n  if (knownCollections.has(first)) return segs;\n\n  const mapped = displayBySlug[first];\n  if (mapped && knownCollections.has(mapped)) {\n    segs[0] = mapped;\n    return segs;\n  }\n\n  // relative \u2192 prefix current collection\n  return [currentCollection, ...segs];\n}\n\n/**\n * Ensure $extensions name hints line up with the JSON path we are about to write.\n * Helps catch renamed variables that could otherwise split into duplicate nodes.\n */\nfunction namesMatchExtensions(t: TokenNode): { ok: boolean; reason?: string } {\n  const ext = t.extensions && typeof t.extensions === 'object'\n    ? (t.extensions as any)['com.figma']\n    : undefined;\n\n  if (!ext || typeof ext !== 'object') return { ok: true };\n\n  const pathCollection = t.path[0];\n  const pathVariable = t.path.slice(1).join('/'); // exact JSON key\n\n  let expectedCollection: string | undefined =\n    typeof (ext as any).collectionName === 'string' ? (ext as any).collectionName : undefined;\n  let expectedVariable: string | undefined =\n    typeof (ext as any).variableName === 'string' ? (ext as any).variableName : undefined;\n\n  // If top-level missing, try perContext (lenient)\n  if (!expectedCollection || !expectedVariable) {\n    const per = (ext as any).perContext;\n    if (per && typeof per === 'object') {\n      const ctxKeys = forEachKey(t.byContext);\n      let ctxToUse: string | undefined;\n\n      for (const k of ctxKeys) {\n        if (per[k] && typeof per[k] === 'object') { ctxToUse = k; break; }\n      }\n      if (!ctxToUse) {\n        for (const k in per) {\n          if (Object.prototype.hasOwnProperty.call(per, k) && per[k] && typeof per[k] === 'object') {\n            ctxToUse = k; break;\n          }\n        }\n      }\n\n      if (ctxToUse) {\n        const ctxData = per[ctxToUse] as any;\n        if (!expectedCollection && typeof ctxData.collectionName === 'string') expectedCollection = ctxData.collectionName;\n        if (!expectedVariable && typeof ctxData.variableName === 'string') expectedVariable = ctxData.variableName;\n      }\n    }\n  }\n\n  if (typeof expectedCollection === 'string' && expectedCollection !== pathCollection) {\n    return {\n      ok: false,\n      reason:\n        `Skipping \u201C${t.path.join('/')}\u201D \u2014 $extensions.com.figma.collectionName (\u201C${expectedCollection}\u201D) ` +\n        `doesn\u2019t match JSON group (\u201C${pathCollection}\u201D).`\n    };\n  }\n\n  if (typeof expectedVariable === 'string' && expectedVariable !== pathVariable) {\n    return {\n      ok: false,\n      reason:\n        `Skipping \u201C${t.path.join('/')}\u201D \u2014 $extensions.com.figma.variableName (\u201C${expectedVariable}\u201D) ` +\n        `doesn\u2019t match JSON key (\u201C${pathVariable}\u201D).`\n    };\n  }\n\n  return { ok: true };\n}\n\nfunction typographyNamesMatchExtensions(t: TokenNode, styleName: string): { ok: boolean; reason?: string } {\n  const ext = t.extensions && typeof t.extensions === 'object'\n    ? (t.extensions as any)['com.figma']\n    : undefined;\n\n  if (!ext || typeof ext !== 'object') return { ok: true };\n\n  const expected = typeof (ext as any).styleName === 'string' ? (ext as any).styleName : undefined;\n  if (expected && expected !== styleName) {\n    return {\n      ok: false,\n      reason: `Skipping \u201C${t.path.join('/')}\u201D \u2014 $extensions.com.figma.styleName (\u201C${expected}\u201D) doesn\u2019t match JSON key (\u201C${styleName}\u201D).`\n    };\n  }\n\n  return { ok: true };\n}\n\n// --- Key indexing helpers: index display + slug for BOTH collection and variable segments\nfunction dot(segs: string[]): string { return segs.join('.'); }\n\nfunction indexVarKeys(\n  map: { [k: string]: string },\n  collectionDisplay: string,\n  varSegsRaw: string[],\n  varId: string\n): void {\n  const colDisp = collectionDisplay;\n  const colSlug = slugSegment(collectionDisplay);\n  const varRaw = varSegsRaw;\n  const varSlug = varSegsRaw.map(s => slugSegment(s));\n\n  // 1) Display collection + Raw variable segs\n  map[dot([colDisp, ...varRaw])] = varId;\n  // 2) Display collection + Slugged variable segs\n  map[dot([colDisp, ...varSlug])] = varId;\n  // 3) Slugged collection + Raw variable segs\n  map[dot([colSlug, ...varRaw])] = varId;\n  // 4) Slugged collection + Slugged variable segs\n  map[dot([colSlug, ...varSlug])] = varId;\n}\n\nexport async function writeIRToFigma(graph: TokenGraph): Promise<WriteResult> {\n  const profile = figma.root.documentColorProfile as DocumentProfile;\n  const canonicalProfile = normalizeDocumentProfile(profile);\n  const variablesApi = figma.variables;\n\n  logInfo(`Import: document color profile ${String(profile)} (canonical ${canonicalProfile}).`);\n\n  const {\n    collections: existingCollections,\n    variablesById,\n    collectionNameById\n  } = await loadCollectionsSnapshot(variablesApi);\n\n  const colByName: { [name: string]: VariableCollection } = {};\n  for (const c of existingCollections) colByName[c.name] = c;\n\n  const existingVarIdByPathDot: { [dot: string]: string } = {};\n  for (const c of existingCollections) {\n    const cDisplay = c.name;\n    for (const vid of c.variableIds) {\n      const variable = variablesById.get(vid);\n      if (!variable) continue;\n      const varSegs = variable.name.split('/');\n      indexVarKeys(existingVarIdByPathDot, cDisplay, varSegs, variable.id);\n    }\n  }\n\n  // ---- build slug\u2192display mapping for collections (existing + incoming)\n  const knownCollections = new Set<string>(Object.keys(colByName));\n  const displayBySlug: { [slug: string]: string } = {};\n  for (const name of knownCollections) displayBySlug[slugSegment(name)] = name;\n  for (const t of graph.tokens) {\n    const name = t.path[0];\n    knownCollections.add(name);\n    displayBySlug[slugSegment(name)] = name;\n  }\n\n  // ---- buckets for Pass 1a (direct values) and 1b (alias-only)\n  const directTokens: TokenNode[] = [];\n  const aliasOnlyTokens: TokenNode[] = [];\n  const typographyTokens: TokenNode[] = [];\n\n  for (const t of graph.tokens) {\n    if (t.type === 'typography') {\n      typographyTokens.push(t);\n      continue;\n    }\n    const hasDirect = tokenHasDirectValue(t);\n    const hasAlias = tokenHasAlias(t);\n\n    if (hasDirect) {\n      directTokens.push(t);\n    } else if (hasAlias) {\n      aliasOnlyTokens.push(t);\n    } else {\n      logWarn(`Skipped ${t.type} token \u201C${t.path.join('/')}\u201D \u2014 needs a ${t.type} $value or an alias reference.`);\n    }\n\n    // Mild note: string tokens that look boolean but have no explicit hint\n    if (t.type === 'string' && !readFigmaVariableTypeHint(t) && tokenHasBooleanLikeString(t)) {\n      logInfo(`Note: \u201C${t.path.join('/')}\u201D has string values \"true\"/\"false\" but no $extensions.com.figma.variableType hint; keeping STRING in Figma.`);\n    }\n  }\n\n\n  // helper to ensure collection exists (only when we actually create a var)\n  function ensureCollection(name: string): VariableCollection {\n    let col = colByName[name];\n    if (!col) {\n      col = variablesApi.createVariableCollection(name);\n      colByName[name] = col;\n      knownCollections.add(name);\n      displayBySlug[slugSegment(name)] = name;\n      collectionNameById.set(col.id, name);\n    }\n    return col;\n  }\n\n  let createdTextStyles = 0;\n\n  async function importTypographyTokens(tokens: TokenNode[]): Promise<void> {\n    if (tokens.length === 0) return;\n\n    const canReadStyles = typeof figma.getLocalTextStyles === 'function';\n    const canCreateStyles = typeof figma.createTextStyle === 'function';\n    if (!canReadStyles || !canCreateStyles) {\n      logWarn('Typography tokens present but text style APIs are unavailable in this version of Figma. Skipping typography import.');\n      return;\n    }\n\n    const stylesById = new Map<string, TextStyle>();\n    const stylesByName = new Map<string, TextStyle>();\n    const localStyles = figma.getLocalTextStyles();\n    for (const style of localStyles) {\n      stylesById.set(style.id, style);\n      stylesByName.set(style.name, style);\n    }\n\n    const loadedFonts = new Set<string>();\n\n    for (const token of tokens) {\n      const styleSegments = token.path.slice(1);\n      const styleName = styleSegments.join('/');\n      if (!styleName) {\n        logWarn(`Skipped typography token \u201C${token.path.join('/')}\u201D \u2014 requires a style name after the collection.`);\n        continue;\n      }\n\n      const nameCheck = typographyNamesMatchExtensions(token, styleName);\n      if (!nameCheck.ok) {\n        logWarn(nameCheck.reason!);\n        continue;\n      }\n\n      const ctxKeys = forEachKey(token.byContext);\n      let typographyValue: TypographyValue | null = null;\n      let typographyContexts = 0;\n      for (const ctx of ctxKeys) {\n        const val = token.byContext[ctx];\n        if (!val) continue;\n        if (val.kind === 'typography') {\n          typographyContexts++;\n          if (!typographyValue) typographyValue = val.value;\n        } else if (val.kind === 'alias') {\n          logWarn(`Skipped typography alias at \u201C${token.path.join('/')}\u201D in ${ctx} \u2014 text styles do not support aliases.`);\n        } else {\n          logWarn(`Skipped unsupported value for \u201C${token.path.join('/')}\u201D in ${ctx} \u2014 expected a typography $value.`);\n        }\n      }\n\n      if (!typographyValue) {\n        logWarn(`Skipped typography token \u201C${token.path.join('/')}\u201D \u2014 needs a typography $value.`);\n        continue;\n      }\n      if (typographyContexts > 1) {\n        logWarn(`Typography token \u201C${token.path.join('/')}\u201D has multiple contexts. Using the first typography value.`);\n      }\n\n      const ext = token.extensions && typeof token.extensions === 'object'\n        ? (token.extensions as any)['com.figma']\n        : undefined;\n      const extStyleId = ext && typeof ext === 'object' && typeof (ext as any).styleID === 'string'\n        ? String((ext as any).styleID)\n        : undefined;\n      const typographyExt = ext && typeof ext === 'object'\n        ? (ext as any).typography as TypographyFigmaExtension | undefined\n        : undefined;\n\n      let style: TextStyle | null = null;\n      let createdStyle = false;\n      if (extStyleId) {\n        style = stylesById.get(extStyleId) || null;\n      }\n      if (!style) {\n        style = stylesByName.get(styleName) || null;\n      }\n      if (!style) {\n        style = figma.createTextStyle();\n        createdStyle = true;\n      }\n      const { fontName, usedFallback } = typographyFontNameFromValue(typographyValue);\n      let appliedFont: FontName | null = null;\n      let skipToken = false;\n      const tokenPath = token.path.join('/');\n      if (fontName) {\n        const key = fontName.family + ':::' + fontName.style;\n        if (!loadedFonts.has(key)) {\n          try {\n            await figma.loadFontAsync(fontName);\n            loadedFonts.add(key);\n          } catch (err) {\n            const msg = err instanceof Error ? err.message : String(err);\n            logWarn(`Skipped typography token \u201C${tokenPath}\u201D \u2014 failed to load font \u201C${fontName.family} ${fontName.style}\u201D. ${msg}`);\n            skipToken = true;\n          }\n        }\n        if (!skipToken && loadedFonts.has(key)) {\n          appliedFont = fontName;\n          if (usedFallback) {\n            logInfo(`Typography token \u201C${token.path.join('/')}\u201D is missing a font style. Defaulted to \u201C${fontName.style}\u201D.`);\n          }\n        }\n      } else {\n        logWarn(`Skipped typography token \u201C${tokenPath}\u201D \u2014 typography token is missing fontFamily.`);\n        skipToken = true;\n      }\n\n      if (skipToken || !appliedFont) {\n        if (createdStyle) {\n          try { style.remove(); } catch { /* ignore */ }\n        }\n        continue;\n      }\n\n      const prevName = style.name;\n      if (style.name !== styleName) {\n        style.name = styleName;\n      }\n      stylesById.set(style.id, style);\n      if (prevName && stylesByName.get(prevName) === style) {\n        stylesByName.delete(prevName);\n      }\n      stylesByName.set(styleName, style);\n\n      if (typeof token.description === 'string' && token.description.trim().length > 0 && style.description !== token.description) {\n        try { style.description = token.description; } catch { /* ignore */ }\n      }\n\n      if (createdStyle) {\n        createdTextStyles++;\n      }\n\n      const warnings = applyTypographyValueToTextStyle(style, typographyValue, {\n        fontName: appliedFont,\n        figma: typographyExt ?? null,\n      });\n      for (const warning of warnings) {\n        logWarn(`Text style \u201C${styleName}\u201D: ${warning}`);\n      }\n    }\n  }\n\n  // ---- Pass 1a: create direct-value variables, collect ids\n  const idByPath: { [dot: string]: string } = {};\n\n  function varNameFromPath(path: string[]): string {\n    // everything after the collection joined with '/'\n    return path.slice(1).join('/') || (path[0] || 'token');\n  }\n\n  for (const t of directTokens) {\n    if (t.path.length < 1) continue;\n\n    // enforce strict name match vs $extensions (when present)\n    const nameChk = namesMatchExtensions(t);\n    if (!nameChk.ok) { logWarn(nameChk.reason!); continue; }\n\n    const collectionName = t.path[0];\n    const varName = varNameFromPath(t.path);\n\n    // Do NOT create a collection or variable unless we have at least one *valid* direct value.\n    const directCheck = tokenHasAtLeastOneValidDirectValue(t, profile);\n    if (!directCheck.ok) {\n      if (directCheck.reason) {\n        logWarn(`Skipped creating direct ${t.type} token \u201C${t.path.join('/')}\u201D \u2014 ${directCheck.reason}`);\n      } else if (!directCheck.suppressWarn) {\n        logWarn(`Skipped creating direct ${t.type} token \u201C${t.path.join('/')}\u201D \u2014 no valid direct values in any context; not creating variable or collection.`);\n      }\n      continue;\n    }\n\n    const col = ensureCollection(collectionName);\n\n    // find existing\n    let existingVarId: string | null = null;\n    for (const vid of col.variableIds) {\n      const cand = variablesById.get(vid) || await variablesApi.getVariableByIdAsync(vid);\n      if (cand && !variablesById.has(vid) && cand) variablesById.set(vid, cand);\n      if (cand && cand.name === varName) { existingVarId = cand.id; break; }\n    }\n\n    let v: Variable | null = null;\n    if (existingVarId) {\n      v = variablesById.get(existingVarId) || await variablesApi.getVariableByIdAsync(existingVarId);\n      if (v && !variablesById.has(existingVarId)) variablesById.set(existingVarId, v);\n      if (!v) continue;\n    } else {\n      const hint = readFigmaVariableTypeHint(t);\n      // Strict rule: only honor BOOLEAN hint when DTCG $type is \"string\".\n      const createAs: VariableResolvedDataType =\n        (hint === 'BOOLEAN' && t.type === 'string') ? 'BOOLEAN' : resolvedTypeFor(t.type);\n\n      v = variablesApi.createVariable(varName, col, createAs);\n      variablesById.set(v.id, v);\n    }\n\n\n    // --- set description if provided (safe & idempotent)\n    if (typeof t.description === 'string' && t.description.trim().length > 0 && v.description !== t.description) {\n      try { v.description = t.description; } catch { /* ignore */ }\n    }\n\n    // Index display & slug for BOTH collection and variable segments\n    const varSegs = varName.split('/');\n    indexVarKeys(idByPath, collectionName, varSegs, v.id);\n  }\n\n  // ---- Pass 1b: create alias-only variables in ROUNDS so intra-collection chains work\n  const pending: TokenNode[] = aliasOnlyTokens.slice();\n  while (pending.length) {\n    let progress = false;\n    const nextRound: TokenNode[] = [];\n\n    for (const t of pending) {\n      // enforce strict name match vs $extensions (when present)\n      const nameChk = namesMatchExtensions(t);\n      if (!nameChk.ok) { logWarn(nameChk.reason!); continue; }\n\n      const collectionName = t.path[0];\n      const varName = varNameFromPath(t.path);\n\n      // Self keys (display + slug) for skipping self-alias resolvability\n      const selfVarSegs = varName.split('/');\n      const selfKeys = new Set<string>();\n      (function addSelfKeys() {\n        const colDisp = collectionName;\n        const colSlug = slugSegment(collectionName);\n        const varRaw = selfVarSegs;\n        const varSlug = selfVarSegs.map(s => slugSegment(s));\n        selfKeys.add(dot([colDisp, ...varRaw]));\n        selfKeys.add(dot([colDisp, ...varSlug]));\n        selfKeys.add(dot([colSlug, ...varRaw]));\n        selfKeys.add(dot([colSlug, ...varSlug]));\n      })();\n\n      // Is ANY alias context resolvable now? (newly created, direct, or existing doc) \u2014 excluding self\n      let resolvable = false;\n      const ctxKeys = forEachKey(t.byContext);\n      for (const ctx of ctxKeys) {\n        const val = (t.byContext as any)[ctx];\n        if (!val || val.kind !== 'alias') continue;\n\n        const segs = normalizeAliasSegments(val.path, collectionName, displayBySlug, knownCollections);\n        const aliasDot = dot(segs);\n\n        if (selfKeys.has(aliasDot)) continue; // ignore self-alias\n\n        if (idByPath[aliasDot] || existingVarIdByPathDot[aliasDot]) {\n          resolvable = true;\n          break;\n        }\n      }\n\n      if (!resolvable) {\n        // hold for next round\n        nextRound.push(t);\n        continue;\n      }\n\n      // Create the variable now (even if its value will be set in Pass 2)\n      const col = ensureCollection(collectionName);\n\n      // find existing\n      let existingVarId: string | null = null;\n    for (const vid of col.variableIds) {\n      const cand = variablesById.get(vid) || await variablesApi.getVariableByIdAsync(vid);\n      if (cand && !variablesById.has(vid)) variablesById.set(vid, cand);\n      if (cand && cand.name === varName) { existingVarId = cand.id; break; }\n    }\n\n    let v: Variable | null = null;\n    if (existingVarId) {\n      v = variablesById.get(existingVarId) || await variablesApi.getVariableByIdAsync(existingVarId);\n      if (v && !variablesById.has(existingVarId)) variablesById.set(existingVarId, v);\n      if (!v) continue;\n    } else {\n      const hint = readFigmaVariableTypeHint(t);\n      const createAs: VariableResolvedDataType =\n        (hint === 'BOOLEAN' && t.type === 'string') ? 'BOOLEAN' : resolvedTypeFor(t.type);\n\n      v = variablesApi.createVariable(varName, col, createAs);\n      variablesById.set(v.id, v);\n    }\n\n\n      // --- set description if provided (safe & idempotent)\n      if (typeof t.description === 'string' && t.description.trim().length > 0 && v.description !== t.description) {\n        try { v.description = t.description; } catch { /* ignore */ }\n      }\n\n      // Index display & slug for BOTH collection and variable segments\n      const varSegs = varName.split('/');\n      indexVarKeys(idByPath, collectionName, varSegs, v.id);\n\n      progress = true;\n    }\n\n    if (!progress) {\n      // Nothing more could be created; warn & drop what\u2019s left\n      for (const t of nextRound) {\n        logWarn(`Alias target not found for \u201C${t.path.join('/')}\u201D. Variable not created.`);\n      }\n      break;\n    }\n\n    // Continue with whatever is still pending\n    pending.length = 0;\n    Array.prototype.push.apply(pending, nextRound);\n  }\n\n  await importTypographyTokens(typographyTokens);\n\n  // ---- Build mode id lookup (collectionName/modeName \u2192 modeId)\n  const modeIdByKey: { [key: string]: string } = {};\n  const colsPost = await variablesApi.getLocalVariableCollectionsAsync();\n  for (const c of colsPost) {\n    for (const m of c.modes) {\n      modeIdByKey[c.name + '/' + m.name] = m.modeId;\n    }\n  }\n\n  // ---- Pass 2: set values (including aliases) + optional description sync\n  for (const node of graph.tokens) {\n    // resolve our variable id via any of the 4 keys we indexed\n    const collectionName = node.path[0];\n    const varName = node.path.slice(1).join('/');\n    const varSegs = varName.split('/');\n    const possibleSelfKeys: string[] = [];\n    (function addSelfKeys() {\n      const colDisp = collectionName;\n      const colSlug = slugSegment(collectionName);\n      const varRaw = varSegs;\n      const varSlug = varSegs.map(s => slugSegment(s));\n      possibleSelfKeys.push(\n        dot([colDisp, ...varRaw]),\n        dot([colDisp, ...varSlug]),\n        dot([colSlug, ...varRaw]),\n        dot([colSlug, ...varSlug]),\n      );\n    })();\n    let varId: string | undefined;\n    for (const k of possibleSelfKeys) { varId = idByPath[k]; if (varId) break; }\n    if (!varId) continue; // not created (e.g., unresolved alias or name mismatch)\n\n    const targetVar = variablesById.get(varId) || await variablesApi.getVariableByIdAsync(varId);\n    if (targetVar && !variablesById.has(varId)) variablesById.set(varId, targetVar);\n    if (!targetVar) continue;\n\n    // Optional: keep existing variables' descriptions in sync with incoming IR\n    if (typeof node.description === 'string' && node.description.trim().length > 0 && targetVar.description !== node.description) {\n      try { targetVar.description = node.description; } catch { /* ignore */ }\n    }\n\n    const ctxKeys = forEachKey(node.byContext);\n    for (const ctx of ctxKeys) {\n      const val = node.byContext[ctx] as any;\n\n      // ensure mode exists (default \"Mode 1\" when missing)\n      let modeId = modeIdByKey[ctx];\n      if (!modeId) {\n        const parts = ctx.split('/');\n        const cName = parts[0];\n        const mName = parts.slice(1).join('/') || 'Mode 1';\n        const col = colByName[cName];\n        if (col) {\n          const found = col.modes.find(m => m.name === mName);\n          if (found) {\n            modeId = found.modeId;\n            modeIdByKey[cName + '/' + mName] = modeId;\n            modeIdByKey[ctx] = modeId;\n          }\n          else if (col.modes.length === 1) {\n            const loneMode = col.modes[0];\n            const prevName = loneMode.name;\n            if (prevName !== mName) {\n              logWarn(`Collection \u201C${cName}\u201D is limited to a single mode. Renaming \u201C${prevName}\u201D to \u201C${mName}\u201D.`);\n              try {\n                col.renameMode(loneMode.modeId, mName);\n                loneMode.name = mName;\n                const keyOld = cName + '/' + prevName;\n                delete modeIdByKey[keyOld];\n                modeId = loneMode.modeId;\n                const keyNew = cName + '/' + mName;\n                modeIdByKey[keyNew] = modeId;\n                modeIdByKey[ctx] = modeId;\n                logInfo(`Renamed mode \u201C${prevName}\u201D \u2192 \u201C${mName}\u201D in collection \u201C${cName}\u201D.`);\n              } catch (err) {\n                const errMsg = err instanceof Error ? err.message : String(err);\n                logError(`Failed to rename mode \u201C${prevName}\u201D to \u201C${mName}\u201D in collection \u201C${cName}\u201D. ${errMsg}`);\n              }\n            } else {\n              modeId = loneMode.modeId;\n              modeIdByKey[cName + '/' + mName] = modeId;\n              modeIdByKey[ctx] = modeId;\n            }\n          }\n          else {\n            try {\n              modeId = col.addMode(mName);\n              modeIdByKey[cName + '/' + mName] = modeId;\n              modeIdByKey[ctx] = modeId;\n            } catch (err) {\n              const message = err instanceof Error ? err.message : String(err);\n              if (message && message.includes('Limited to 1')) {\n                const loneMode = col.modes[0];\n                const prevName = loneMode?.name || 'Mode 1';\n                logWarn(`Unable to add mode \u201C${mName}\u201D to collection \u201C${cName}\u201D because only a single mode is allowed. Renaming existing mode \u201C${prevName}\u201D.`);\n                try {\n                  if (loneMode) {\n                    col.renameMode(loneMode.modeId, mName);\n                    loneMode.name = mName;\n                    const keyOld = cName + '/' + prevName;\n                    delete modeIdByKey[keyOld];\n                    modeId = loneMode.modeId;\n                    const keyNew = cName + '/' + mName;\n                    modeIdByKey[keyNew] = modeId;\n                    modeIdByKey[ctx] = modeId;\n                    logInfo(`Renamed mode \u201C${prevName}\u201D \u2192 \u201C${mName}\u201D in collection \u201C${cName}\u201D.`);\n                  }\n                  else {\n                    logError(`Unable to rename mode in collection \u201C${cName}\u201D because it has no modes.`);\n                  }\n                } catch (renameErr) {\n                  const renameMsg = renameErr instanceof Error ? renameErr.message : String(renameErr);\n                  logError(`Failed to rename mode \u201C${prevName}\u201D to \u201C${mName}\u201D in collection \u201C${cName}\u201D. ${renameMsg}`);\n                }\n              } else {\n                logError(`Error while adding mode \u201C${mName}\u201D to collection \u201C${cName}\u201D. ${message}`);\n              }\n            }\n          }\n        }\n      }\n      if (!modeId) continue;\n\n      if (val.kind === 'alias') {\n        const currentCollection = collectionName;\n\n        // Build candidates (as-written, relative, slug\u2192display for first seg).\n        const rawSegs = Array.isArray(val.path)\n          ? (val.path as string[]).slice()\n          : String(val.path).split('.').map(s => s.trim()).filter(Boolean);\n\n        const candidates: string[][] = [];\n        if (rawSegs.length > 0) candidates.push(rawSegs);\n        candidates.push([currentCollection, ...rawSegs]);\n        if (rawSegs.length > 0 && displayBySlug[rawSegs[0]]) {\n          candidates.push([displayBySlug[rawSegs[0]], ...rawSegs.slice(1)]);\n        }\n\n        let targetId: string | undefined;\n        for (const cand of candidates) {\n          // Try exact, and also a fully-slugged form (for non-color types referencing other collections)\n          const exact = dot(cand);\n          const fullySlugged = dot([slugSegment(cand[0] || ''), ...cand.slice(1).map(s => slugSegment(s))]);\n\n          targetId =\n            idByPath[exact] ||\n            idByPath[fullySlugged] ||\n            existingVarIdByPathDot[exact] ||\n            existingVarIdByPathDot[fullySlugged];\n\n          if (targetId) break;\n        }\n\n        if (!targetId) {\n          logWarn(`Alias target not found while setting \u201C${node.path.join('/')}\u201D in ${ctx}. Skipped this context.`);\n          continue;\n        }\n\n        // prevent self-alias even if resolvable\n        if (targetId === targetVar.id) {\n          logWarn(`Self-alias is not allowed for \u201C${node.path.join('/')}\u201D in ${ctx}. Skipped this context.`);\n          continue;\n        }\n\n        const aliasObj = await variablesApi.createVariableAliasByIdAsync(targetId);\n        targetVar.setValueForMode(modeId, aliasObj);\n        continue;\n      }\n      else if (val.kind === 'color') {\n        // STRICT: validate DTCG color object shape first\n        const shape = isDtcgColorShapeValid(val.value);\n        if (!shape.ok) {\n          logWarn(`Skipped setting color for \u201C${node.path.join('/')}\u201D in ${ctx} \u2014 ${shape.reason}.`);\n          continue;\n        }\n\n        // STRICT: check representability in this document profile\n        const cs = (val.value.colorSpace || 'srgb').toLowerCase();\n        if (!isColorSpaceRepresentableInDocument(cs, canonicalProfile)) {\n          if (cs === 'display-p3' && canonicalProfile === 'SRGB') {\n            logWarn(\n              `Skipped \u201C${node.path.join('/')}\u201D in ${ctx}: the token is display-p3 but this file is set to sRGB. ` +\n              'Open File \u2192 File Settings \u2192 Color Space and switch to Display P3, or convert the token to sRGB.'\n            );\n          } else {\n            logWarn(`Skipped setting color for \u201C${node.path.join('/')}\u201D in ${ctx} \u2014 colorSpace \u201C${cs}\u201D isn\u2019t representable in this document (${canonicalProfile}).`);\n          }\n          continue;\n        }\n\n        // Safe normalization (no destructive clamping before checks)\n        const norm = normalizeDtcgColorValue(val.value);\n        maybeWarnColorMismatch(node, ctx, typeof norm.hex === 'string' ? norm.hex : null);\n        const rgba = dtcgToFigmaRGBA(norm, profile);\n        targetVar.setValueForMode(modeId, { r: rgba.r, g: rgba.g, b: rgba.b, a: rgba.a });\n\n      } else if (val.kind === 'number' || val.kind === 'string' || val.kind === 'boolean') {\n        // BOOLEAN round-trip:\n        // - If the Figma variable was created as BOOLEAN (by hint), accept true/false safely.\n        // - If it's STRING but IR provides a boolean, downgrade to \"true\"/\"false\".\n        if (targetVar.resolvedType === 'BOOLEAN') {\n          if (val.kind === 'boolean') {\n            targetVar.setValueForMode(modeId, !!val.value);\n          } else if (val.kind === 'string' && looksBooleanString(val.value)) {\n            targetVar.setValueForMode(modeId, /^true$/i.test(val.value.trim()));\n          } else {\n            logWarn(`Skipped setting non-boolean value for BOOLEAN variable \u201C${node.path.join('/')}\u201D in ${ctx}.`);\n          }\n        } else if (val.kind === 'boolean') {\n          // Figma var is not BOOLEAN \u2192 set as string \"true\"/\"false\" (non-breaking)\n          targetVar.setValueForMode(modeId, val.value ? 'true' : 'false');\n        } else {\n          targetVar.setValueForMode(modeId, val.value);\n        }\n      }\n    }\n  }\n\n  // After Pass 2 and after setting values\n  for (const name of Object.keys(colByName)) {\n    const col = colByName[name];\n    if (col && col.variableIds.length === 0) {\n      try { col.remove(); } catch { /* ignore */ }\n      knownCollections.delete(name);\n      delete colByName[name];\n    }\n  }\n  return { createdTextStyles };\n}\n", "// src/core/pipeline.ts\n// Pipeline glue between adapters and the UI.\n// - importDtcg: DTCG JSON -> IR -> write to Figma\n// - exportDtcg: read IR from Figma -> serialize to DTCG; package as files\n\nimport { normalize } from './normalize';\nimport { readDtcgToIR } from '../adapters/dtcg-reader';\nimport { serialize } from '../adapters/dtcg-writer';\nimport { readFigmaToIR } from '../adapters/figma-reader';\nimport { writeIRToFigma } from '../adapters/figma-writer';\nimport type { TokenGraph, TokenNode, ValueOrAlias } from './ir';\n\nexport interface ExportOpts {\n  format: 'single' | 'perMode' | 'typography';\n  styleDictionary?: boolean;\n  flatTokens?: boolean;\n}\nexport interface ExportResult { files: Array<{ name: string; json: unknown }> }\n\nexport interface ImportSummary {\n  /** Total tokens parsed from the incoming file. */\n  totalTokens: number;\n  /** Tokens that remained after applying the selected contexts. */\n  importedTokens: number;\n  /** Total number of Figma styles created while applying the import. */\n  createdStyles: number;\n  /** Every context discovered in the incoming file (Collection/Mode). */\n  availableContexts: string[];\n  /** Contexts actually written to the document after filtering. */\n  appliedContexts: string[];\n  /** Contexts that were intentionally skipped because they weren't selected. */\n  skippedContexts: Array<{ context: string; reason: string }>;\n  /** Contexts requested by the UI that did not exist in the incoming file. */\n  missingRequestedContexts: string[];\n  /** Raw contexts requested by the UI (before intersecting with available contexts). */\n  selectionRequested: string[];\n  /** True when the requested selection had no overlap and we fell back to all contexts. */\n  selectionFallbackToAll?: boolean;\n  /** Tokens that lost one or more contexts during filtering. */\n  tokensWithRemovedContexts: Array<{\n    path: string;\n    removedContexts: string[];\n    keptContexts: string[];\n    reason: 'partial' | 'removed';\n  }>;\n}\n\n// ---------- helpers ----------\n\nexport interface ImportOpts {\n  allowHexStrings?: boolean;\n  contexts?: string[];\n}\n\n\n/**\n * Capture the enumerable keys on a plain object without trusting prototype mutation.\n * We keep this helper local so the export path never depends on a broader utility module.\n */\nfunction keysOf<T>(obj: { [k: string]: T }): string[] {\n  var out: string[] = [];\n  var k: string;\n  for (k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) out.push(k);\n  return out;\n}\n\n/**\n * Replace file-hostile characters so each export path is safe for Git commits on every OS.\n * Using a narrow allow list keeps legacy file names stable while preventing accidental nesting.\n */\nconst INVALID_FILE_CHARS = /[<>:\"/\\\\|?*\\u0000-\\u001F]/g;\n\nfunction sanitizeForFile(s: string): string {\n  var cleaned = String(s);\n  cleaned = cleaned.replace(INVALID_FILE_CHARS, '_');\n  cleaned = cleaned.replace(/\\s+/g, ' ').trim();\n  cleaned = cleaned.replace(/[. ]+$/g, '');\n  return cleaned;\n}\n\n/**\n * Build a copy of a token that only contains the requested context so per-mode exports stay minimal.\n * Returning null when the context is absent lets the caller drop empty files entirely.\n */\nfunction cloneTokenWithSingleContext(t: TokenNode, ctx: string): TokenNode | null {\n  var val = t.byContext[ctx];\n  if (!val) return null;\n\n  // shallow clone without spreads\n  var copyByCtx: { [k: string]: ValueOrAlias } = {};\n  copyByCtx[ctx] = val;\n\n  return {\n    path: (function () { var arr: string[] = []; var i = 0; for (i = 0; i < t.path.length; i++) arr.push(t.path[i]); return arr; })(),\n    type: t.type,\n    byContext: copyByCtx,\n    description: t.description,\n    extensions: t.extensions\n  };\n}\n\nfunction collectContextsFromGraph(graph: TokenGraph): string[] {\n  var seen: string[] = [];\n  var i = 0;\n  for (i = 0; i < graph.tokens.length; i++) {\n    var t = graph.tokens[i];\n    var ks = keysOf(t.byContext);\n    var j = 0;\n    for (j = 0; j < ks.length; j++) {\n      var ctx = ks[j];\n      var already = false;\n      var k = 0;\n      for (k = 0; k < seen.length; k++) if (seen[k] === ctx) { already = true; break; }\n      if (!already) seen.push(ctx);\n    }\n  }\n  return seen;\n}\n\nfunction sanitizeContexts(list: string[] | undefined): string[] {\n  if (!list) return [];\n  var out: string[] = [];\n  for (var i = 0; i < list.length; i++) {\n    var raw = list[i];\n    if (typeof raw !== 'string') continue;\n    var trimmed = raw.trim();\n    if (!trimmed) continue;\n    var exists = false;\n    for (var j = 0; j < out.length; j++) if (out[j] === trimmed) { exists = true; break; }\n    if (!exists) out.push(trimmed);\n  }\n  return out;\n}\n\nfunction filterGraphByContexts(graph: TokenGraph, requested: string[]): { graph: TokenGraph; summary: ImportSummary } {\n  var available = collectContextsFromGraph(graph);\n  var requestedList = sanitizeContexts(requested);\n\n  var availableSet: { [k: string]: true } = {};\n  for (var ai = 0; ai < available.length; ai++) availableSet[available[ai]] = true;\n\n  var appliedSet: { [k: string]: true } = {};\n  var missingRequested: string[] = [];\n  var fallbackToAll = false;\n\n  if (requestedList.length > 0) {\n    for (var ri = 0; ri < requestedList.length; ri++) {\n      var ctx = requestedList[ri];\n      if (availableSet[ctx]) appliedSet[ctx] = true;\n      else missingRequested.push(ctx);\n    }\n    if (Object.keys(appliedSet).length === 0 && available.length > 0) {\n      fallbackToAll = true;\n      for (var ai2 = 0; ai2 < available.length; ai2++) appliedSet[available[ai2]] = true;\n    }\n  } else {\n    for (var ai3 = 0; ai3 < available.length; ai3++) appliedSet[available[ai3]] = true;\n  }\n\n  var appliedList: string[] = [];\n  for (var ctxKey in appliedSet) if (Object.prototype.hasOwnProperty.call(appliedSet, ctxKey)) appliedList.push(ctxKey);\n  appliedList.sort();\n\n  var skippedList: Array<{ context: string; reason: string }> = [];\n  for (var si = 0; si < available.length; si++) {\n    var ctxAvailable = available[si];\n    if (!appliedSet[ctxAvailable]) {\n      skippedList.push({ context: ctxAvailable, reason: 'Excluded by partial import selection' });\n    }\n  }\n  skippedList.sort(function (a, b) {\n    if (a.context === b.context) return 0;\n    return a.context < b.context ? -1 : 1;\n  });\n\n  var filteredTokens: TokenNode[] = [];\n  var removedTokens: Array<{ path: string; removedContexts: string[]; keptContexts: string[]; reason: 'partial' | 'removed' }> = [];\n\n  for (var ti = 0; ti < graph.tokens.length; ti++) {\n    var tok = graph.tokens[ti];\n    var ctxs = keysOf(tok.byContext);\n    if (ctxs.length === 0) {\n      // Nothing to filter; keep token as-is (clone for safety).\n      var cloneEmpty: TokenNode = {\n        path: tok.path.slice(),\n        type: tok.type,\n        byContext: {}\n      };\n      if (typeof tok.description !== 'undefined') cloneEmpty.description = tok.description;\n      if (typeof tok.extensions !== 'undefined') cloneEmpty.extensions = tok.extensions;\n      filteredTokens.push(cloneEmpty);\n      continue;\n    }\n\n    var kept: string[] = [];\n    var removed: string[] = [];\n    var newCtx: { [k: string]: ValueOrAlias } = {};\n\n    for (var ci = 0; ci < ctxs.length; ci++) {\n      var ctx = ctxs[ci];\n      if (appliedSet[ctx]) {\n        kept.push(ctx);\n        newCtx[ctx] = tok.byContext[ctx];\n      } else {\n        removed.push(ctx);\n      }\n    }\n\n    if (kept.length === 0) {\n      removedTokens.push({\n        path: tok.path.join('/'),\n        removedContexts: removed.slice(),\n        keptContexts: [],\n        reason: 'removed'\n      });\n      continue;\n    }\n\n    if (removed.length > 0) {\n      removedTokens.push({\n        path: tok.path.join('/'),\n        removedContexts: removed.slice(),\n        keptContexts: kept.slice(),\n        reason: 'partial'\n      });\n    }\n\n    var clone: TokenNode = {\n      path: tok.path.slice(),\n      type: tok.type,\n      byContext: newCtx\n    };\n    if (typeof tok.description !== 'undefined') clone.description = tok.description;\n    if (typeof tok.extensions !== 'undefined') clone.extensions = tok.extensions;\n    filteredTokens.push(clone);\n  }\n\n  removedTokens.sort(function (a, b) {\n    if (a.path === b.path) return 0;\n    return a.path < b.path ? -1 : 1;\n  });\n\n  return {\n    graph: { tokens: filteredTokens },\n    summary: {\n      totalTokens: graph.tokens.length,\n      importedTokens: filteredTokens.length,\n      createdStyles: 0,\n      availableContexts: available.slice().sort(),\n      appliedContexts: appliedList,\n      skippedContexts: skippedList,\n      missingRequestedContexts: missingRequested,\n      selectionRequested: requestedList,\n      selectionFallbackToAll: fallbackToAll ? true : undefined,\n      tokensWithRemovedContexts: removedTokens\n    }\n  };\n}\n\n// ---------- API ----------\n\n// Read a DTCG payload, normalize it, and write the resulting graph into the current document.\nexport async function importDtcg(json: unknown, opts: ImportOpts = {}): Promise<ImportSummary> {\n  // Build desired graph from DTCG, then write directly to Figma.\n  // We previously shipped an unused \"plan\" module that tried to diff the desired\n  // graph against the live document. Nothing in the plugin ever called it, and\n  // the write path already overwrites the full state, so keeping the unused\n  // module only increased bundle size and maintenance cost. Keeping a single\n  // happy-path write keeps the observable behavior identical to the versions\n  // that shipped before the cleanup.\n  const desired = normalize(readDtcgToIR(json, { allowHexStrings: !!opts.allowHexStrings }));\n  const filtered = filterGraphByContexts(desired, opts.contexts || []);\n  const writeResult = await writeIRToFigma(filtered.graph);\n  filtered.summary.createdStyles = writeResult.createdTextStyles;\n  return filtered.summary;\n}\n\n\n// Pull the latest graph from Figma and emit files in the format requested by the UI (single/per-mode/typography).\nexport async function exportDtcg(opts: ExportOpts): Promise<ExportResult> {\n  var current = await readFigmaToIR();\n  var graph = normalize(current);\n  var styleDictionary = !!opts.styleDictionary;\n  var flatTokens = !!opts.flatTokens;\n\n  if (opts.format === 'typography') {\n    var typographyTokens: TokenNode[] = [];\n    for (var ti = 0; ti < graph.tokens.length; ti++) {\n      var tok = graph.tokens[ti];\n      if (tok.type === 'typography') {\n        var cloneTypo: TokenNode = {\n          path: tok.path.slice(),\n          type: tok.type,\n          byContext: {} as { [ctx: string]: ValueOrAlias }\n        };\n        var ctxKeys = keysOf(tok.byContext);\n        for (var ci = 0; ci < ctxKeys.length; ci++) {\n          var ctx = ctxKeys[ci];\n          cloneTypo.byContext[ctx] = tok.byContext[ctx];\n        }\n        if (typeof tok.description !== 'undefined') cloneTypo.description = tok.description;\n        if (typeof tok.extensions !== 'undefined') cloneTypo.extensions = tok.extensions;\n        typographyTokens.push(cloneTypo);\n      }\n    }\n\n    var typographyGraph: TokenGraph = { tokens: typographyTokens };\n    var typographySerialized = serialize(typographyGraph, { styleDictionary: styleDictionary, flatTokens: flatTokens });\n    var typographyJson = typographySerialized.json;\n    if (!typographyTokens.length) {\n      typographyJson = {};\n    }\n    return { files: [{ name: 'typography.json', json: typographyJson }] };\n  }\n\n  if (opts.format === 'single') {\n    // One file with whatever contexts exist; writer will emit the first available per token.\n    var single = serialize(graph, { styleDictionary: styleDictionary, flatTokens: flatTokens });\n    return { files: [{ name: 'tokens.json', json: single.json }] };\n  }\n\n  // Per mode: split graph by context \"Collection/Mode\", one file each.\n  var contexts: string[] = [];\n  var i = 0;\n  for (i = 0; i < graph.tokens.length; i++) {\n    var t = graph.tokens[i];\n    var ks = keysOf(t.byContext);\n    var j = 0;\n    for (j = 0; j < ks.length; j++) {\n      var c = ks[j];\n      // push if unique\n      var found = false;\n      var k = 0;\n      for (k = 0; k < contexts.length; k++) if (contexts[k] === c) { found = true; break; }\n      if (!found) contexts.push(c);\n    }\n  }\n\n  // Build a file per context\n  var files: Array<{ name: string; json: unknown }> = [];\n  var ci = 0;\n  for (ci = 0; ci < contexts.length; ci++) {\n    var ctx = contexts[ci];\n\n    // Create a filtered graph where each token only carries this ctx (if present)\n    var filtered: TokenGraph = { tokens: [] };\n    var ii = 0;\n    for (ii = 0; ii < graph.tokens.length; ii++) {\n      var tok = graph.tokens[ii];\n      var one = cloneTokenWithSingleContext(tok, ctx);\n      if (one) filtered.tokens.push(one);\n    }\n\n    // If nothing in this context, skip\n    if (filtered.tokens.length === 0) continue;\n\n    var out = serialize(filtered, { styleDictionary: styleDictionary, flatTokens: flatTokens });\n\n    // Try to recover the original collection/mode names from per-context metadata so\n    // we don't lose slashes or other punctuation that appears in the collection name.\n    var collection = ctx;\n    var mode = 'default';\n\n    var haveCollection = false;\n    var haveMode = false;\n    for (ii = 0; ii < filtered.tokens.length && (!haveCollection || !haveMode); ii++) {\n      var tok = filtered.tokens[ii];\n      if (!tok || !tok.extensions) continue;\n\n      var figmaExt = (tok.extensions as { [k: string]: unknown })['com.figma'] as\n        | { perContext?: { [ctx: string]: { collectionName?: string; modeName?: string } } }\n        | undefined;\n      if (!figmaExt || typeof figmaExt !== 'object') continue;\n\n      var perCtx = figmaExt.perContext;\n      if (!perCtx || typeof perCtx !== 'object') continue;\n\n      var ctxMeta = perCtx[ctx];\n      if (!ctxMeta || typeof ctxMeta !== 'object') continue;\n\n      var ctxCollection = (ctxMeta as { collectionName?: unknown }).collectionName;\n      var ctxMode = (ctxMeta as { modeName?: unknown }).modeName;\n\n      if (typeof ctxCollection === 'string' && !haveCollection) {\n        collection = ctxCollection;\n        haveCollection = true;\n      }\n      if (typeof ctxMode === 'string' && !haveMode) {\n        mode = ctxMode;\n        haveMode = true;\n      }\n    }\n\n    if (!haveCollection || !haveMode) {\n      // ctx format falls back to \"Collection/Mode\"\n      var slash = ctx.lastIndexOf('/');\n      collection = slash >= 0 ? ctx.substring(0, slash) : ctx;\n      mode = slash >= 0 ? ctx.substring(slash + 1) : 'default';\n    }\n\n    var fname = sanitizeForFile(collection) + '_mode=' + sanitizeForFile(mode) + '.tokens.json';\n    files.push({ name: fname, json: out.json });\n  }\n\n  // Fallback: if no contexts were found, still emit a single file\n  if (files.length === 0) {\n    var fallback = serialize(graph, { styleDictionary: styleDictionary, flatTokens: flatTokens });\n    files.push({ name: 'tokens.json', json: fallback.json });\n  }\n\n  return { files: files };\n}\n\nexport { sanitizeForFile };\n", "// src/core/github/api.ts\n// Lightweight GitHub API wrapper tuned for the Figma plugin sandbox.\n// - Wraps fetch with retries and rate-limit awareness\n// - Normalizes payloads so the UI layer stays framework-agnostic\n\n/* =========================\n * Common types & helpers\n * ========================= */\n\nexport interface GhUser {\n    login: string;\n    name?: string;\n}\n\nexport type GhUserResult =\n    | { ok: true; user: GhUser }\n    | { ok: false; error: string };\n\n/** Safe header getter that handles figma's Response polyfill. */\nfunction headerGet(h: any, key: string): string | null {\n    try {\n        if (h && typeof h.get === 'function') return h.get(key);\n    } catch { /* noop */ }\n    return null;\n}\n\nexport interface GhRateInfo {\n    remaining?: number;\n    resetEpochSec?: number;\n}\n\n/** Parse rate limit headers into a tiny struct (when present). */\nfunction parseRate(h: any): GhRateInfo | undefined {\n    const remainingStr = headerGet(h, 'x-ratelimit-remaining');\n    const resetStr = headerGet(h, 'x-ratelimit-reset');\n    const rate: GhRateInfo = {};\n    const rem = remainingStr ? parseInt(remainingStr, 10) : NaN;\n    const rst = resetStr ? parseInt(resetStr, 10) : NaN;\n    if (Number.isFinite(rem)) rate.remaining = rem;\n    if (Number.isFinite(rst)) rate.resetEpochSec = rst;\n    return (rate.remaining !== undefined || rate.resetEpochSec !== undefined) ? rate : undefined;\n}\n\n/** Always resolve `res.text()` without throwing, even inside the sandbox. */\nasync function safeText(res: any): Promise<string> {\n    try { return await res.text(); } catch { return ''; }\n}\n\n/** Base64 encode (Unicode safe) without using Node Buffer. */\nfunction b64(s: string): string {\n    try {\n        // Convert to UTF-8 first so btoa can handle it.\n        // unescape is fine here inside the sandbox and avoids a heavier polyfill.\n        return btoa(unescape(encodeURIComponent(s)));\n    } catch {\n        // Last-ditch fallback: encode bytes manually for btoa.\n        const enc = new TextEncoder();\n        const bytes = enc.encode(s);\n        let bin = '';\n        for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);\n        return btoa(bin);\n    }\n}\n\nconst INVALID_REPO_SEGMENT = /[<>:\"\\\\|?*\\u0000-\\u001F]/;\n\nfunction sanitizeRepoPathInput(path: string): { ok: true; path: string } | { ok: false; message: string } {\n    const collapsed = String(path || '')\n        .replace(/\\\\/g, '/')\n        .replace(/\\/{2,}/g, '/')\n        .replace(/^\\/+|\\/+$/g, '');\n\n    if (!collapsed) return { ok: true, path: '' };\n\n    const segments = collapsed.split('/').filter(Boolean);\n    for (const seg of segments) {\n        if (!seg) return { ok: false, message: 'Path contains an empty segment.' };\n        if (seg === '.' || seg === '..') {\n            return { ok: false, message: 'Path cannot include \".\" or \"..\" segments.' };\n        }\n        if (INVALID_REPO_SEGMENT.test(seg)) {\n            return { ok: false, message: `Path component \"${seg}\" contains invalid characters.` };\n        }\n    }\n\n    return { ok: true, path: segments.join('/') };\n}\n\n/** Encode a repo *path* but preserve `/` separators. */\nfunction encodePathSegments(path: string): string {\n    const sanitized = sanitizeRepoPathInput(path);\n    if (!sanitized.ok) throw new Error(sanitized.message);\n    if (!sanitized.path) return '';\n    return sanitized.path.split('/').map(encodeURIComponent).join('/');\n}\n\n/** Decode base64 text to UTF-8 while tolerating malformed inputs. */\nfunction decodeBase64ToUtf8(rawInput: string): string {\n    const cleaned = typeof rawInput === 'string' ? rawInput.trim() : '';\n    if (!cleaned) return '';\n    const stripWhitespace = cleaned.replace(/\\s+/g, '');\n    if (!stripWhitespace) return '';\n\n    const decodeBytes = (bytes: Uint8Array): string => {\n        if (typeof TextDecoder !== 'undefined') {\n            try {\n                return new TextDecoder().decode(bytes);\n            } catch { /* ignore */ }\n        }\n        let text = '';\n        for (let i = 0; i < bytes.length; i++) text += String.fromCharCode(bytes[i]);\n        try {\n            // escape is fine here; this path only runs in environments lacking TextDecoder\n            return decodeURIComponent(escape(text));\n        } catch {\n            return text;\n        }\n    };\n\n    if (typeof figma !== 'undefined' && typeof figma.base64Decode === 'function') {\n        try {\n            return decodeBytes(figma.base64Decode(stripWhitespace));\n        } catch { /* fall through */ }\n    }\n\n    if (typeof atob === 'function') {\n        try {\n            const bin = atob(stripWhitespace);\n            const bytes = new Uint8Array(bin.length);\n            for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);\n            return decodeBytes(bytes);\n        } catch {\n            try {\n                return decodeURIComponent(escape(atob(stripWhitespace)));\n            } catch { /* ignore */ }\n        }\n    }\n\n    const maybeBuffer = (globalThis as { Buffer?: { from(data: string, encoding: string): { toString(enc: string): string } } }).Buffer;\n    if (maybeBuffer && typeof maybeBuffer.from === 'function') {\n        try {\n            return maybeBuffer.from(stripWhitespace, 'base64').toString('utf8');\n        } catch { /* ignore */ }\n    }\n\n    return '';\n}\n\n/* =========================\n * Auth / Repos\n * ========================= */\n\n/** Verify the provided token and return the GitHub user profile. */\nexport async function ghGetUser(token: string): Promise<GhUserResult> {\n    try {\n        const res = await fetch('https://api.github.com/user', {\n            method: 'GET',\n            headers: {\n                'Authorization': `Bearer ${token}`,\n                'Accept': 'application/vnd.github+json',\n                'X-GitHub-Api-Version': '2022-11-28'\n            }\n        });\n        if (res.status === 401) return { ok: false, error: 'bad credentials' };\n        if (!res.ok) return { ok: false, error: `HTTP ${res.status}` };\n\n        const data = await res.json();\n        const login = typeof data?.login === 'string' ? data.login : '';\n        const name = typeof data?.name === 'string' ? data.name : undefined;\n        if (!login) return { ok: false, error: 'response missing login' };\n        return { ok: true, user: { login, name } };\n    } catch (e) {\n        return { ok: false, error: (e as Error)?.message || 'network error' };\n    }\n}\n\nexport interface GhRepo {\n    id: number;\n    name: string;\n    full_name: string;       // \"owner/repo\"\n    private: boolean;\n    default_branch: string;  // e.g., \"main\"\n    owner?: { login?: string };\n    permissions?: { admin?: boolean; push?: boolean; pull?: boolean };\n    fork?: boolean;\n}\n\nexport type GhListReposResult =\n    | { ok: true; repos: GhRepo[] }\n    | { ok: false; error: string };\n\n/** Fetch helper that retries transient failures a couple of times. */\nasync function fetchJsonWithRetry(url: string, init: any, tries = 2) {\n    let last: any;\n    for (let i = 0; i < tries; i++) {\n        try { return await fetch(url, init); }\n        catch (e) { last = e; await new Promise(r => setTimeout(r, 150)); }\n    }\n    throw last;\n}\n\n/** List the user's repositories with pagination and retry handling. */\nexport async function ghListRepos(token: string): Promise<GhListReposResult> {\n    try {\n        const base =\n            'https://api.github.com/user/repos' +\n            '?per_page=100&affiliation=owner,collaborator,organization_member&sort=updated';\n\n        const headers = {\n            'Authorization': `Bearer ${token}`,\n            'Accept': 'application/vnd.github+json',\n            'X-GitHub-Api-Version': '2022-11-28'\n        };\n\n        const all: GhRepo[] = [];\n        let page = 1;\n\n        while (true) {\n            const res = await fetchJsonWithRetry(`${base}&page=${page}`, { headers }, 2);\n            if (res.status === 401) return { ok: false, error: 'bad credentials' };\n            if (!res.ok) {\n                if (all.length) return { ok: true, repos: all };\n                return { ok: false, error: (await res.text()) || `HTTP ${res.status}` };\n            }\n\n            const arr = await res.json();\n            if (!Array.isArray(arr) || arr.length === 0) break;\n\n            for (const r of arr) {\n                if (r?.full_name) {\n                    all.push({\n                        id: r.id,\n                        name: r.name,\n                        full_name: r.full_name,\n                        private: !!r.private,\n                        default_branch: r.default_branch || 'main',\n                        owner: r.owner,\n                        permissions: r.permissions,\n                        fork: r.fork\n                    });\n                }\n            }\n\n            if (arr.length < 100) break;\n            page++;\n        }\n\n        return { ok: true, repos: all };\n    } catch (e) {\n        return { ok: false, error: (e as Error)?.message || 'network error' };\n    }\n}\n\n/* =========================\n * Branches\n * ========================= */\n\nexport type GhListBranchesResult =\n    | {\n        ok: true;\n        owner: string;\n        repo: string;\n        page: number;\n        branches: Array<{ name: string }>;\n        defaultBranch?: string;\n        hasMore: boolean;\n        rate?: GhRateInfo;\n    }\n    | {\n        ok: false;\n        owner: string;\n        repo: string;\n        status: number;\n        message: string;\n        samlRequired?: boolean;\n        rate?: GhRateInfo;\n    };\n\n/** List branches; when `force` add a ts param to bypass caches. */\n/** Fetch branches paginated, returning rate info alongside the data. */\nexport async function ghListBranches(\n    token: string,\n    owner: string,\n    repo: string,\n    page = 1,\n    force = false\n): Promise<GhListBranchesResult> {\n    const baseRepoUrl = `https://api.github.com/repos/${owner}/${repo}`;\n    const headers = {\n        'Authorization': `Bearer ${token}`,\n        'Accept': 'application/vnd.github+json',\n        'X-GitHub-Api-Version': '2022-11-28'\n    } as const;\n\n    const ts = force ? `&_ts=${Date.now()}` : '';\n\n    try {\n        const branchesUrl = `${baseRepoUrl}/branches?per_page=100&page=${page}${ts}`;\n        const res = await fetch(branchesUrl, { headers });\n\n        const rate = parseRate((res as any)?.headers);\n        const saml = headerGet((res as any)?.headers, 'x-github-saml');\n\n        if (res.status === 403 && saml) {\n            return {\n                ok: false, owner, repo, status: 403,\n                message: 'SAML/SSO required', samlRequired: true, rate\n            };\n        }\n\n        if (!res.ok) {\n            const text = await safeText(res);\n            return { ok: false, owner, repo, status: res.status, message: text || `HTTP ${res.status}`, rate };\n        }\n\n        const arr = await res.json();\n        const branches: Array<{ name: string }> = Array.isArray(arr)\n            ? arr.filter(b => b && typeof b.name === 'string').map(b => ({ name: b.name }))\n            : [];\n\n        const link = headerGet((res as any)?.headers, 'link');\n        let hasMore = false;\n        if (link && /\\brel=\"next\"/i.test(link)) hasMore = true;\n        else if (branches.length === 100) hasMore = true;\n\n        let defaultBranch: string | undefined;\n        if (page === 1) {\n            try {\n                const repoRes = await fetch(`${baseRepoUrl}${force ? `?_ts=${Date.now()}` : ''}`, { headers });\n                if (repoRes.ok) {\n                    const j = await repoRes.json();\n                    if (j && typeof j.default_branch === 'string') defaultBranch = j.default_branch;\n                }\n            } catch { /* ignore */ }\n        }\n\n        return { ok: true, owner, repo, page, branches, defaultBranch, hasMore, rate };\n    } catch (e) {\n        return { ok: false, owner, repo, status: 0, message: (e as Error)?.message || 'network error' };\n    }\n}\n\nexport type GhCreateBranchResult =\n    | {\n        ok: true;\n        owner: string;\n        repo: string;\n        baseBranch: string;\n        newBranch: string;\n        sha: string;\n        html_url: string;\n        rate?: GhRateInfo;\n    }\n    | {\n        ok: false;\n        owner: string;\n        repo: string;\n        baseBranch: string;\n        newBranch: string;\n        status: number;\n        message: string;\n        samlRequired?: boolean;\n        noPushPermission?: boolean;\n        rate?: GhRateInfo;\n    };\n\n/** Create a branch from the chosen base ref when the user requests a fork. */\nexport async function ghCreateBranch(\n    token: string,\n    owner: string,\n    repo: string,\n    newBranch: string,\n    baseBranch: string\n): Promise<GhCreateBranchResult> {\n    const baseRepoUrl = `https://api.github.com/repos/${owner}/${repo}`;\n    const headers = {\n        'Authorization': `Bearer ${token}`,\n        'Accept': 'application/vnd.github+json',\n        'X-GitHub-Api-Version': '2022-11-28'\n    } as const;\n\n    const branchName = String(newBranch || '').trim().replace(/^refs\\/heads\\//, '');\n    const baseName = String(baseBranch || '').trim().replace(/^refs\\/heads\\//, '');\n    if (!branchName || !baseName) {\n        return { ok: false, owner, repo, baseBranch: baseName, newBranch: branchName, status: 400, message: 'empty branch name(s)' };\n    }\n\n    try {\n        // Preflight: push permission & SAML hints\n        try {\n            const repoRes = await fetch(baseRepoUrl, { headers });\n            const rate0 = parseRate((repoRes as any)?.headers);\n            const saml0 = headerGet((repoRes as any)?.headers, 'x-github-saml');\n            if (repoRes.status === 403 && saml0) {\n                return { ok: false, owner, repo, baseBranch: baseName, newBranch: branchName, status: 403, message: 'SAML/SSO required', samlRequired: true, rate: rate0 };\n            }\n            if (!repoRes.ok) {\n                const text = await safeText(repoRes);\n                return { ok: false, owner, repo, baseBranch: baseName, newBranch: branchName, status: repoRes.status, message: text || `HTTP ${repoRes.status}` };\n            }\n            const repoJson = await repoRes.json();\n            const pushAllowed = !!(repoJson?.permissions?.push);\n            if (repoJson?.permissions && pushAllowed !== true) {\n                return { ok: false, owner, repo, baseBranch: baseName, newBranch: branchName, status: 403, message: 'Token/user lacks push permission to this repository', noPushPermission: true, rate: rate0 };\n            }\n        } catch { /* ignore */ }\n\n        // Resolve base \u2192 SHA\n        const refUrl = `${baseRepoUrl}/git/ref/heads/${encodeURIComponent(baseName)}`;\n        const refRes = await fetch(refUrl, { headers });\n        const rate1 = parseRate((refRes as any)?.headers);\n        const saml1 = headerGet((refRes as any)?.headers, 'x-github-saml');\n\n        if (refRes.status === 403 && saml1) {\n            return { ok: false, owner, repo, baseBranch: baseName, newBranch: branchName, status: 403, message: 'SAML/SSO required', samlRequired: true, rate: rate1 };\n        }\n        if (!refRes.ok) {\n            const text = await safeText(refRes);\n            return { ok: false, owner, repo, baseBranch: baseName, newBranch: branchName, status: refRes.status, message: text || `HTTP ${refRes.status}`, rate: rate1 };\n        }\n\n        const refJson = await refRes.json();\n        const sha = (refJson?.object?.sha || refJson?.sha || '').trim();\n        if (!sha) {\n            return { ok: false, owner, repo, baseBranch: baseName, newBranch: branchName, status: 500, message: 'could not resolve base SHA' };\n        }\n\n        // Create ref\n        const createUrl = `${baseRepoUrl}/git/refs`;\n        const body = JSON.stringify({ ref: `refs/heads/${branchName}`, sha });\n        const createRes = await fetch(createUrl, { method: 'POST', headers, body });\n        const rate2 = parseRate((createRes as any)?.headers);\n        const saml2 = headerGet((createRes as any)?.headers, 'x-github-saml');\n\n        if (createRes.status === 403 && saml2) {\n            return { ok: false, owner, repo, baseBranch: baseName, newBranch: branchName, status: 403, message: 'SAML/SSO required', samlRequired: true, rate: rate2 };\n        }\n        if (!createRes.ok) {\n            const text = await safeText(createRes);\n            return { ok: false, owner, repo, baseBranch: baseName, newBranch: branchName, status: createRes.status, message: text || `HTTP ${createRes.status}`, rate: rate2 };\n        }\n\n        const html_url = `https://github.com/${owner}/${repo}/tree/${encodeURIComponent(branchName)}`;\n        return { ok: true, owner, repo, baseBranch: baseName, newBranch: branchName, sha, html_url, rate: rate2 };\n    } catch (e) {\n        return { ok: false, owner, repo, baseBranch: baseName, newBranch: branchName, status: 0, message: (e as Error)?.message || 'network error' };\n    }\n}\n\n/* =========================\n * Contents API: list & ensure folder\n * ========================= */\n\nexport type GhDirEntry = {\n    type: 'dir' | 'file';\n    name: string;\n    path: string;\n};\n\nexport type GhListDirResult =\n    | {\n        ok: true;\n        owner: string;\n        repo: string;\n        ref: string;\n        path: string;\n        entries: GhDirEntry[];\n        rate?: GhRateInfo;\n    }\n    | {\n        ok: false;\n        owner: string;\n        repo: string;\n        ref: string;\n        path: string;\n        status: number;\n        message: string;\n        rate?: GhRateInfo;\n    };\n\n/** GET /repos/{owner}/{repo}/contents/{path}?ref={ref} */\n/** List a single directory in a repo, returning both dir and file entries. */\nexport async function ghListDir(\n    token: string,\n    owner: string,\n    repo: string,\n    path: string,\n    ref: string\n): Promise<GhListDirResult> {\n    const baseRepoUrl = `https://api.github.com/repos/${owner}/${repo}`;\n    const sanitized = sanitizeRepoPathInput(path);\n    if (!sanitized.ok) {\n        return {\n            ok: false,\n            owner,\n            repo,\n            ref,\n            path: String(path || '').replace(/^\\/+|\\/+$/g, ''),\n            status: 400,\n            message: sanitized.message\n        };\n    }\n    const rel = sanitized.path\n        ? sanitized.path.split('/').map(encodeURIComponent).join('/')\n        : '';\n    const canonicalPath = sanitized.path;\n    const url = rel\n        ? `${baseRepoUrl}/contents/${rel}?ref=${encodeURIComponent(ref)}&_ts=${Date.now()}`\n        : `${baseRepoUrl}/contents?ref=${encodeURIComponent(ref)}&_ts=${Date.now()}`;\n    const headers = {\n        'Authorization': `Bearer ${token}`,\n        'Accept': 'application/vnd.github+json',\n        'X-GitHub-Api-Version': '2022-11-28'\n    } as const;\n\n    try {\n        const res = await fetch(url, { headers });\n        const rate = parseRate((res as any)?.headers);\n        if (!res.ok) {\n            const msg = await safeText(res);\n            return {\n                ok: false,\n                owner, repo, ref, path: canonicalPath,\n                status: res.status,\n                message: msg || `HTTP ${res.status}`,\n                rate\n            };\n        }\n        const json = await res.json();\n        if (!Array.isArray(json)) {\n            const type = typeof json?.type === 'string' ? json.type : '';\n            const status = type === 'file' ? 409 : 400;\n            const message = type === 'file'\n                ? 'GitHub: Path is a file, not a folder.'\n                : 'GitHub: Unable to list path as a folder.';\n            return {\n                ok: false,\n                owner, repo, ref,\n                path: canonicalPath,\n                status,\n                message,\n                rate\n            };\n        }\n        const entries: GhDirEntry[] = json.map((it: any) => ({\n            type: it?.type === 'dir' ? 'dir' : 'file',\n            name: String(it?.name || ''),\n            path: String(it?.path || '')\n        }));\n        return {\n            ok: true,\n            owner, repo, ref,\n            path: canonicalPath,\n            entries,\n            rate\n        };\n    } catch (e) {\n        return {\n            ok: false,\n            owner, repo, ref,\n            path: canonicalPath,\n            status: 0,\n            message: (e as Error)?.message || 'network error'\n        };\n    }\n}\n\n/** Wrapper that returns ONLY directories (keeps a legacy `dirs` array). */\nexport type GhListDirsResult =\n    | {\n        ok: true;\n        owner: string;\n        repo: string;\n        branch: string;\n        path: string;\n        entries: GhDirEntry[]; // dirs only\n        dirs: Array<{ name: string; path: string }>;\n        rate?: GhRateInfo;\n    }\n    | {\n        ok: false;\n        owner: string;\n        repo: string;\n        branch: string;\n        path: string;\n        status: number;\n        message: string;\n        samlRequired?: boolean;\n        rate?: GhRateInfo;\n    };\n\n/** Walk paginated folder listings and stream results back to the caller. */\nexport async function ghListDirs(\n    token: string,\n    owner: string,\n    repo: string,\n    branch: string,\n    path = ''\n): Promise<GhListDirsResult> {\n    const res = await ghListDir(token, owner, repo, path, branch);\n    if (!res.ok) {\n        return {\n            ok: false,\n            owner, repo, branch,\n            path: res.path,\n            status: res.status,\n            message: res.message,\n            samlRequired: /SAML|SSO/i.test(res.message || '') || res.status === 403\n        };\n    }\n    const onlyDirs = res.entries.filter(e => e.type === 'dir');\n    return {\n        ok: true,\n        owner, repo, branch,\n        path: res.path,\n        entries: onlyDirs,\n        dirs: onlyDirs.map(d => ({ name: d.name, path: d.path })),\n        rate: res.rate\n    };\n}\n\n/* ---------- Ensure folder (materialize if empty) ---------- */\n\nexport type GhEnsureFolderResult =\n    | {\n        ok: true;\n        owner: string;\n        repo: string;\n        branch: string;\n        folderPath: string; // normalized\n        created: boolean;   // true if a placeholder commit was needed\n        fileSha?: string;\n        html_url?: string;\n        rate?: GhRateInfo;\n    }\n    | {\n        ok: false;\n        owner: string;\n        repo: string;\n        branch: string;\n        folderPath: string;\n        status: number;\n        message: string;\n        samlRequired?: boolean;\n        noPushPermission?: boolean;\n        rate?: GhRateInfo;\n    };\n\n/** Create nested folders by committing empty `.keep` blobs as needed. */\nexport async function ghEnsureFolder(\n    token: string,\n    owner: string,\n    repo: string,\n    branch: string,\n    folderPath: string\n): Promise<GhEnsureFolderResult> {\n    const baseRepoUrl = `https://api.github.com/repos/${owner}/${repo}`;\n    const headers = {\n        'Authorization': `Bearer ${token}`,\n        'Accept': 'application/vnd.github+json',\n        'X-GitHub-Api-Version': '2022-11-28'\n    } as const;\n\n    const sanitized = sanitizeRepoPathInput(folderPath);\n    if (!sanitized.ok) {\n        return { ok: false, owner, repo, branch, folderPath: '', status: 400, message: sanitized.message };\n    }\n    const norm = sanitized.path;\n    if (!norm) {\n        return { ok: false, owner, repo, branch, folderPath: norm, status: 400, message: 'empty folder path' };\n    }\n\n    try {\n        // Exists already?\n        {\n            const rel = encodePathSegments(norm);\n            const url = `${baseRepoUrl}/contents/${rel}?ref=${encodeURIComponent(branch)}&_ts=${Date.now()}`;\n            const res = await fetch(url, { headers });\n            const rate = parseRate((res as any)?.headers);\n            const saml = headerGet((res as any)?.headers, 'x-github-saml');\n\n            if (res.status === 403 && saml) {\n                return { ok: false, owner, repo, branch, folderPath: norm, status: 403, message: 'SAML/SSO required', samlRequired: true, rate };\n            }\n\n            if (res.ok) {\n                return {\n                    ok: true,\n                    owner, repo, branch,\n                    folderPath: norm,\n                    created: false,\n                    html_url: `https://github.com/${owner}/${repo}/tree/${encodeURIComponent(branch)}/${encodePathSegments(norm)}`,\n                    rate\n                };\n            }\n            if (res.status !== 404) {\n                const text = await safeText(res);\n                return { ok: false, owner, repo, branch, folderPath: norm, status: res.status, message: text || `HTTP ${res.status}`, rate };\n            }\n        }\n\n        // Materialize with .gitkeep\n        const placeholderRel = `${norm}/.gitkeep`;\n        const putUrl = `${baseRepoUrl}/contents/${encodePathSegments(placeholderRel)}`;\n        const body = JSON.stringify({\n            message: `chore: create folder ${norm}`,\n            content: b64('.'),\n            branch\n        });\n\n        const putRes = await fetch(putUrl, { method: 'PUT', headers, body });\n        const rate2 = parseRate((putRes as any)?.headers);\n        const saml2 = headerGet((putRes as any)?.headers, 'x-github-saml');\n\n        if (putRes.status === 403 && saml2) {\n            return { ok: false, owner, repo, branch, folderPath: norm, status: 403, message: 'SAML/SSO required', samlRequired: true, rate: rate2 };\n        }\n        if (!putRes.ok) {\n            const text = await safeText(putRes);\n            return { ok: false, owner, repo, branch, folderPath: norm, status: putRes.status, message: text || `HTTP ${putRes.status}`, rate: rate2 };\n        }\n\n        const j = await putRes.json();\n        const fileSha = j?.content?.sha || j?.commit?.sha || '';\n\n        return {\n            ok: true,\n            owner, repo, branch,\n            folderPath: norm,\n            created: true,\n            fileSha,\n            html_url: `https://github.com/${owner}/${repo}/tree/${encodeURIComponent(branch)}/${encodePathSegments(norm)}`,\n            rate: rate2\n        };\n    } catch (e) {\n        return { ok: false, owner, repo, branch, folderPath: norm, status: 0, message: (e as Error)?.message || 'network error' };\n    }\n}\n\n// ---------- Single-commit file writer (Git Data API) ----------\n\nexport type GhCommitFile = {\n    path: string;      // e.g., \"tokens/My File.json\" (may include subfolders)\n    content: string;   // file contents as UTF-8 text (we use blobs with encoding: 'utf-8')\n    mode?: '100644';   // normal file; left optional\n};\n\nexport type GhCommitFilesResult =\n    | {\n        ok: true;\n        owner: string;\n        repo: string;\n        branch: string;\n        commitSha: string;\n        commitUrl: string;         // https://github.com/{owner}/{repo}/commit/{sha}\n        treeUrl?: string;\n        rate?: GhRateInfo;\n    }\n    | {\n        ok: false;\n        owner: string;\n        repo: string;\n        branch: string;\n        status: number;\n        message: string;\n        rate?: GhRateInfo;\n    };\n\n/**\n * Writes one or more files to a repo as a single commit on a branch.\n * Uses Git Data API: blobs \u2192 tree \u2192 commit \u2192 update ref.\n * No extra commits to \"create folders\"; tree paths handle that.\n */\n/** Create or update a commit containing the provided files on the target branch. */\nexport async function ghCommitFiles(\n    token: string,\n    owner: string,\n    repo: string,\n    branch: string,\n    message: string,\n    files: GhCommitFile[]\n): Promise<GhCommitFilesResult> {\n    const base = `https://api.github.com/repos/${owner}/${repo}`;\n    const headers = {\n        Authorization: `Bearer ${token}`,\n        Accept: 'application/vnd.github+json',\n        'X-GitHub-Api-Version': '2022-11-28'\n    } as const;\n\n    function normPath(p: string): string {\n        const sanitized = sanitizeRepoPathInput(p);\n        if (!sanitized.ok) throw new Error(sanitized.message);\n        return sanitized.path;\n    }\n\n    const cleaned: GhCommitFile[] = [];\n    for (let i = 0; i < files.length; i++) {\n        const src = files[i];\n        let normalizedPath: string;\n        try {\n            normalizedPath = normPath(src.path);\n        } catch (err) {\n            return { ok: false, owner, repo, branch, status: 400, message: (err as Error)?.message || 'invalid path' };\n        }\n        if (!normalizedPath) continue;\n        if (typeof src.content !== 'string') continue;\n        cleaned.push({\n            path: normalizedPath,\n            content: src.content,\n            mode: src.mode || '100644'\n        });\n    }\n\n    if (cleaned.length === 0) {\n        return { ok: false, owner, repo, branch, status: 400, message: 'no files to commit' };\n    }\n\n    try {\n        // 1) Resolve branch \u2192 commit SHA\n        const cacheBust = `_ts=${Date.now()}`;\n        const refRes = await fetch(`${base}/git/ref/heads/${encodeURIComponent(branch)}?${cacheBust}`, { headers });\n        const rate1 = parseRate((refRes as any)?.headers);\n        if (!refRes.ok) {\n            const text = await safeText(refRes);\n            return { ok: false, owner, repo, branch, status: refRes.status, message: text || `HTTP ${refRes.status}`, rate: rate1 };\n        }\n        const refJson = await refRes.json();\n        const baseCommitSha: string = (refJson?.object?.sha || refJson?.sha || '').trim();\n        if (!baseCommitSha) {\n            return { ok: false, owner, repo, branch, status: 500, message: 'could not resolve branch commit sha', rate: rate1 };\n        }\n\n        // 2) Resolve base commit \u2192 tree SHA\n        const commitRes = await fetch(`${base}/git/commits/${baseCommitSha}?${cacheBust}`, { headers });\n        const rate2 = parseRate((commitRes as any)?.headers);\n        if (!commitRes.ok) {\n            const text = await safeText(commitRes);\n            return { ok: false, owner, repo, branch, status: commitRes.status, message: text || `HTTP ${commitRes.status}`, rate: rate2 };\n        }\n        const commitJson = await commitRes.json();\n        const baseTreeSha: string = (commitJson?.tree?.sha || '').trim();\n        if (!baseTreeSha) {\n            return { ok: false, owner, repo, branch, status: 500, message: 'could not resolve base tree sha', rate: rate2 };\n        }\n\n        // 3) Create blobs for each file\n        const blobShas: string[] = [];\n        for (let i = 0; i < cleaned.length; i++) {\n            const blobRes = await fetch(`${base}/git/blobs`, {\n                method: 'POST',\n                headers,\n                body: JSON.stringify({ content: cleaned[i].content, encoding: 'utf-8' })\n            });\n            const rateB = parseRate((blobRes as any)?.headers);\n            if (!blobRes.ok) {\n                const text = await safeText(blobRes);\n                return { ok: false, owner, repo, branch, status: blobRes.status, message: text || `HTTP ${blobRes.status}`, rate: rateB };\n            }\n            const blobJson = await blobRes.json();\n            const blobSha: string = (blobJson?.sha || '').trim();\n            if (!blobSha) {\n                return { ok: false, owner, repo, branch, status: 500, message: 'failed to create blob sha' };\n            }\n            blobShas.push(blobSha);\n        }\n\n        // 4) Create a new tree using those blobs at the desired paths\n        const treeEntries = cleaned.map((f, idx) => ({\n            path: f.path, type: 'blob', mode: f.mode!, sha: blobShas[idx]\n        }));\n        const treeRes = await fetch(`${base}/git/trees`, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify({ base_tree: baseTreeSha, tree: treeEntries })\n        });\n        const rate3 = parseRate((treeRes as any)?.headers);\n        if (!treeRes.ok) {\n            const text = await safeText(treeRes);\n            return { ok: false, owner, repo, branch, status: treeRes.status, message: text || `HTTP ${treeRes.status}`, rate: rate3 };\n        }\n        const treeJson = await treeRes.json();\n        const newTreeSha: string = (treeJson?.sha || '').trim();\n        if (!newTreeSha) {\n            return { ok: false, owner, repo, branch, status: 500, message: 'failed to create tree sha' };\n        }\n\n        // 5) Create a commit with that tree and parent = current branch commit\n        const commitCreateRes = await fetch(`${base}/git/commits`, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify({ message, tree: newTreeSha, parents: [baseCommitSha] })\n        });\n        const rate4 = parseRate((commitCreateRes as any)?.headers);\n        if (!commitCreateRes.ok) {\n            const text = await safeText(commitCreateRes);\n            return { ok: false, owner, repo, branch, status: commitCreateRes.status, message: text || `HTTP ${commitCreateRes.status}`, rate: rate4 };\n        }\n        const newCommit = await commitCreateRes.json();\n        const newCommitSha: string = (newCommit?.sha || '').trim();\n        if (!newCommitSha) {\n            return { ok: false, owner, repo, branch, status: 500, message: 'failed to create commit sha' };\n        }\n\n        // 6) Fast-forward the branch to the new commit\n        const updateRefRes = await fetch(`${base}/git/refs/heads/${encodeURIComponent(branch)}`, {\n            method: 'PATCH',\n            headers,\n            body: JSON.stringify({ sha: newCommitSha, force: false })\n        });\n        const rate5 = parseRate((updateRefRes as any)?.headers);\n        if (!updateRefRes.ok) {\n            const text = await safeText(updateRefRes);\n            return { ok: false, owner, repo, branch, status: updateRefRes.status, message: text || `HTTP ${updateRefRes.status}`, rate: rate5 };\n        }\n\n        return {\n            ok: true,\n            owner, repo, branch,\n            commitSha: newCommitSha,\n            commitUrl: `https://github.com/${owner}/${repo}/commit/${newCommitSha}`,\n            treeUrl: `https://github.com/${owner}/${repo}/tree/${encodeURIComponent(branch)}`,\n            rate: rate5\n        };\n    } catch (e) {\n        return { ok: false, owner, repo, branch, status: 0, message: (e as Error)?.message || 'network error' };\n    }\n}\n\n/* =========================\n * File contents\n * ========================= */\n\nexport type GhGetFileContentsResult =\n    | {\n        ok: true;\n        owner: string;\n        repo: string;\n        branch: string;\n        path: string;\n        sha: string;\n        size?: number;\n        contentText: string;\n        encoding: string;\n        rate?: GhRateInfo;\n    }\n    | {\n        ok: false;\n        owner: string;\n        repo: string;\n        branch: string;\n        path: string;\n        status: number;\n        message: string;\n        rate?: GhRateInfo;\n        isDirectory?: boolean;\n        samlRequired?: boolean;\n    };\n\n/** Fetch a file and decode it to UTF-8 so previews can render cleanly. */\nexport async function ghGetFileContents(\n    token: string,\n    owner: string,\n    repo: string,\n    branch: string,\n    path: string\n): Promise<GhGetFileContentsResult> {\n    const sanitized = sanitizeRepoPathInput(path);\n    if (!sanitized.ok) {\n        return { ok: false, owner, repo, branch, path: '', status: 400, message: sanitized.message };\n    }\n    if (!sanitized.path) {\n        return { ok: false, owner, repo, branch, path: '', status: 400, message: 'Empty path' };\n    }\n    const cleanPath = sanitized.path;\n    const base = `https://api.github.com/repos/${owner}/${repo}/contents/${cleanPath.split('/').map(encodeURIComponent).join('/')}`;\n    const url = `${base}?ref=${encodeURIComponent(branch)}`;\n    const headers = {\n        Authorization: `Bearer ${token}`,\n        Accept: 'application/vnd.github+json',\n        'X-GitHub-Api-Version': '2022-11-28'\n    } as const;\n\n    try {\n        const res = await fetch(url, { headers });\n        const rate = parseRate((res as any)?.headers);\n        const saml = headerGet((res as any)?.headers, 'x-github-saml');\n\n        if (res.status === 403 && saml) {\n            return { ok: false, owner, repo, branch, path: cleanPath, status: 403, message: 'SAML/SSO required', samlRequired: true, rate };\n        }\n\n        if (!res.ok) {\n            const text = await safeText(res);\n            return { ok: false, owner, repo, branch, path: cleanPath, status: res.status, message: text || `HTTP ${res.status}`, rate };\n        }\n\n        const json = await res.json();\n        if (Array.isArray(json)) {\n            return {\n                ok: false,\n                owner,\n                repo,\n                branch,\n                path: cleanPath,\n                status: 409,\n                message: 'Path refers to a directory. Provide a file path.',\n                rate,\n                isDirectory: true\n            };\n        }\n\n        const encoding = typeof json?.encoding === 'string' ? json.encoding : '';\n        const content = typeof json?.content === 'string' ? json.content : '';\n        const sha = typeof json?.sha === 'string' ? json.sha : '';\n        const size = typeof json?.size === 'number' ? json.size : undefined;\n\n        if (!content) {\n            return { ok: false, owner, repo, branch, path: cleanPath, status: 422, message: 'File had no content', rate };\n        }\n\n        let text = content;\n        if (encoding === 'base64') {\n            text = decodeBase64ToUtf8(content.replace(/\\s+/g, ''));\n        }\n\n        return {\n            ok: true,\n            owner,\n            repo,\n            branch,\n            path: cleanPath,\n            sha,\n            size,\n            contentText: text,\n            encoding,\n            rate\n        };\n    } catch (e) {\n        return { ok: false, owner, repo, branch, path: cleanPath, status: 0, message: (e as Error)?.message || 'network error' };\n    }\n}\n\n/* =========================\n * Pull requests\n * ========================= */\n\nexport type GhCreatePullRequestResult =\n    | {\n        ok: true;\n        owner: string;\n        repo: string;\n        base: string;\n        head: string;\n        number: number;\n        url: string;\n        rate?: GhRateInfo;\n        alreadyExists?: false;\n    }\n    | {\n        ok: false;\n        owner: string;\n        repo: string;\n        base: string;\n        head: string;\n        status: number;\n        message: string;\n        rate?: GhRateInfo;\n        alreadyExists?: boolean;\n        samlRequired?: boolean;\n    };\n\n/** Create a draft or regular pull request against the selected repository. */\nexport async function ghCreatePullRequest(\n    token: string,\n    owner: string,\n    repo: string,\n    params: { title: string; head: string; base: string; body?: string }\n): Promise<GhCreatePullRequestResult> {\n    const url = `https://api.github.com/repos/${owner}/${repo}/pulls`;\n    const headers = {\n        Authorization: `Bearer ${token}`,\n        Accept: 'application/vnd.github+json',\n        'X-GitHub-Api-Version': '2022-11-28'\n    } as const;\n\n    const title = String(params.title || '').trim();\n    const head = String(params.head || '').trim();\n    const base = String(params.base || '').trim();\n    const body = typeof params.body === 'string' && params.body.length ? params.body : undefined;\n\n    if (!title || !head || !base) {\n        return { ok: false, owner, repo, base, head, status: 400, message: 'missing PR parameters' };\n    }\n\n    try {\n        const res = await fetch(url, {\n            method: 'POST',\n            headers,\n            body: JSON.stringify({ title, head, base, body })\n        });\n        const rate = parseRate((res as any)?.headers);\n        const saml = headerGet((res as any)?.headers, 'x-github-saml');\n\n        if (res.status === 403 && saml) {\n            return { ok: false, owner, repo, base, head, status: 403, message: 'SAML/SSO required', samlRequired: true, rate };\n        }\n\n        if (!res.ok) {\n            const text = await safeText(res);\n            const msg = text || `HTTP ${res.status}`;\n            const already = res.status === 422 && /already exists/i.test(msg);\n            return { ok: false, owner, repo, base, head, status: res.status, message: msg, rate, alreadyExists: already };\n        }\n\n        const json = await res.json();\n        const number = typeof json?.number === 'number' ? json.number : 0;\n        const prUrl = typeof json?.html_url === 'string' ? json.html_url : '';\n\n        if (!number || !prUrl) {\n            return { ok: false, owner, repo, base, head, status: 500, message: 'invalid PR response', rate };\n        }\n\n        return { ok: true, owner, repo, base, head, number, url: prUrl, rate };\n    } catch (e) {\n        return { ok: false, owner, repo, base, head, status: 0, message: (e as Error)?.message || 'network error' };\n    }\n}\n", "// src/app/github/folders.ts\n// Shared helpers for normalizing GitHub folder inputs.\n\nconst INVALID_FOLDER_SEGMENT = /[<>:\"\\\\|?*\\u0000-\\u001F]/;\n\ntype FolderNormalization =\n  | { ok: true; storage: string }\n  | { ok: false; message: string };\n\ntype FolderCommitPath =\n  | { ok: true; path: string }\n  | { ok: false; message: string };\n\nfunction validateFolderSegments(segments: string[]): string | null {\n  for (let i = 0; i < segments.length; i++) {\n    const seg = segments[i];\n    if (!seg) return 'GitHub: Folder path has an empty segment.';\n    if (seg === '.' || seg === '..') {\n      return 'GitHub: Folder path cannot include \".\" or \"..\" segments.';\n    }\n    if (INVALID_FOLDER_SEGMENT.test(seg)) {\n      return `GitHub: Folder segment \"${seg}\" contains invalid characters.`;\n    }\n  }\n  return null;\n}\n\nexport function normalizeFolderForStorage(raw: string): FolderNormalization {\n  const trimmed = (raw ?? '').trim();\n  if (!trimmed) return { ok: true, storage: '' };\n  if (trimmed === '/' || trimmed === './' || trimmed === '.') return { ok: true, storage: '/' };\n\n  const collapsed = trimmed.replace(/\\\\/g, '/').replace(/\\/{2,}/g, '/');\n  const stripped = collapsed.replace(/^\\/+/, '').replace(/\\/+$/, '');\n  if (!stripped) return { ok: true, storage: '/' };\n\n  const segments = stripped.split('/').filter(Boolean);\n  const err = validateFolderSegments(segments);\n  if (err) return { ok: false, message: err };\n  return { ok: true, storage: segments.join('/') };\n}\n\nexport function folderStorageToCommitPath(stored: string): FolderCommitPath {\n  if (!stored) return { ok: true, path: '' };\n  if (stored === '/' || stored === './' || stored === '.') return { ok: true, path: '' };\n\n  const collapsed = stored.replace(/\\\\/g, '/').replace(/\\/{2,}/g, '/');\n  const stripped = collapsed.replace(/^\\/+/, '').replace(/\\/+$/, '');\n  if (!stripped) return { ok: true, path: '' };\n\n  const segments = stripped.split('/').filter(Boolean);\n  const err = validateFolderSegments(segments);\n  if (err) return { ok: false, message: err };\n  return { ok: true, path: segments.join('/') };\n}\n", "// src/app/github/filenames.ts\n// Shared helpers for validating GitHub export filenames so UI and plugin stay in sync.\n\nexport const DEFAULT_GITHUB_FILENAME = 'tokens.json';\nconst INVALID_FILENAME_CHARS = /[<>:\"/\\\\|?*\\u0000-\\u001F]/;\nconst MAX_FILENAME_LENGTH = 128;\n\nexport type GithubFilenameValidation =\n  | { ok: true; filename: string }\n  | { ok: false; message: string };\n\nexport function validateGithubFilename(raw: string | null | undefined): GithubFilenameValidation {\n  const initial = typeof raw === 'string' ? raw : DEFAULT_GITHUB_FILENAME;\n  const trimmed = initial.trim();\n  if (!trimmed) {\n    return { ok: false, message: 'GitHub: Enter a filename (e.g., tokens.json).' };\n  }\n  if (trimmed === '.' || trimmed === '..') {\n    return { ok: false, message: 'GitHub: Filename cannot be \".\" or \"..\".' };\n  }\n  if (trimmed.length > MAX_FILENAME_LENGTH) {\n    return { ok: false, message: `GitHub: Filename must be ${MAX_FILENAME_LENGTH} characters or fewer.` };\n  }\n  if (INVALID_FILENAME_CHARS.test(trimmed)) {\n    return { ok: false, message: 'GitHub: Filename contains unsupported characters like / \\\\ : * ? \" < > |.' };\n  }\n  if (!/\\.json$/i.test(trimmed)) {\n    return { ok: false, message: 'GitHub: Filename must end with .json.' };\n  }\n  return { ok: true, filename: trimmed };\n}\n", "import {\n    ghGetUser,\n    ghListRepos,\n    ghListBranches,\n    ghCreateBranch,\n    ghListDirs,\n    ghEnsureFolder,\n    ghCommitFiles,\n    ghGetFileContents,\n    ghCreatePullRequest,\n} from \"../../core/github/api\";\nimport type { UiToPlugin, PluginToUi, GithubScope } from \"../messages\";\nimport {\n    normalizeFolderForStorage,\n    folderStorageToCommitPath,\n} from \"./folders\";\nimport { validateGithubFilename, DEFAULT_GITHUB_FILENAME } from \"./filenames\";\n\ntype SnapshotFn = typeof import(\"../collections\").snapshotCollectionsForUi;\ntype AnalyzeSelectionFn = typeof import(\"../collections\").analyzeSelectionState;\ntype SafeKeyFn = typeof import(\"../collections\").safeKeyFromCollectionAndMode;\ntype ImportFn = typeof import(\"../../core/pipeline\").importDtcg;\ntype ExportFn = typeof import(\"../../core/pipeline\").exportDtcg;\n\ntype HandlerDeps = {\n    send: (msg: PluginToUi) => void;\n    snapshotCollectionsForUi: SnapshotFn;\n    analyzeSelectionState: AnalyzeSelectionFn;\n    safeKeyFromCollectionAndMode: SafeKeyFn;\n    importDtcg: ImportFn;\n    exportDtcg: ExportFn;\n};\n\ntype GhSelected = {\n    owner?: string;\n    repo?: string;\n    branch?: string;\n    folder?: string;\n    filename?: string;\n    commitMessage?: string;\n    scope?: GithubScope;\n    collection?: string;\n    mode?: string;\n    styleDictionary?: boolean;\n    flatTokens?: boolean;\n    createPr?: boolean;\n    prBase?: string;\n    prTitle?: string;\n    prBody?: string;\n};\n\ntype GithubDispatcher = {\n    handle: (msg: UiToPlugin) => Promise<boolean>;\n    onUiReady: () => Promise<void>;\n};\n\nconst GH_SELECTED_KEY = \"gh.selected\";\nconst GH_LAST_COMMIT_KEY = \"gh.lastCommitSignature\";\n\nfunction encodeToken(s: string): string {\n    try {\n        return btoa(s);\n    } catch {\n        return s;\n    }\n}\n\nfunction decodeToken(s: string): string {\n    try {\n        return atob(s);\n    } catch {\n        return s;\n    }\n}\n\nfunction sleep(ms: number) {\n    return new Promise<void>((resolve) => setTimeout(resolve, ms));\n}\n\nexport function createGithubDispatcher(deps: HandlerDeps): GithubDispatcher {\n    let ghToken: string | null = null;\n\n    async function getSelected(): Promise<GhSelected> {\n        try {\n            return (await figma.clientStorage.getAsync(GH_SELECTED_KEY)) ?? {};\n        } catch {\n            return {};\n        }\n    }\n\n    async function setSelected(sel: GhSelected): Promise<void> {\n        try {\n            await figma.clientStorage.setAsync(GH_SELECTED_KEY, sel);\n        } catch {\n            /* ignore */\n        }\n    }\n\n    async function mergeSelected(\n        partial: Partial<GhSelected>\n    ): Promise<GhSelected> {\n        const current = await getSelected();\n        const merged = { ...current, ...partial };\n        await setSelected(merged);\n    return merged;\n}\n\ntype CommitSignature = { branch: string; fullPath: string; scope: GithubScope };\n\nasync function getLastCommitSignature(): Promise<CommitSignature | null> {\n    try {\n        const stored = await figma.clientStorage.getAsync(GH_LAST_COMMIT_KEY);\n        if (\n            stored &&\n            typeof stored === \"object\" &&\n            typeof (stored as { branch?: unknown }).branch === \"string\" &&\n            typeof (stored as { fullPath?: unknown }).fullPath === \"string\"\n        ) {\n            return {\n                branch: (stored as { branch: string }).branch,\n                fullPath: (stored as { fullPath: string }).fullPath,\n                scope:\n                    typeof (stored as { scope?: unknown }).scope === \"string\" &&\n                    ((stored as { scope?: unknown }).scope === \"all\" ||\n                        (stored as { scope?: unknown }).scope === \"selected\" ||\n                        (stored as { scope?: unknown }).scope === \"typography\")\n                        ? ((stored as { scope: GithubScope }).scope as GithubScope)\n                        : \"selected\",\n            };\n        }\n    } catch {\n        /* ignore */\n    }\n    return null;\n}\n\nasync function setLastCommitSignature(sig: CommitSignature): Promise<void> {\n    try {\n        await figma.clientStorage.setAsync(GH_LAST_COMMIT_KEY, sig);\n    } catch {\n        /* ignore */\n    }\n}\n\n    function pickPerModeFile(\n        files: Array<{ name: string; json: unknown }>,\n        collectionName: string,\n        modeName: string\n    ): { name: string; json: unknown } | null {\n        const prettyExact = `${collectionName} - ${modeName}.json`;\n        const prettyLoose = `${collectionName} - ${modeName}`;\n        const legacy1 = `${collectionName}_mode=${modeName}`;\n        const legacy2 = `${collectionName}/mode=${modeName}`;\n        const legacy3 = deps.safeKeyFromCollectionAndMode(\n            collectionName,\n            modeName\n        );\n\n        let picked = files.find((f) => {\n            const n = String(f?.name || \"\");\n            return (\n                n === prettyExact ||\n                n === prettyLoose ||\n                n.includes(`${collectionName} - ${modeName}`)\n            );\n        });\n        if (!picked) {\n            picked = files.find((f) => {\n                const n = String(f?.name || \"\");\n                return (\n                    n.includes(legacy1) ||\n                    n.includes(legacy2) ||\n                    n.includes(legacy3)\n                );\n            });\n        }\n        return picked || null;\n    }\n\n    async function listAndSendRepos(token: string): Promise<void> {\n        await sleep(75);\n        let repos = await ghListRepos(token);\n        if (\n            !repos.ok &&\n            /Failed to fetch|network error/i.test(repos.error || \"\")\n        ) {\n            await sleep(200);\n            repos = await ghListRepos(token);\n        }\n        if (repos.ok) {\n            const minimal = repos.repos.map((r) => ({\n                full_name: r.full_name,\n                default_branch: r.default_branch,\n                private: !!r.private,\n            }));\n            deps.send({ type: \"GITHUB_REPOS\", payload: { repos: minimal } });\n        } else {\n            deps.send({\n                type: \"ERROR\",\n                payload: {\n                    message: `GitHub: Could not list repos: ${repos.error}`,\n                },\n            });\n            deps.send({ type: \"GITHUB_REPOS\", payload: { repos: [] } });\n        }\n    }\n\n    async function restoreGithubTokenAndVerify(): Promise<void> {\n        try {\n            const rememberPrefStored = await figma.clientStorage\n                .getAsync(\"githubRememberPref\")\n                .catch(() => null);\n            const rememberPref =\n                typeof rememberPrefStored === \"boolean\"\n                    ? rememberPrefStored\n                    : true;\n            if (!rememberPref) {\n                await figma.clientStorage\n                    .deleteAsync(\"github_token_b64\")\n                    .catch(() => {});\n                return;\n            }\n\n            const stored = await figma.clientStorage\n                .getAsync(\"github_token_b64\")\n                .catch(() => null);\n            if (!stored || typeof stored !== \"string\" || stored.length === 0)\n                return;\n\n            const decoded = decodeToken(stored);\n            ghToken = decoded;\n\n            const who = await ghGetUser(decoded);\n            if (who.ok) {\n                deps.send({\n                    type: \"GITHUB_AUTH_RESULT\",\n                    payload: {\n                        ok: true,\n                        login: who.user.login,\n                        name: who.user.name,\n                        remember: true,\n                    },\n                });\n                await listAndSendRepos(decoded);\n            } else {\n                deps.send({\n                    type: \"ERROR\",\n                    payload: {\n                        message: `GitHub: Authentication failed (stored token): ${who.error}.`,\n                    },\n                });\n                deps.send({\n                    type: \"GITHUB_AUTH_RESULT\",\n                    payload: { ok: false, error: who.error, remember: false },\n                });\n            }\n        } catch {\n            // ignore\n        }\n    }\n\n    async function getSelectedFolderForCommit(folderRaw: string) {\n        const folderStoredResult = normalizeFolderForStorage(folderRaw);\n        if (!folderStoredResult.ok) {\n            return folderStoredResult;\n        }\n        const folderCommitResult = folderStorageToCommitPath(\n            folderStoredResult.storage\n        );\n        if (!folderCommitResult.ok) {\n            return folderCommitResult;\n        }\n        return {\n            ok: true as const,\n            storage: folderStoredResult.storage,\n            path: folderCommitResult.path,\n        };\n    }\n\n  async function ensureFolderPathWritable(\n    token: string,\n    owner: string,\n    repo: string,\n    branch: string,\n    folderPath: string\n  ): Promise<{ ok: true } | { ok: false; status: number; message: string }> {\n        if (!folderPath) return { ok: true };\n        const segments = folderPath.split(\"/\").filter(Boolean);\n        let prefix = \"\";\n        for (let i = 0; i < segments.length; i++) {\n            prefix = prefix ? `${prefix}/${segments[i]}` : segments[i];\n            const res = await ghListDirs(token, owner, repo, branch, prefix);\n            if (res.ok) continue;\n            const status = typeof res.status === \"number\" ? res.status : 0;\n            if (status === 404) break;\n            if (status === 409) {\n                return {\n                    ok: false,\n                    status: 409,\n                    message: `GitHub: \"${prefix}\" is already a file. Choose a different export folder.`,\n                };\n            }\n            if (res.samlRequired) {\n                return {\n                    ok: false,\n                    status: 403,\n                    message:\n                        \"GitHub: Authorize SSO for this repository to export into that folder.\",\n                };\n            }\n            const message = res.message || `HTTP ${status}`;\n            return { ok: false, status: status || 400, message };\n    }\n    return { ok: true };\n  }\n\n  async function refreshCollectionsSnapshotForUi(): Promise<void> {\n    try {\n      const snap = await deps.snapshotCollectionsForUi();\n      const last = await figma.clientStorage.getAsync('lastSelection').catch(() => null);\n      const exportAllPrefVal = await figma.clientStorage.getAsync('exportAllPref').catch(() => false);\n      const styleDictionaryPrefVal = await figma.clientStorage.getAsync('styleDictionaryPref').catch(() => false);\n      const flatTokensPrefVal = await figma.clientStorage.getAsync('flatTokensPref').catch(() => false);\n      const allowHexPrefStored = await figma.clientStorage.getAsync('allowHexPref').catch(() => null);\n      const githubRememberPrefStored = await figma.clientStorage.getAsync('githubRememberPref').catch(() => null);\n      const allowHexPrefVal = typeof allowHexPrefStored === 'boolean' ? allowHexPrefStored : true;\n      const githubRememberPrefVal = typeof githubRememberPrefStored === 'boolean' ? githubRememberPrefStored : true;\n      const lastOrNull = last && typeof last.collection === 'string' && typeof last.mode === 'string'\n        ? last\n        : null;\n\n      deps.send({\n        type: 'COLLECTIONS_DATA',\n        payload: {\n          collections: snap.collections,\n          last: lastOrNull,\n          exportAllPref: !!exportAllPrefVal,\n          styleDictionaryPref: !!styleDictionaryPrefVal,\n          flatTokensPref: !!flatTokensPrefVal,\n          allowHexPref: allowHexPrefVal,\n          githubRememberPref: githubRememberPrefVal\n        }\n      });\n      deps.send({ type: 'RAW_COLLECTIONS_TEXT', payload: { text: snap.rawText } });\n    } catch (err) {\n      const message = (err as Error)?.message || 'unknown error';\n      deps.send({ type: 'ERROR', payload: { message: `GitHub: Failed to refresh local state: ${message}` } });\n    }\n  }\n\n    async function handle(msg: UiToPlugin): Promise<boolean> {\n        switch (msg.type) {\n            case \"GITHUB_SET_TOKEN\": {\n                const token = String(msg.payload.token || \"\").trim();\n                const remember = !!msg.payload.remember;\n\n                if (!token) {\n                    deps.send({\n                        type: \"ERROR\",\n                        payload: { message: \"GitHub: Empty token.\" },\n                    });\n                    deps.send({\n                        type: \"GITHUB_AUTH_RESULT\",\n                        payload: {\n                            ok: false,\n                            error: \"empty token\",\n                            remember: false,\n                        },\n                    });\n                    return true;\n                }\n\n                ghToken = token;\n                if (remember) {\n                    await figma.clientStorage\n                        .setAsync(\"github_token_b64\", encodeToken(token))\n                        .catch(() => {});\n                } else {\n                    await figma.clientStorage\n                        .deleteAsync(\"github_token_b64\")\n                        .catch(() => {});\n                }\n\n                const who = await ghGetUser(token);\n                if (who.ok) {\n                    deps.send({\n                        type: \"GITHUB_AUTH_RESULT\",\n                        payload: {\n                            ok: true,\n                            login: who.user.login,\n                            name: who.user.name,\n                            remember,\n                        },\n                    });\n                    await listAndSendRepos(token);\n                } else {\n                    deps.send({\n                        type: \"ERROR\",\n                        payload: {\n                            message: `GitHub: Authentication failed: ${who.error}.`,\n                        },\n                    });\n                    deps.send({\n                        type: \"GITHUB_AUTH_RESULT\",\n                        payload: {\n                            ok: false,\n                            error: who.error,\n                            remember: false,\n                        },\n                    });\n                    deps.send({ type: \"GITHUB_REPOS\", payload: { repos: [] } });\n                }\n                return true;\n            }\n\n            case \"GITHUB_FORGET_TOKEN\": {\n                ghToken = null;\n                await figma.clientStorage\n                    .deleteAsync(\"github_token_b64\")\n                    .catch(() => {\n                        /* ignore */\n                    });\n                deps.send({\n                    type: \"INFO\",\n                    payload: { message: \"GitHub: Token cleared.\" },\n                });\n                deps.send({\n                    type: \"GITHUB_AUTH_RESULT\",\n                    payload: { ok: false, remember: false },\n                });\n                deps.send({ type: \"GITHUB_REPOS\", payload: { repos: [] } });\n                return true;\n            }\n\n            case \"GITHUB_SELECT_REPO\": {\n                const sel = await getSelected();\n                await setSelected({\n                    owner: msg.payload.owner,\n                    repo: msg.payload.repo,\n                    branch: sel.branch,\n                    folder: undefined,\n                    filename: sel.filename,\n                    commitMessage: sel.commitMessage,\n                    scope: sel.scope,\n                    collection: sel.collection,\n                    mode: sel.mode,\n                    createPr: sel.createPr,\n                    prBase: sel.prBase,\n                    prTitle: sel.prTitle,\n                    prBody: sel.prBody,\n                });\n                return true;\n            }\n\n            case \"GITHUB_SELECT_BRANCH\": {\n                const sel = await getSelected();\n                await setSelected({\n                    owner: msg.payload.owner || sel.owner,\n                    repo: msg.payload.repo || sel.repo,\n                    branch: msg.payload.branch,\n                    folder: undefined,\n                    filename: sel.filename,\n                    commitMessage: sel.commitMessage,\n                    scope: sel.scope,\n                    collection: sel.collection,\n                    mode: sel.mode,\n                    createPr: sel.createPr,\n                    prBase: sel.prBase,\n                    prTitle: sel.prTitle,\n                    prBody: sel.prBody,\n                });\n                return true;\n            }\n\n            case \"GITHUB_SET_FOLDER\": {\n                const folderResult = normalizeFolderForStorage(\n                    String(msg.payload.folder ?? \"\")\n                );\n                if (!folderResult.ok) {\n                    deps.send({\n                        type: \"ERROR\",\n                        payload: { message: folderResult.message },\n                    });\n                    return true;\n                }\n                const folder = folderResult.storage;\n                const sel = await getSelected();\n                await setSelected({\n                    owner: msg.payload.owner || sel.owner,\n                    repo: msg.payload.repo || sel.repo,\n                    branch: sel.branch,\n                    folder,\n                    filename: sel.filename,\n                    commitMessage: sel.commitMessage,\n                    scope: sel.scope,\n                    collection: sel.collection,\n                    mode: sel.mode,\n                    createPr: sel.createPr,\n                    prBase: sel.prBase,\n                    prTitle: sel.prTitle,\n                    prBody: sel.prBody,\n                });\n                return true;\n            }\n\n            case \"GITHUB_SAVE_STATE\": {\n                const update: Partial<GhSelected> = {};\n                if (typeof msg.payload.owner === \"string\")\n                    update.owner = msg.payload.owner;\n                if (typeof msg.payload.repo === \"string\")\n                    update.repo = msg.payload.repo;\n                if (typeof msg.payload.branch === \"string\")\n                    update.branch = msg.payload.branch;\n                if (typeof msg.payload.folder === \"string\") {\n                    const folderResult = normalizeFolderForStorage(\n                        msg.payload.folder\n                    );\n                    if (folderResult.ok) update.folder = folderResult.storage;\n                    else\n                        deps.send({\n                            type: \"ERROR\",\n                            payload: { message: folderResult.message },\n                        });\n                }\n                if (typeof msg.payload.filename === \"string\")\n                    update.filename = msg.payload.filename.trim();\n                if (typeof msg.payload.commitMessage === \"string\")\n                    update.commitMessage = msg.payload.commitMessage;\n                if (\n                    msg.payload.scope === \"all\" ||\n                    msg.payload.scope === \"selected\" ||\n                    msg.payload.scope === \"typography\"\n                ) {\n                    update.scope = msg.payload.scope;\n                }\n                if (typeof msg.payload.collection === \"string\")\n                    update.collection = msg.payload.collection;\n                if (typeof msg.payload.mode === \"string\")\n                    update.mode = msg.payload.mode;\n                if (typeof msg.payload.styleDictionary === \"boolean\")\n                    update.styleDictionary = msg.payload.styleDictionary;\n                if (typeof msg.payload.flatTokens === \"boolean\")\n                    update.flatTokens = msg.payload.flatTokens;\n                if (typeof msg.payload.createPr === \"boolean\")\n                    update.createPr = msg.payload.createPr;\n                if (typeof msg.payload.prBase === \"string\")\n                    update.prBase = msg.payload.prBase;\n                if (typeof msg.payload.prTitle === \"string\")\n                    update.prTitle = msg.payload.prTitle;\n                if (typeof msg.payload.prBody === \"string\")\n                    update.prBody = msg.payload.prBody;\n                await mergeSelected(update);\n                return true;\n            }\n\n            case \"GITHUB_FETCH_BRANCHES\": {\n                const owner = String(msg.payload.owner || \"\");\n                const repo = String(msg.payload.repo || \"\");\n                const page = Number.isFinite(msg.payload.page)\n                    ? Number(msg.payload.page)\n                    : 1;\n                const force = !!msg.payload.force;\n\n                if (!ghToken) {\n                    deps.send({\n                        type: \"GITHUB_BRANCHES_ERROR\",\n                        payload: {\n                            owner,\n                            repo,\n                            status: 401,\n                            message: \"No token\",\n                        },\n                    });\n                    return true;\n                }\n\n                const res = await ghListBranches(\n                    ghToken,\n                    owner,\n                    repo,\n                    page,\n                    force\n                );\n                if (res.ok) {\n                    deps.send({ type: \"GITHUB_BRANCHES\", payload: res });\n                    if (page === 1 && res.defaultBranch) {\n                        await mergeSelected({\n                            owner,\n                            repo,\n                            branch: res.defaultBranch,\n                            prBase: res.defaultBranch,\n                        });\n                    }\n                } else {\n                    deps.send({ type: \"GITHUB_BRANCHES_ERROR\", payload: res });\n                }\n                return true;\n            }\n\n            case \"GITHUB_FOLDER_LIST\": {\n                const owner = String(msg.payload.owner || \"\");\n                const repo = String(msg.payload.repo || \"\");\n                const branch = String(msg.payload.branch || \"\");\n                const pathRaw = String(msg.payload.path || \"\");\n\n                if (!ghToken) {\n                    deps.send({\n                        type: \"GITHUB_FOLDER_LIST_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch,\n                            path: pathRaw,\n                            status: 401,\n                            message: \"No token\",\n                        },\n                    });\n                    return true;\n                }\n\n                const normalizedPath = normalizeFolderForStorage(pathRaw);\n                if (!normalizedPath.ok) {\n                    deps.send({\n                        type: \"GITHUB_FOLDER_LIST_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch,\n                            path: pathRaw,\n                            status: 400,\n                            message: normalizedPath.message,\n                        },\n                    });\n                    return true;\n                }\n                const commitPathResult = folderStorageToCommitPath(\n                    normalizedPath.storage\n                );\n                if (!commitPathResult.ok) {\n                    deps.send({\n                        type: \"GITHUB_FOLDER_LIST_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch,\n                            path: pathRaw,\n                            status: 400,\n                            message: commitPathResult.message,\n                        },\n                    });\n                    return true;\n                }\n\n                const folderPath = commitPathResult.path;\n                if (folderPath) {\n                    const collision = await ensureFolderPathWritable(\n                        ghToken,\n                        owner,\n                        repo,\n                        branch,\n                        folderPath\n                    );\n                    if (!collision.ok) {\n                        deps.send({\n                            type: \"GITHUB_FOLDER_LIST_RESULT\",\n                            payload: {\n                                ok: false,\n                                owner,\n                                repo,\n                                branch,\n                                path: folderPath,\n                                status: collision.status,\n                                message: collision.message,\n                            },\n                        });\n                        return true;\n                    }\n                }\n\n                const res = await ghListDirs(\n                    ghToken,\n                    owner,\n                    repo,\n                    branch,\n                    commitPathResult.path\n                );\n                if (res.ok) {\n                    deps.send({\n                        type: \"GITHUB_FOLDER_LIST_RESULT\",\n                        payload: {\n                            ok: true,\n                            owner,\n                            repo,\n                            branch,\n                            path: res.path,\n                            entries: res.dirs.map((d) => ({\n                                type: \"dir\",\n                                name: d.name,\n                                path: d.path,\n                            })),\n                            rate: res.rate,\n                        },\n                    });\n                } else {\n                    deps.send({\n                        type: \"GITHUB_FOLDER_LIST_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch,\n                            path: res.path,\n                            status: res.status,\n                            message: res.message,\n                            rate: res.rate,\n                        },\n                    });\n                }\n                return true;\n            }\n\n            case \"GITHUB_CREATE_FOLDER\": {\n                const owner = String(msg.payload.owner || \"\");\n                const repo = String(msg.payload.repo || \"\");\n                const branch = String(msg.payload.branch || \"\");\n                const folderPathRaw = String(\n                    (msg.payload as any).folderPath || msg.payload.path || \"\"\n                ).trim();\n\n                if (!ghToken) {\n                    deps.send({\n                        type: \"GITHUB_CREATE_FOLDER_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch,\n                            folderPath: folderPathRaw,\n                            status: 401,\n                            message: \"No token\",\n                        },\n                    });\n                    return true;\n                }\n\n                const folderNormalized =\n                    normalizeFolderForStorage(folderPathRaw);\n                if (!folderNormalized.ok) {\n                    deps.send({\n                        type: \"GITHUB_CREATE_FOLDER_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch,\n                            folderPath: folderPathRaw,\n                            status: 400,\n                            message: folderNormalized.message,\n                        },\n                    });\n                    return true;\n                }\n\n                const folderCommit = folderStorageToCommitPath(\n                    folderNormalized.storage\n                );\n                if (!folderCommit.ok) {\n                    deps.send({\n                        type: \"GITHUB_CREATE_FOLDER_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch,\n                            folderPath: folderPathRaw,\n                            status: 400,\n                            message: folderCommit.message,\n                        },\n                    });\n                    return true;\n                }\n                if (!folderCommit.path) {\n                    deps.send({\n                        type: \"GITHUB_CREATE_FOLDER_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch,\n                            folderPath: folderPathRaw,\n                            status: 400,\n                            message: \"GitHub: Choose a subfolder name.\",\n                        },\n                    });\n                    return true;\n                }\n\n                const res = await ghEnsureFolder(\n                    ghToken,\n                    owner,\n                    repo,\n                    branch,\n                    folderCommit.path\n                );\n                deps.send({\n                    type: \"GITHUB_CREATE_FOLDER_RESULT\",\n                    payload: res,\n                });\n                return true;\n            }\n\n            case \"GITHUB_CREATE_BRANCH\": {\n                const owner = String(msg.payload.owner || \"\");\n                const repo = String(msg.payload.repo || \"\");\n                const baseBranch = String(msg.payload.baseBranch || \"\");\n                const newBranch = String(msg.payload.newBranch || \"\");\n\n                if (!ghToken) {\n                    deps.send({\n                        type: \"GITHUB_CREATE_BRANCH_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            baseBranch,\n                            newBranch,\n                            status: 401,\n                            message: \"No token\",\n                        },\n                    });\n                    return true;\n                }\n                if (!owner || !repo || !baseBranch || !newBranch) {\n                    deps.send({\n                        type: \"GITHUB_CREATE_BRANCH_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            baseBranch,\n                            newBranch,\n                            status: 400,\n                            message: \"Missing owner/repo/base/new\",\n                        },\n                    });\n                    return true;\n                }\n\n                const res = await ghCreateBranch(\n                    ghToken,\n                    owner,\n                    repo,\n                    newBranch,\n                    baseBranch\n                );\n                if (res.ok) {\n                    await mergeSelected({ owner, repo, branch: newBranch });\n                }\n                deps.send({\n                    type: \"GITHUB_CREATE_BRANCH_RESULT\",\n                    payload: res,\n                });\n                return true;\n            }\n\n            case \"GITHUB_FETCH_TOKENS\": {\n                const owner = String(msg.payload.owner || \"\");\n                const repo = String(msg.payload.repo || \"\");\n                const branch = String(msg.payload.branch || \"\");\n                const pathRaw = String(msg.payload.path || \"\");\n                const allowHex = !!msg.payload.allowHexStrings;\n\n                if (!ghToken) {\n                    deps.send({\n                        type: \"GITHUB_FETCH_TOKENS_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch,\n                            path: pathRaw,\n                            status: 401,\n                            message: \"No token\",\n                        },\n                    });\n                    return true;\n                }\n                if (!owner || !repo || !branch || !pathRaw.trim()) {\n                    deps.send({\n                        type: \"GITHUB_FETCH_TOKENS_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch,\n                            path: pathRaw,\n                            status: 400,\n                            message: \"Missing owner/repo/branch/path\",\n                        },\n                    });\n                    return true;\n                }\n\n                const normalizedPath = normalizeFolderForStorage(pathRaw);\n                if (!normalizedPath.ok) {\n                    deps.send({\n                        type: \"GITHUB_FETCH_TOKENS_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch,\n                            path: pathRaw,\n                            status: 400,\n                            message: normalizedPath.message,\n                        },\n                    });\n                    return true;\n                }\n                const commitPathResult = folderStorageToCommitPath(\n                    normalizedPath.storage\n                );\n                if (!commitPathResult.ok) {\n                    deps.send({\n                        type: \"GITHUB_FETCH_TOKENS_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch,\n                            path: pathRaw,\n                            status: 400,\n                            message: commitPathResult.message,\n                        },\n                    });\n                    return true;\n                }\n                const path = commitPathResult.path;\n\n                const res = await ghGetFileContents(\n                    ghToken,\n                    owner,\n                    repo,\n                    branch,\n                    path\n                );\n                if (!res.ok) {\n                    deps.send({\n                        type: \"GITHUB_FETCH_TOKENS_RESULT\",\n                        payload: res,\n                    });\n                    if (res.samlRequired) {\n                        deps.send({\n                            type: \"ERROR\",\n                            payload: {\n                                message:\n                                    \"GitHub: SSO required for this repository. Authorize your PAT and try again.\",\n                            },\n                        });\n                    }\n                    return true;\n                }\n\n                try {\n                    const json = JSON.parse(res.contentText || \"{}\");\n                    const contexts = Array.isArray(msg.payload.contexts)\n                        ? msg.payload.contexts.map((c) => String(c))\n                        : [];\n                    const summary = await deps.importDtcg(json, {\n                        allowHexStrings: allowHex,\n                        contexts,\n                    });\n                    deps.send({\n                        type: \"GITHUB_FETCH_TOKENS_RESULT\",\n                        payload: { ok: true, owner, repo, branch, path, json },\n                    });\n                    deps.send({\n                        type: \"INFO\",\n                        payload: {\n                            message: `Imported tokens from ${owner}/${repo}@${branch}:${path}`,\n                        },\n                    });\n                    deps.send({\n                        type: \"IMPORT_SUMMARY\",\n                        payload: {\n                            summary,\n                            timestamp: Date.now(),\n                            source: \"github\",\n                        },\n                    });\n\n                    await refreshCollectionsSnapshotForUi();\n                } catch (err) {\n                    const msgText = (err as Error)?.message || \"Invalid JSON\";\n                    deps.send({\n                        type: \"GITHUB_FETCH_TOKENS_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch,\n                            path,\n                            status: 422,\n                            message: msgText,\n                        },\n                    });\n                    deps.send({\n                        type: \"ERROR\",\n                        payload: {\n                            message: `GitHub import failed: ${msgText}`,\n                        },\n                    });\n                }\n                return true;\n            }\n\n            case \"GITHUB_EXPORT_FILES\": {\n                const scope: GithubScope =\n                    msg.payload.scope === \"all\"\n                        ? \"all\"\n                        : msg.payload.scope === \"typography\"\n                        ? \"typography\"\n                        : \"selected\";\n                const collection = String(msg.payload.collection || \"\");\n                const mode = String(msg.payload.mode || \"\");\n                const styleDictionary = !!msg.payload.styleDictionary;\n                const flatTokens = !!msg.payload.flatTokens;\n\n                try {\n                    if (scope === \"all\") {\n                        const all = await deps.exportDtcg({\n                            format: \"single\",\n                            styleDictionary,\n                            flatTokens,\n                        });\n                        deps.send({\n                            type: \"GITHUB_EXPORT_FILES_RESULT\",\n                            payload: { files: all.files },\n                        });\n                    } else if (scope === \"typography\") {\n                        const typo = await deps.exportDtcg({\n                            format: \"typography\",\n                        });\n                        deps.send({\n                            type: \"GITHUB_EXPORT_FILES_RESULT\",\n                            payload: { files: typo.files },\n                        });\n                    } else {\n                        if (!collection || !mode) {\n                            deps.send({\n                                type: \"GITHUB_EXPORT_FILES_RESULT\",\n                                payload: { files: [] },\n                            });\n                            deps.send({\n                                type: \"ERROR\",\n                                payload: {\n                                    message:\n                                        \"GitHub: choose collection and mode before exporting.\",\n                                },\n                            });\n                            return true;\n                        }\n                        const per = await deps.exportDtcg({\n                            format: \"perMode\",\n                            styleDictionary,\n                            flatTokens,\n                        });\n                        const prettyExact = `${collection} - ${mode}.json`;\n                        const prettyLoose = `${collection} - ${mode}`;\n                        const legacy1 = `${collection}_mode=${mode}`;\n                        const legacy2 = `${collection}/mode=${mode}`;\n                        const legacy3 = deps.safeKeyFromCollectionAndMode(\n                            collection,\n                            mode\n                        );\n                        let picked = per.files.find((f) => {\n                            const n = String(f?.name || \"\");\n                            return (\n                                n === prettyExact ||\n                                n === prettyLoose ||\n                                n.includes(`${collection} - ${mode}`)\n                            );\n                        });\n                        if (!picked) {\n                            picked = per.files.find((f) => {\n                                const n = String(f?.name || \"\");\n                                return (\n                                    n.includes(legacy1) ||\n                                    n.includes(legacy2) ||\n                                    n.includes(legacy3)\n                                );\n                            });\n                        }\n                        const files = picked ? [picked] : per.files;\n                        deps.send({\n                            type: \"GITHUB_EXPORT_FILES_RESULT\",\n                            payload: { files },\n                        });\n                    }\n                } catch (err) {\n                    const msgText =\n                        (err as Error)?.message || \"Failed to export\";\n                    deps.send({\n                        type: \"ERROR\",\n                        payload: {\n                            message: `GitHub export failed: ${msgText}`,\n                        },\n                    });\n                    deps.send({\n                        type: \"GITHUB_EXPORT_FILES_RESULT\",\n                        payload: { files: [] },\n                    });\n                }\n                return true;\n            }\n\n            case \"GITHUB_EXPORT_AND_COMMIT\": {\n                const owner = String(msg.payload.owner || \"\");\n                const repo = String(msg.payload.repo || \"\");\n                const baseBranch = String(msg.payload.branch || \"\");\n                const folderRaw =\n                    typeof msg.payload.folder === \"string\"\n                        ? msg.payload.folder\n                        : \"\";\n                const commitMessage = (\n                    String(msg.payload.commitMessage || \"\") ||\n                    \"Update tokens from Figma\"\n                ).trim();\n                const requestedScope: GithubScope =\n                    msg.payload.scope === \"all\"\n                        ? \"all\"\n                        : msg.payload.scope === \"typography\"\n                        ? \"typography\"\n                        : \"selected\";\n                let scope: GithubScope = requestedScope;\n                const collection = String(msg.payload.collection || \"\");\n                const mode = String(msg.payload.mode || \"\");\n                const styleDictionary = !!msg.payload.styleDictionary;\n                const flatTokens = !!msg.payload.flatTokens;\n                const createPr = !!msg.payload.createPr;\n                const prBaseBranch = createPr\n                    ? String(msg.payload.prBase || \"\")\n                    : \"\";\n                const prTitle =\n                    String(msg.payload.prTitle || commitMessage).trim() ||\n                    commitMessage;\n                const prBody =\n                    typeof msg.payload.prBody === \"string\"\n                        ? msg.payload.prBody\n                        : undefined;\n                const storedSelection = await getSelected();\n                const selectionCollection =\n                    collection ||\n                    (typeof storedSelection.collection === \"string\"\n                        ? storedSelection.collection\n                        : \"\");\n                const selectionMode =\n                    mode ||\n                    (typeof storedSelection.mode === \"string\"\n                        ? storedSelection.mode\n                        : \"\");\n                const filenameCandidate =\n                    typeof msg.payload.filename === \"string\"\n                        ? msg.payload.filename\n                        : typeof storedSelection.filename === \"string\"\n                        ? storedSelection.filename\n                        : undefined;\n                const filenameCheck = validateGithubFilename(\n                    filenameCandidate ?? DEFAULT_GITHUB_FILENAME\n                );\n                if (!filenameCheck.ok) {\n                    deps.send({\n                        type: \"GITHUB_COMMIT_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch: baseBranch,\n                            status: 400,\n                            message: filenameCheck.message,\n                            folder: folderRaw || \"\",\n                            filename: filenameCandidate,\n                        },\n                    });\n                    return true;\n                }\n                const filenameToCommit = filenameCheck.filename;\n\n                if (!ghToken) {\n                    deps.send({\n                        type: \"GITHUB_COMMIT_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch: baseBranch,\n                            status: 401,\n                            message: \"No token\",\n                            folder: folderRaw || \"\",\n                            filename: filenameToCommit,\n                        },\n                    });\n                    return true;\n                }\n                if (!owner || !repo || !baseBranch) {\n                    deps.send({\n                        type: \"GITHUB_COMMIT_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch: baseBranch,\n                            status: 400,\n                            message: \"Missing owner/repo/branch\",\n                            folder: folderRaw || \"\",\n                            filename: filenameToCommit,\n                        },\n                    });\n                    return true;\n                }\n                if (!commitMessage) {\n                    deps.send({\n                        type: \"GITHUB_COMMIT_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch: baseBranch,\n                            status: 400,\n                            message: \"Empty commit message\",\n                            folder: folderRaw || \"\",\n                            filename: filenameToCommit,\n                        },\n                    });\n                    return true;\n                }\n\n                const folderInfo = await getSelectedFolderForCommit(folderRaw);\n                if (!folderInfo.ok) {\n                    deps.send({\n                        type: \"GITHUB_COMMIT_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch: baseBranch,\n                            status: 400,\n                            message: folderInfo.message,\n                            folder: folderRaw || \"\",\n                            filename: filenameToCommit,\n                        },\n                    });\n                    return true;\n                }\n\n                if (folderInfo.path) {\n                    const folderCheck = await ensureFolderPathWritable(\n                        ghToken,\n                        owner,\n                        repo,\n                        baseBranch,\n                        folderInfo.path\n                    );\n                    if (!folderCheck.ok) {\n                        deps.send({\n                            type: \"GITHUB_COMMIT_RESULT\",\n                            payload: {\n                                ok: false,\n                                owner,\n                                repo,\n                                branch: baseBranch,\n                                status: folderCheck.status,\n                                message: folderCheck.message,\n                                folder: folderInfo.storage,\n                                filename: filenameToCommit,\n                            },\n                        });\n                        return true;\n                    }\n                }\n\n                if (createPr && !prBaseBranch) {\n                    deps.send({\n                        type: \"GITHUB_COMMIT_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch: baseBranch,\n                            status: 400,\n                            message:\n                                \"Unable to determine target branch for pull request.\",\n                            folder: folderInfo.storage,\n                            filename: filenameToCommit,\n                        },\n                    });\n                    return true;\n                }\n                if (createPr && prBaseBranch === baseBranch) {\n                    deps.send({\n                        type: \"GITHUB_COMMIT_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch: baseBranch,\n                            status: 400,\n                            message:\n                                \"Selected branch matches PR target branch. Choose a different branch before creating a PR.\",\n                            folder: folderInfo.storage,\n                            filename: filenameToCommit,\n                        },\n                    });\n                    return true;\n                }\n\n                const folderStorageValue = folderInfo.storage;\n                const folderCommitPath = folderInfo.path;\n                const fullPathForCommit = folderCommitPath\n                    ? `${folderCommitPath}/${filenameToCommit}`\n                    : filenameToCommit;\n                const lastCommitSignature =\n                    (await getLastCommitSignature()) || null;\n                const sameTargetAsLastCommit =\n                    !!lastCommitSignature &&\n                    lastCommitSignature.branch === baseBranch &&\n                    lastCommitSignature.fullPath === fullPathForCommit &&\n                    lastCommitSignature.scope === scope;\n\n                const selectionState: Partial<GhSelected> = {\n                    owner,\n                    repo,\n                    branch: baseBranch,\n                    folder: folderInfo.storage,\n                    filename: filenameToCommit,\n                    commitMessage,\n                    scope,\n                    styleDictionary: msg.payload.styleDictionary,\n                    flatTokens: msg.payload.flatTokens,\n                    createPr,\n                    prBase: createPr ? prBaseBranch : undefined,\n                    prTitle: createPr ? prTitle : undefined,\n                    prBody: createPr ? prBody : undefined,\n                };\n                if (selectionCollection)\n                    selectionState.collection = selectionCollection;\n                if (selectionMode) selectionState.mode = selectionMode;\n                await mergeSelected(selectionState);\n                await refreshCollectionsSnapshotForUi();\n\n                try {\n                    const files: Array<{ name: string; json: unknown }> = [];\n\n                    if (scope === \"all\") {\n                        const all = await deps.exportDtcg({\n                            format: \"single\",\n                            styleDictionary,\n                            flatTokens,\n                        });\n                        for (const f of all.files)\n                            files.push({ name: f.name, json: f.json });\n                    } else if (scope === \"typography\") {\n                        const typo = await deps.exportDtcg({\n                            format: \"typography\",\n                        });\n                        for (const f of typo.files)\n                            files.push({ name: f.name, json: f.json });\n                    } else {\n                        if (!selectionCollection || !selectionMode) {\n                            deps.send({\n                                type: \"GITHUB_COMMIT_RESULT\",\n                                payload: {\n                                    ok: false,\n                                    owner,\n                                    repo,\n                                    branch: baseBranch,\n                                    status: 400,\n                                    message: \"Pick a collection and a mode.\",\n                                    folder: folderStorageValue,\n                                    filename: filenameToCommit,\n                                    fullPath: fullPathForCommit,\n                                },\n                            });\n                            return true;\n                        }\n                        const per = await deps.exportDtcg({\n                            format: \"perMode\",\n                            styleDictionary,\n                            flatTokens,\n                        });\n                        const picked = pickPerModeFile(\n                            per.files,\n                            selectionCollection,\n                            selectionMode\n                        );\n                        if (!picked) {\n                            const available = per.files\n                                .map((f) => f.name)\n                                .join(\", \");\n                            deps.send({\n                                type: \"GITHUB_COMMIT_RESULT\",\n                                payload: {\n                                    ok: false,\n                                    owner,\n                                    repo,\n                                    branch: baseBranch,\n                                    status: 404,\n                                    message: `No export found for \"${selectionCollection}\" / \"${selectionMode}\". Available: [${available}]`,\n                                    folder: folderStorageValue,\n                                    filename: filenameToCommit,\n                                    fullPath: fullPathForCommit,\n                                },\n                            });\n                            return true;\n                        }\n                        files.push({ name: picked.name, json: picked.json });\n                    }\n\n                    if (files.length > 1) {\n                        deps.send({\n                            type: \"GITHUB_COMMIT_RESULT\",\n                            payload: {\n                                ok: false,\n                                owner,\n                                repo,\n                                branch: baseBranch,\n                                status: 400,\n                                message:\n                                    \"GitHub: Custom filename requires a single export file. Adjust scope or disable extra formats.\",\n                                folder: folderStorageValue,\n                                filename: filenameToCommit,\n                                fullPath: fullPathForCommit,\n                            },\n                        });\n                        return true;\n                    }\n\n                    const isPlainEmptyObject = (v: any) =>\n                        v &&\n                        typeof v === \"object\" &&\n                        !Array.isArray(v) &&\n                        Object.keys(v).length === 0;\n                    let exportLooksEmpty =\n                        files.length === 0 ||\n                        files.every((f) => isPlainEmptyObject(f.json));\n\n                    if (exportLooksEmpty) {\n                        if (scope === \"typography\") {\n                            const warningMessage =\n                                \"GitHub export warning: typography.json is empty (no local text styles). Nothing to commit.\";\n                            deps.send({\n                                type: \"GITHUB_COMMIT_RESULT\",\n                                payload: {\n                                    ok: false,\n                                    owner,\n                                    repo,\n                                    branch: baseBranch,\n                                    status: 412,\n                                    message: warningMessage,\n                                    folder: folderStorageValue,\n                                    filename: filenameToCommit,\n                                    fullPath: fullPathForCommit,\n                                },\n                            });\n                            return true;\n                        }\n                        if (exportLooksEmpty && scope === \"selected\") {\n                            const diag = await deps.analyzeSelectionState(\n                                selectionCollection,\n                                selectionMode\n                            );\n                            const tail = diag.ok\n                                ? `Found ${\n                                      diag.variableCount\n                                  } variable(s) in \"${selectionCollection}\", but ${\n                                      diag.variablesWithValues ?? 0\n                                  } with a value in \"${selectionMode}\".`\n                                : diag.message || \"No values present.\";\n                            deps.send({\n                                type: \"GITHUB_COMMIT_RESULT\",\n                                payload: {\n                                    ok: false,\n                                    owner,\n                                    repo,\n                                    branch: baseBranch,\n                                    status: 412,\n                                    message: `Export for \"${selectionCollection}\" / \"${selectionMode}\" produced an empty tokens file. ${tail}`,\n                                    folder: folderStorageValue,\n                                    filename: filenameToCommit,\n                                    fullPath: fullPathForCommit,\n                                },\n                            });\n                            return true;\n                        }\n                        if (exportLooksEmpty) {\n                            deps.send({\n                                type: \"GITHUB_COMMIT_RESULT\",\n                                payload: {\n                                    ok: false,\n                                    owner,\n                                    repo,\n                                    branch: baseBranch,\n                                    status: 412,\n                                    message:\n                                        \"Export produced an empty tokens file. Ensure this file contains local Variables with values.\",\n                                    folder: folderStorageValue,\n                                    filename: filenameToCommit,\n                                    fullPath: fullPathForCommit,\n                                },\n                            });\n                            return true;\n                        }\n                    }\n\n                    const prettyExportName = (\n                        original: string | undefined | null\n                    ): string => {\n                        const name =\n                            original && typeof original === \"string\"\n                                ? original\n                                : \"tokens.json\";\n                        const m = name.match(/^(.*)_mode=(.*)\\.tokens\\.json$/);\n                        if (m) return `${m[1].trim()} - ${m[2].trim()}.json`;\n                        return name.endsWith(\".json\") ? name : name + \".json\";\n                    };\n                    const prefix = folderCommitPath\n                        ? folderCommitPath + \"/\"\n                        : \"\";\n                    const commitFiles = files.map((f) => {\n                        const resolvedName =\n                            files.length === 1\n                                ? filenameToCommit\n                                : prettyExportName(f.name);\n                        return {\n                            path: prefix + resolvedName,\n                            content: JSON.stringify(f.json, null, 2) + \"\\n\",\n                        };\n                    });\n\n                    const normalizeForCompare = (text: string): string =>\n                        text.replace(/\\r\\n/g, \"\\n\").trimEnd();\n                    const tryParseJson = (\n                        text: string\n                    ): unknown | undefined => {\n                        try {\n                            return JSON.parse(text);\n                        } catch {\n                            return undefined;\n                        }\n                    };\n                    const canonicalizeJson = (value: unknown): unknown => {\n                        if (Array.isArray(value)) {\n                            return value.map((item) => canonicalizeJson(item));\n                        }\n                        if (value && typeof value === \"object\") {\n                            const proto = Object.getPrototypeOf(value);\n                            if (proto === Object.prototype || proto === null) {\n                                const record = value as Record<string, unknown>;\n                                const sortedKeys = Object.keys(record).sort();\n                                const canonical: Record<string, unknown> = {};\n                                for (const key of sortedKeys)\n                                    canonical[key] = canonicalizeJson(\n                                        record[key]\n                                    );\n                                return canonical;\n                            }\n                        }\n                        return value;\n                    };\n                    const containsTypographyTokens = (text: string): boolean => {\n                        const parsed = tryParseJson(text);\n                        const hasTypography = (value: unknown): boolean => {\n                            if (!value) return false;\n                            if (typeof value === \"string\") {\n                                return value.toLowerCase() === \"typography\";\n                            }\n                            if (typeof value === \"object\") {\n                                if (\n                                    Object.prototype.hasOwnProperty.call(\n                                        value,\n                                        \"$type\"\n                                    )\n                                ) {\n                                    const t = (value as {\n                                        [k: string]: unknown;\n                                    })[\"$type\"];\n                                    if (\n                                        typeof t === \"string\" &&\n                                        t.toLowerCase() === \"typography\"\n                                    ) {\n                                        return true;\n                                    }\n                                }\n                                for (const key in value as {\n                                    [k: string]: unknown;\n                                }) {\n                                    if (\n                                        Object.prototype.hasOwnProperty.call(\n                                            value,\n                                            key\n                                        ) &&\n                                        hasTypography(\n                                            (value as {\n                                                [k: string]: unknown;\n                                            })[key]\n                                        )\n                                    ) {\n                                        return true;\n                                    }\n                                }\n                            }\n                            return false;\n                        };\n                        if (parsed !== undefined) {\n                            return hasTypography(parsed);\n                        }\n                        return /\"\\$type\"\\s*:\\s*\"typography\"/i.test(text);\n                    };\n                    const contentsMatch = (\n                        existing: string,\n                        nextContent: string\n                    ): boolean => {\n                        if (existing === nextContent) return true;\n                        if (\n                            normalizeForCompare(existing) ===\n                            normalizeForCompare(nextContent)\n                        )\n                            return true;\n                        const existingJson = tryParseJson(existing);\n                        const nextJson = tryParseJson(nextContent);\n                        if (\n                            existingJson !== undefined &&\n                            nextJson !== undefined\n                        ) {\n                            return (\n                                JSON.stringify(\n                                    canonicalizeJson(existingJson)\n                                ) === JSON.stringify(canonicalizeJson(nextJson))\n                            );\n                        }\n                        return false;\n                    };\n\n                    let allFilesIdentical = commitFiles.length > 0;\n                    for (const file of commitFiles) {\n                        const current = await ghGetFileContents(\n                            ghToken,\n                            owner,\n                            repo,\n                            baseBranch,\n                            file.path\n                        );\n                        if (!current.ok) {\n                            if (current.status === 404) {\n                                allFilesIdentical = false;\n                                break;\n                            }\n                            // If we cannot read the current file (permissions, SAML, etc.), assume changes are needed.\n                            allFilesIdentical = false;\n                            break;\n                        }\n                        if (\n                            scope === \"typography\" &&\n                            containsTypographyTokens(file.content) &&\n                            !containsTypographyTokens(current.contentText)\n                        ) {\n                            allFilesIdentical = false;\n                            break;\n                        }\n                        if (!contentsMatch(current.contentText, file.content)) {\n                            allFilesIdentical = false;\n                            break;\n                        }\n                    }\n\n                    if (allFilesIdentical && !sameTargetAsLastCommit) {\n                        allFilesIdentical = false;\n                    }\n\n                    if (allFilesIdentical) {\n                        const noChangeMessage =\n                            scope === \"selected\"\n                                ? `No token values changed for \"${selectionCollection}\" / \"${selectionMode}\"; repository already matches the current export.`\n                                : \"No token values changed; repository already matches the current export.\";\n                        deps.send({\n                            type: \"GITHUB_COMMIT_RESULT\",\n                            payload: {\n                                ok: false,\n                                owner,\n                                repo,\n                                branch: baseBranch,\n                                status: 304,\n                                message: noChangeMessage,\n                                folder: folderStorageValue,\n                                filename: filenameToCommit,\n                                fullPath: fullPathForCommit,\n                            },\n                        });\n                        return true;\n                    }\n\n                    const attemptCommit = async () =>\n                        ghCommitFiles(\n                            ghToken!,\n                            owner,\n                            repo,\n                            baseBranch,\n                            commitMessage,\n                            commitFiles\n                        );\n                    let commitRes = await attemptCommit();\n                    let fastForwardRetry = false;\n                    if (\n                        !commitRes.ok &&\n                        commitRes.status === 422 &&\n                        typeof commitRes.message === \"string\" &&\n                        /not a fast forward/i.test(commitRes.message)\n                    ) {\n                        await sleep(200);\n                        commitRes = await attemptCommit();\n                        fastForwardRetry = true;\n                    }\n                    if (!commitRes.ok) {\n                        const looksLikeFastForwardRace =\n                            commitRes.status === 422 &&\n                            typeof commitRes.message === \"string\" &&\n                            /not a fast forward/i.test(commitRes.message);\n                        if (looksLikeFastForwardRace && sameTargetAsLastCommit) {\n                            const noChangeMessage =\n                                scope === \"selected\"\n                                    ? `No token values changed for \"${selectionCollection}\" / \"${selectionMode}\"; repository already matches the current export.`\n                                    : \"No token values changed; repository already matches the current export.\";\n                            deps.send({\n                                type: \"GITHUB_COMMIT_RESULT\",\n                                payload: {\n                                    ok: false,\n                                    owner,\n                                    repo,\n                                    branch: baseBranch,\n                                    status: 304,\n                                    message: noChangeMessage,\n                                    folder: folderStorageValue,\n                                    filename: filenameToCommit,\n                                    fullPath: fullPathForCommit,\n                                },\n                            });\n                            return true;\n                        }\n                        deps.send({\n                            type: \"GITHUB_COMMIT_RESULT\",\n                            payload: {\n                                ...commitRes,\n                                folder: folderStorageValue,\n                                filename: filenameToCommit,\n                                fullPath: fullPathForCommit,\n                            },\n                        });\n                        deps.send({\n                            type: \"ERROR\",\n                            payload: {\n                                message: `GitHub: Commit failed (${commitRes.status}): ${commitRes.message}${\n                                    fastForwardRetry\n                                        ? \" (after retry)\"\n                                        : \"\"\n                                }`,\n                            },\n                        });\n                        return true;\n                    }\n\n                    await setLastCommitSignature({\n                        branch: baseBranch,\n                        fullPath: fullPathForCommit,\n                        scope,\n                    });\n\n                    let prResult:\n                        | Awaited<ReturnType<typeof ghCreatePullRequest>>\n                        | undefined;\n                    if (createPr) {\n                        prResult = await ghCreatePullRequest(\n                            ghToken,\n                            owner,\n                            repo,\n                            {\n                                title: prTitle,\n                                head: baseBranch,\n                                base: prBaseBranch,\n                                body: prBody,\n                            }\n                        );\n                    }\n\n                    const commitOkPayload = {\n                        ok: true as const,\n                        owner,\n                        repo,\n                        branch: baseBranch,\n                        folder: folderStorageValue,\n                        filename: filenameToCommit,\n                        fullPath: fullPathForCommit,\n                        commitSha: commitRes.commitSha,\n                        commitUrl: commitRes.commitUrl,\n                        treeUrl: commitRes.treeUrl,\n                        rate: commitRes.rate,\n                        createdPr:\n                            prResult && prResult.ok\n                                ? {\n                                      number: prResult.number,\n                                      url: prResult.url,\n                                      base: prResult.base,\n                                      head: prResult.head,\n                                  }\n                                : undefined,\n                    };\n                    deps.send({\n                        type: \"GITHUB_COMMIT_RESULT\",\n                        payload: commitOkPayload,\n                    });\n\n                    deps.send({\n                        type: \"INFO\",\n                        payload: {\n                            message: `Committed ${commitFiles.length} file(s) to ${owner}/${repo}@${baseBranch}`,\n                        },\n                    });\n                    if (createPr) {\n                        if (prResult && prResult.ok) {\n                            deps.send({\n                                type: \"GITHUB_PR_RESULT\",\n                                payload: prResult,\n                            });\n                            deps.send({\n                                type: \"INFO\",\n                                payload: {\n                                    message: `PR created: ${prResult.url}`,\n                                },\n                            });\n                        } else if (prResult) {\n                            deps.send({\n                                type: \"GITHUB_PR_RESULT\",\n                                payload: prResult,\n                            });\n                            deps.send({\n                                type: \"ERROR\",\n                                payload: {\n                                    message: `GitHub: PR creation failed (${prResult.status}): ${prResult.message}`,\n                                },\n                            });\n                        }\n                    }\n                } catch (e) {\n                    const msgText = (e as Error)?.message || \"unknown error\";\n                    deps.send({\n                        type: \"GITHUB_COMMIT_RESULT\",\n                        payload: {\n                            ok: false,\n                            owner,\n                            repo,\n                            branch: baseBranch,\n                            status: 0,\n                            message: msgText,\n                            folder: folderStorageValue,\n                            filename: filenameToCommit,\n                            fullPath: fullPathForCommit,\n                        },\n                    });\n                }\n                return true;\n            }\n\n            default:\n                return false;\n        }\n    }\n\n    async function onUiReady(): Promise<void> {\n        await restoreGithubTokenAndVerify();\n        const sel = await getSelected();\n        if (sel.owner && sel.repo) {\n            deps.send({ type: \"GITHUB_RESTORE_SELECTED\", payload: sel });\n        }\n    }\n\n    return { handle, onUiReady };\n}\n", "// src/app/main.ts\n// Main-thread controller: wires UI messages into Figma APIs and GitHub helpers.\n// - Handles persistence so the iframe can reload without losing settings\n// - Wraps GitHub flows with retries and gentle error surfaces\n\nimport type { UiToPlugin, PluginToUi, GithubScope } from \"./messages\";\nimport {\n    snapshotCollectionsForUi,\n    analyzeSelectionState,\n    safeKeyFromCollectionAndMode,\n} from \"./collections\";\nimport { importDtcg, exportDtcg } from \"../core/pipeline\";\n\nimport { createGithubDispatcher } from \"./github/dispatcher\";\n\n// __html__ is injected by your build (esbuild) from dist/ui.html with ui.js inlined.\ndeclare const __html__: string;\n\n// Use saved size if available; fall back to 960\u00D7540.\n(async function initUI() {\n    let w = 960,\n        h = 540;\n    try {\n        const saved = await figma.clientStorage.getAsync(\"uiSize\");\n        if (\n            saved &&\n            typeof saved.width === \"number\" &&\n            typeof saved.height === \"number\"\n        ) {\n            const sw = Math.floor(saved.width);\n            const sh = Math.floor(saved.height);\n            w = Math.max(720, Math.min(1600, sw));\n            h = Math.max(420, Math.min(1200, sh));\n        }\n    } catch {\n        /* ignore */\n    }\n    figma.showUI(__html__, { width: w, height: h });\n})();\n\nfunction send(msg: PluginToUi): void {\n    figma.ui.postMessage(msg);\n}\n\nconst github = createGithubDispatcher({\n    send,\n    snapshotCollectionsForUi,\n    analyzeSelectionState,\n    safeKeyFromCollectionAndMode,\n    importDtcg,\n    exportDtcg,\n});\n\ntype CollectionsDataPayload = Extract<\n    PluginToUi,\n    { type: \"COLLECTIONS_DATA\" }\n>[\"payload\"];\ntype RefreshReason = \"initial\" | \"manual\" | \"auto\";\ntype AutoRefreshSource = \"style-event\" | \"variable-poll\";\n\n// Poll for variable graph changes every 5s, but after a detected change we run a short\n// burst of faster polls so repeated edits feel responsive without hammering constantly.\nconst VARIABLE_POLL_INTERVAL_MS = 5000;\nconst VARIABLE_POLL_BURST_DELAY_MS = 350;\nconst VARIABLE_POLL_BURST_LIMIT = 3;\nconst AUTO_REFRESH_DEBOUNCE_MS = 600;\n\nlet autoSyncActive = false;\nlet autoRefreshTimer: ReturnType<typeof setTimeout> | null = null;\nlet autoRefreshRequested = false;\nlet autoRefreshRunning = false;\nlet variablePollTimer: ReturnType<typeof setTimeout> | null = null;\n// Tracks how many burst polls remain after a change so we can fall back to the slower cadence.\nlet variableBurstRemaining = 0;\nlet documentChangeHandler: ((event: DocumentChangeEvent) => void) | null = null;\nlet styleChangeHandler: ((event: StyleChangeEvent) => void) | null = null;\nlet lastCollectionsSignature: string | null = null;\nlet pendingSignatureAfterRefresh: string | null = null;\nlet pendingAutoRefreshSource: AutoRefreshSource | null = null;\nconst pendingStyleEvents = new Map<\n    string,\n    {\n        create?: boolean;\n        update?: boolean;\n        delete?: boolean;\n        attempts?: number;\n        loggedUpdate?: boolean;\n    }\n>();\nconst styleDisplayIds = new Map<string, string>();\nconst knownStyleIds = new Set<string>();\n\nfunction computeCollectionsSignatureFromPayload(\n    payload: CollectionsDataPayload\n): string {\n    const parts: string[] = [];\n    const collections = (payload.collections || [])\n        .slice()\n        .sort((a, b) => a.id.localeCompare(b.id));\n    for (let i = 0; i < collections.length; i++) {\n        const col = collections[i];\n        if (!col) continue;\n        parts.push(col.id, col.name);\n        const modes = (col.modes || [])\n            .slice()\n            .sort((a, b) => a.id.localeCompare(b.id));\n        for (let mi = 0; mi < modes.length; mi++) {\n            const mode = modes[mi];\n            parts.push(mode.id, mode.name);\n        }\n        const variables = (col.variables || [])\n            .slice()\n            .sort((a, b) => a.id.localeCompare(b.id));\n        for (let vi = 0; vi < variables.length; vi++) {\n            const variable = variables[vi];\n            parts.push(variable.id, variable.name, variable.type);\n        }\n    }\n    return parts.join(\"|\");\n}\n\nasync function buildCollectionsPayload(): Promise<{\n    payload: CollectionsDataPayload;\n    rawText: string;\n    count: number;\n    signature: string;\n}> {\n    const snap = await snapshotCollectionsForUi();\n    const last = await figma.clientStorage\n        .getAsync(\"lastSelection\")\n        .catch(() => null);\n    const exportAllPrefVal = await figma.clientStorage\n        .getAsync(\"exportAllPref\")\n        .catch(() => false);\n    const styleDictionaryPrefVal = await figma.clientStorage\n        .getAsync(\"styleDictionaryPref\")\n        .catch(() => false);\n    const flatTokensPrefVal = await figma.clientStorage\n        .getAsync(\"flatTokensPref\")\n        .catch(() => false);\n    const allowHexPrefStored = await figma.clientStorage\n        .getAsync(\"allowHexPref\")\n        .catch(() => null);\n    const githubRememberPrefStored = await figma.clientStorage\n        .getAsync(\"githubRememberPref\")\n        .catch(() => null);\n    const allowHexPrefVal =\n        typeof allowHexPrefStored === \"boolean\" ? allowHexPrefStored : true;\n    const githubRememberPrefVal =\n        typeof githubRememberPrefStored === \"boolean\"\n            ? githubRememberPrefStored\n            : true;\n    const lastOrNull =\n        last &&\n        typeof last.collection === \"string\" &&\n        typeof last.mode === \"string\"\n            ? last\n            : null;\n\n    const payload: CollectionsDataPayload = {\n        collections: snap.collections,\n        last: lastOrNull,\n        exportAllPref: !!exportAllPrefVal,\n        styleDictionaryPref: !!styleDictionaryPrefVal,\n        flatTokensPref: !!flatTokensPrefVal,\n        allowHexPref: allowHexPrefVal,\n        githubRememberPref: githubRememberPrefVal,\n    };\n\n    return {\n        payload,\n        rawText: snap.rawText,\n        count: snap.collections.length,\n        signature: computeCollectionsSignatureFromPayload(payload),\n    };\n}\n\nasync function refreshCollections(\n    reason: RefreshReason,\n    autoSource?: AutoRefreshSource | null\n): Promise<void> {\n    const prevStyleIds = new Set(knownStyleIds);\n    try {\n        const snap = await buildCollectionsPayload();\n        const shouldLog = reason !== \"auto\";\n        if (shouldLog) {\n            let message = \"\";\n            if (reason === \"initial\") {\n                message =\n                    \"Fetched \" + String(snap.count) + \" collections (initial)\";\n            } else if (reason === \"manual\") {\n                message = \"Fetched \" + String(snap.count) + \" collections\";\n            } else if (autoSource === \"style-event\") {\n                message =\n                    \"Document change detected; refreshed \" +\n                    String(snap.count) +\n                    \" collections\";\n            }\n            if (message) {\n                send({ type: \"INFO\", payload: { message } });\n            }\n        }\n        send({ type: \"COLLECTIONS_DATA\", payload: snap.payload });\n        send({ type: \"RAW_COLLECTIONS_TEXT\", payload: { text: snap.rawText } });\n        lastCollectionsSignature = snap.signature;\n        pendingSignatureAfterRefresh = null;\n        const nextStyleIds = collectCurrentStyleIds();\n        knownStyleIds.clear();\n        nextStyleIds.forEach((id) => knownStyleIds.add(id));\n        flushStyleEventLogs(prevStyleIds, nextStyleIds);\n    } catch (err) {\n        const message = (err as Error)?.message || \"unknown error\";\n        send({\n            type: \"ERROR\",\n            payload: { message: \"Failed to refresh collections: \" + message },\n        });\n    }\n}\n\nasync function computeVariableCollectionsSignature(): Promise<string | null> {\n    if (\n        !figma.variables ||\n        typeof figma.variables.getLocalVariableCollectionsAsync !== \"function\"\n    ) {\n        return null;\n    }\n\n    const collections =\n        await figma.variables.getLocalVariableCollectionsAsync();\n    const signatures: string[] = [];\n    const sortedCollections = (collections || [])\n        .slice()\n        .sort((a, b) => a.id.localeCompare(b.id));\n    for (let i = 0; i < sortedCollections.length; i++) {\n        const col = sortedCollections[i];\n        if (!col) continue;\n        signatures.push(col.id, col.name, col.defaultModeId);\n        const modes = (col.modes || [])\n            .slice()\n            .sort((a, b) => a.modeId.localeCompare(b.modeId));\n        for (let mi = 0; mi < modes.length; mi++) {\n            const mode = modes[mi];\n            signatures.push(mode.modeId, mode.name);\n        }\n        const vars = (col.variableIds || []).slice().sort();\n        for (let vi = 0; vi < vars.length; vi++) signatures.push(vars[vi]);\n    }\n\n    if (typeof figma.variables.getLocalVariablesAsync === \"function\") {\n        const allVars = await figma.variables.getLocalVariablesAsync();\n        const sortedVars = (allVars || [])\n            .slice()\n            .sort((a, b) => a.id.localeCompare(b.id));\n        for (let vi = 0; vi < sortedVars.length; vi++) {\n            const variable = sortedVars[vi];\n            if (!variable) continue;\n            signatures.push(\n                variable.id,\n                variable.name,\n                variable.variableCollectionId,\n                variable.resolvedType,\n                serializeVariableValues(variable.valuesByMode)\n            );\n        }\n    }\n\n    return signatures.join(\"|\");\n}\n\nfunction serializeVariableValues(\n    values: Record<string, unknown> | undefined\n): string {\n    if (!values) return \"\";\n    const parts: string[] = [];\n    const modeIds = Object.keys(values).sort();\n    for (let mi = 0; mi < modeIds.length; mi++) {\n        const modeId = modeIds[mi];\n        parts.push(modeId, formatVariableValue(values[modeId]));\n    }\n    return parts.join(\"|\");\n}\n\nfunction formatVariableValue(value: unknown): string {\n    if (value === null || typeof value === \"undefined\") return \"null\";\n    if (typeof value === \"number\" || typeof value === \"boolean\")\n        return String(value);\n    if (typeof value === \"string\") return value;\n    try {\n        return JSON.stringify(value);\n    } catch {\n        return \"[unserializable]\";\n    }\n}\n\nasync function variableGraphLikelyChanged(): Promise<boolean> {\n    try {\n        const signature = await computeVariableCollectionsSignature();\n        if (!signature) return false;\n        if (lastCollectionsSignature === null) {\n            pendingSignatureAfterRefresh = signature;\n            return true;\n        }\n        if (signature === lastCollectionsSignature) return false;\n        if (\n            pendingSignatureAfterRefresh &&\n            pendingSignatureAfterRefresh === signature\n        )\n            return false;\n        pendingSignatureAfterRefresh = signature;\n        return true;\n    } catch {\n        return true;\n    }\n}\n\nfunction isStyleDocumentChange(\n    change: DocumentChange | null | undefined\n): boolean {\n    if (!change) return false;\n    return (\n        change.type === \"STYLE_CREATE\" ||\n        change.type === \"STYLE_DELETE\" ||\n        change.type === \"STYLE_PROPERTY_CHANGE\"\n    );\n}\n\nfunction handleDocumentChangeEvent(event: DocumentChangeEvent): void {\n    if (!autoSyncActive || !event || !event.documentChanges) return;\n    const list = event.documentChanges;\n    let sawStyleChange = false;\n    for (let i = 0; i < list.length; i++) {\n        const change = list[i];\n        if (isStyleDocumentChange(change)) {\n            recordStyleEvent(change?.type, change?.id);\n            sawStyleChange = true;\n        }\n    }\n    if (sawStyleChange) {\n        requestAutoRefresh(\"style-event\");\n    }\n}\n\nfunction handleStyleChangeEvent(event: StyleChangeEvent): void {\n    if (!autoSyncActive || !event || !event.styleChanges) return;\n    const list = event.styleChanges;\n    let sawStyleChange = false;\n    for (let i = 0; i < list.length; i++) {\n        const change = list[i];\n        if (!change || !change.type) continue;\n        recordStyleEvent(change.type, change.id);\n        sawStyleChange = true;\n    }\n    if (sawStyleChange) {\n        requestAutoRefresh(\"style-event\");\n    }\n}\n\nfunction normalizeStyleId(raw: string | undefined): string | null {\n    if (!raw) return null;\n    const idx = raw.indexOf(\",\");\n    return idx >= 0 ? raw.slice(0, idx) : raw;\n}\n\nfunction recordStyleEvent(\n    type: string | undefined,\n    idRaw: string | undefined\n): void {\n    if (!type) return;\n    const id = normalizeStyleId(idRaw);\n    if (!id) return;\n    if (\n        type !== \"STYLE_CREATE\" &&\n        type !== \"STYLE_DELETE\" &&\n        type !== \"STYLE_PROPERTY_CHANGE\"\n    ) {\n        return;\n    }\n    if (idRaw) styleDisplayIds.set(id, idRaw);\n    const entry = pendingStyleEvents.get(id) || {};\n    if (type === \"STYLE_CREATE\") {\n        entry.create = true;\n        entry.update = false;\n        entry.delete = false;\n        entry.loggedUpdate = false;\n    } else if (type === \"STYLE_PROPERTY_CHANGE\") {\n        if (!entry.create) {\n            entry.update = true;\n            if (!entry.loggedUpdate && knownStyleIds.has(id)) {\n                logStyleMessage(\"Style updated\", styleDisplayIds.get(id) || id);\n                entry.loggedUpdate = true;\n            }\n        }\n    } else if (type === \"STYLE_DELETE\") {\n        entry.delete = true;\n    }\n    entry.attempts = entry.attempts || 0;\n    pendingStyleEvents.set(id, entry);\n}\n\nfunction collectCurrentStyleIds(): Set<string> {\n    const ids = new Set<string>();\n    try {\n        const collect = (\n            styles: BaseStyle[] | ReadonlyArray<BaseStyle> | undefined\n        ) => {\n            if (!styles) return;\n            for (let i = 0; i < styles.length; i++) {\n                const style = styles[i];\n                if (!style || typeof style.id !== \"string\") continue;\n                const norm = normalizeStyleId(style.id) || style.id;\n                ids.add(norm);\n            }\n        };\n        if (typeof figma.getLocalPaintStyles === \"function\")\n            collect(figma.getLocalPaintStyles());\n        if (typeof figma.getLocalTextStyles === \"function\")\n            collect(figma.getLocalTextStyles());\n        if (typeof figma.getLocalEffectStyles === \"function\")\n            collect(figma.getLocalEffectStyles());\n        if (typeof figma.getLocalGridStyles === \"function\")\n            collect(figma.getLocalGridStyles());\n    } catch {\n        // ignore\n    }\n    return ids;\n}\n\nfunction flushStyleEventLogs(prev: Set<string>, next: Set<string>): void {\n    if (pendingStyleEvents.size === 0) return;\n    const survivors = new Map<\n        string,\n        {\n            create?: boolean;\n            update?: boolean;\n            delete?: boolean;\n            attempts?: number;\n        }\n    >();\n    pendingStyleEvents.forEach((entry, id) => {\n        const hadPrev = prev.has(id);\n        const hasNext = next.has(id);\n        let handled = false;\n        if (entry.delete && hadPrev && !hasNext) {\n            logStyleMessage(\"Style deleted\", styleDisplayIds.get(id) || id);\n            handled = true;\n        } else if (entry.create && !hadPrev && hasNext) {\n            logStyleMessage(\"Style created\", styleDisplayIds.get(id) || id);\n            handled = true;\n        } else if (\n            entry.update &&\n            !entry.create &&\n            !entry.loggedUpdate &&\n            hadPrev &&\n            hasNext\n        ) {\n            logStyleMessage(\"Style updated\", styleDisplayIds.get(id) || id);\n            handled = true;\n        }\n        if (!handled) {\n            const attempts = (entry.attempts || 0) + 1;\n            if (attempts < 4) {\n                survivors.set(id, { ...entry, attempts });\n            }\n        }\n    });\n    pendingStyleEvents.clear();\n    survivors.forEach((value, key) => pendingStyleEvents.set(key, value));\n}\n\nfunction logStyleMessage(prefix: string, _id: string): void {\n    send({ type: \"INFO\", payload: { message: prefix } });\n}\n\nfunction requestAutoRefresh(source: AutoRefreshSource): void {\n    if (!autoSyncActive) return;\n    autoRefreshRequested = true;\n    if (source === \"style-event\") {\n        pendingAutoRefreshSource = \"style-event\";\n    } else if (pendingAutoRefreshSource !== \"style-event\") {\n        pendingAutoRefreshSource = \"variable-poll\";\n    }\n    if (autoRefreshTimer !== null) return;\n    autoRefreshTimer = setTimeout(runAutoRefresh, AUTO_REFRESH_DEBOUNCE_MS);\n}\n\nasync function runAutoRefresh(): Promise<void> {\n    autoRefreshTimer = null;\n    if (!autoSyncActive) {\n        autoRefreshRequested = false;\n        return;\n    }\n    if (!autoRefreshRequested) return;\n    if (autoRefreshRunning) {\n        if (autoRefreshTimer === null) {\n            autoRefreshTimer = setTimeout(\n                runAutoRefresh,\n                AUTO_REFRESH_DEBOUNCE_MS\n            );\n        }\n        return;\n    }\n\n    autoRefreshRequested = false;\n    autoRefreshRunning = true;\n    try {\n        const source = pendingAutoRefreshSource;\n        pendingAutoRefreshSource = null;\n        await refreshCollections(\"auto\", source);\n    } finally {\n        autoRefreshRunning = false;\n        if (\n            autoSyncActive &&\n            autoRefreshRequested &&\n            autoRefreshTimer === null\n        ) {\n            autoRefreshTimer = setTimeout(\n                runAutoRefresh,\n                AUTO_REFRESH_DEBOUNCE_MS\n            );\n        }\n    }\n}\n\n// Run the variable graph sampler on a steady cadence, but when a change is detected we\n// execute a short burst of faster polls so multiple edits settle quickly.\nfunction scheduleVariablePoll(\n    delayMs: number = VARIABLE_POLL_INTERVAL_MS\n): void {\n    if (!autoSyncActive || variablePollTimer !== null) return;\n    variablePollTimer = setTimeout(async () => {\n        variablePollTimer = null;\n        if (!autoSyncActive) return;\n        let needsRefresh = true;\n        try {\n            needsRefresh = await variableGraphLikelyChanged();\n        } catch {\n            needsRefresh = true;\n        }\n        if (needsRefresh) {\n            requestAutoRefresh(\"variable-poll\");\n            variableBurstRemaining = VARIABLE_POLL_BURST_LIMIT;\n            scheduleVariablePoll(VARIABLE_POLL_BURST_DELAY_MS);\n        } else {\n            if (variableBurstRemaining > 0) {\n                variableBurstRemaining--;\n                scheduleVariablePoll(VARIABLE_POLL_BURST_DELAY_MS);\n            } else {\n                scheduleVariablePoll(VARIABLE_POLL_INTERVAL_MS);\n            }\n        }\n    }, delayMs);\n}\n\nfunction startDocumentStateSync(): void {\n    if (autoSyncActive) return;\n    autoSyncActive = true;\n    documentChangeHandler = handleDocumentChangeEvent;\n    figma.on(\"documentchange\", handleDocumentChangeEvent);\n    if (typeof figma.on === \"function\") {\n        styleChangeHandler = handleStyleChangeEvent;\n        figma.on(\"stylechange\", handleStyleChangeEvent);\n    }\n    scheduleVariablePoll();\n}\n\nfunction stopDocumentStateSync(): void {\n    if (!autoSyncActive) return;\n    autoSyncActive = false;\n    if (documentChangeHandler) {\n        figma.off(\"documentchange\", documentChangeHandler);\n        documentChangeHandler = null;\n    }\n    if (styleChangeHandler) {\n        figma.off(\"stylechange\", styleChangeHandler);\n        styleChangeHandler = null;\n    }\n    if (variablePollTimer !== null) {\n        clearTimeout(variablePollTimer);\n        variablePollTimer = null;\n    }\n    autoRefreshRequested = false;\n    if (autoRefreshTimer !== null) {\n        clearTimeout(autoRefreshTimer);\n        autoRefreshTimer = null;\n    }\n    autoRefreshRunning = false;\n    pendingAutoRefreshSource = null;\n    pendingStyleEvents.clear();\n    styleDisplayIds.clear();\n    knownStyleIds.clear();\n}\n\nfigma.on(\"close\", () => {\n    stopDocumentStateSync();\n});\n\ntype MessageOfType<T extends UiToPlugin[\"type\"]> = Extract<\n    UiToPlugin,\n    { type: T }\n>;\ntype Handler = (msg: UiToPlugin) => Promise<void> | void;\n\n// Prime the UI with cached state and fresh collections so the iframe can render immediately.\nasync function handleUiReady(_msg: UiToPlugin): Promise<void> {\n    await refreshCollections(\"initial\");\n    await github.onUiReady();\n    startDocumentStateSync();\n}\n\n// Refresh the collection snapshot on demand, mirroring the bootstrap payload.\nasync function handleFetchCollections(_msg: UiToPlugin): Promise<void> {\n    await refreshCollections(\"manual\");\n}\n\n// Apply an uploaded DTCG payload to the document and broadcast the resulting summary back to the UI.\nasync function handleImportDtcg(msg: UiToPlugin): Promise<void> {\n    const payload = (msg as MessageOfType<\"IMPORT_DTCG\">).payload;\n    const contexts = Array.isArray(payload.contexts)\n        ? payload.contexts.map((c) => String(c))\n        : [];\n    const summary = await importDtcg(payload.json, {\n        allowHexStrings: !!payload.allowHexStrings,\n        contexts,\n    });\n\n    const skippedCount = summary.skippedContexts.length;\n    if (skippedCount > 0) {\n        send({\n            type: \"INFO\",\n            payload: {\n                message: `Import completed. Applied ${summary.appliedContexts.length} context(s); skipped ${skippedCount}.`,\n            },\n        });\n    } else {\n        send({ type: \"INFO\", payload: { message: \"Import completed.\" } });\n    }\n\n    send({\n        type: \"IMPORT_SUMMARY\",\n        payload: { summary, timestamp: Date.now(), source: \"local\" },\n    });\n\n    const snap = await snapshotCollectionsForUi();\n    const last = await figma.clientStorage\n        .getAsync(\"lastSelection\")\n        .catch(() => null);\n    const exportAllPrefVal = await figma.clientStorage\n        .getAsync(\"exportAllPref\")\n        .catch(() => false);\n    const styleDictionaryPrefVal = await figma.clientStorage\n        .getAsync(\"styleDictionaryPref\")\n        .catch(() => false);\n    const flatTokensPrefVal = await figma.clientStorage\n        .getAsync(\"flatTokensPref\")\n        .catch(() => false);\n    const allowHexPrefStored = await figma.clientStorage\n        .getAsync(\"allowHexPref\")\n        .catch(() => null);\n    const githubRememberPrefStored = await figma.clientStorage\n        .getAsync(\"githubRememberPref\")\n        .catch(() => null);\n    const allowHexPrefVal =\n        typeof allowHexPrefStored === \"boolean\" ? allowHexPrefStored : true;\n    const githubRememberPrefVal =\n        typeof githubRememberPrefStored === \"boolean\"\n            ? githubRememberPrefStored\n            : true;\n    const lastOrNull =\n        last &&\n        typeof last.collection === \"string\" &&\n        typeof last.mode === \"string\"\n            ? last\n            : null;\n\n    send({\n        type: \"COLLECTIONS_DATA\",\n        payload: {\n            collections: snap.collections,\n            last: lastOrNull,\n            exportAllPref: !!exportAllPrefVal,\n            styleDictionaryPref: !!styleDictionaryPrefVal,\n            flatTokensPref: !!flatTokensPrefVal,\n            allowHexPref: allowHexPrefVal,\n            githubRememberPref: githubRememberPrefVal,\n        },\n    });\n    send({ type: \"RAW_COLLECTIONS_TEXT\", payload: { text: snap.rawText } });\n}\n\n// Export tokens either per mode or as a single bundle, matching the UI's requested scope.\nasync function handleExportDtcg(msg: UiToPlugin): Promise<void> {\n    const payload = (msg as MessageOfType<\"EXPORT_DTCG\">).payload;\n    const exportAll = !!payload.exportAll;\n    const styleDictionary = !!payload.styleDictionary;\n    const flatTokens = !!payload.flatTokens;\n    if (exportAll) {\n        const all = await exportDtcg({\n            format: \"single\",\n            styleDictionary,\n            flatTokens,\n        });\n        send({ type: \"EXPORT_RESULT\", payload: { files: all.files } });\n        return;\n    }\n\n    const collectionName = payload.collection ? payload.collection : \"\";\n    const modeName = payload.mode ? payload.mode : \"\";\n    const per = await exportDtcg({\n        format: \"perMode\",\n        styleDictionary,\n        flatTokens,\n    });\n\n    const prettyExact = `${collectionName} - ${modeName}.json`;\n    const prettyLoose = `${collectionName} - ${modeName}`;\n    const legacy1 = `${collectionName}_mode=${modeName}`;\n    const legacy2 = `${collectionName}/mode=${modeName}`;\n    const legacy3 = safeKeyFromCollectionAndMode(collectionName, modeName);\n\n    let picked = per.files.find((f) => {\n        const n = String(f?.name || \"\");\n        return (\n            n === prettyExact ||\n            n === prettyLoose ||\n            n.includes(`${collectionName} - ${modeName}`)\n        );\n    });\n    if (!picked) {\n        picked = per.files.find((f) => {\n            const n = String(f?.name || \"\");\n            return (\n                n.includes(legacy1) ||\n                n.includes(legacy2) ||\n                n.includes(legacy3)\n            );\n        });\n    }\n\n    const filesToSend = picked ? [picked] : per.files;\n    if (!picked) {\n        send({\n            type: \"INFO\",\n            payload: {\n                message: `Export: pretty file not found for \"${collectionName}\" / \"${modeName}\". Falling back to all per-mode files.`,\n            },\n        });\n    }\n    send({ type: \"EXPORT_RESULT\", payload: { files: filesToSend } });\n}\n\n// Convert local text styles into typography tokens and surface the preview payload to the UI.\nasync function handleExportTypography(_msg: UiToPlugin): Promise<void> {\n    const result = await exportDtcg({ format: \"typography\" });\n    send({ type: \"EXPORT_RESULT\", payload: { files: result.files } });\n    if (result.files.length > 0) {\n        const first = result.files[0];\n        send({\n            type: \"W3C_PREVIEW\",\n            payload: { name: first.name, json: first.json },\n        });\n    }\n}\n\n// Persist the last selected collection/mode pair so the UI can restore the user's focus.\nasync function handleSaveLast(msg: UiToPlugin): Promise<void> {\n    const payload = (msg as MessageOfType<\"SAVE_LAST\">).payload;\n    if (\n        typeof payload.collection === \"string\" &&\n        typeof payload.mode === \"string\"\n    ) {\n        await figma.clientStorage.setAsync(\"lastSelection\", {\n            collection: payload.collection,\n            mode: payload.mode,\n        });\n    }\n}\n\n// Store persistent export preferences (currently the \"export all\" toggle).\nasync function handleSavePrefs(msg: UiToPlugin): Promise<void> {\n    const payload = (msg as MessageOfType<\"SAVE_PREFS\">).payload;\n    if (typeof payload.exportAll === \"boolean\") {\n        await figma.clientStorage.setAsync(\n            \"exportAllPref\",\n            !!payload.exportAll\n        );\n    }\n    if (typeof payload.styleDictionary === \"boolean\") {\n        await figma.clientStorage.setAsync(\n            \"styleDictionaryPref\",\n            !!payload.styleDictionary\n        );\n    }\n    if (typeof payload.flatTokens === \"boolean\") {\n        await figma.clientStorage.setAsync(\n            \"flatTokensPref\",\n            !!payload.flatTokens\n        );\n    }\n    if (typeof payload.allowHexStrings === \"boolean\") {\n        await figma.clientStorage.setAsync(\n            \"allowHexPref\",\n            !!payload.allowHexStrings\n        );\n    }\n    if (typeof payload.githubRememberToken === \"boolean\") {\n        const rememberPref = !!payload.githubRememberToken;\n        await figma.clientStorage.setAsync(\"githubRememberPref\", rememberPref);\n        if (!rememberPref) {\n            await figma.clientStorage\n                .deleteAsync(\"github_token_b64\")\n                .catch(() => {});\n        }\n    }\n}\n\n// Remember the iframe size so subsequent launches reopen with the user's preferred bounds.\nasync function handleUiResize(msg: UiToPlugin): Promise<void> {\n    const payload = (msg as MessageOfType<\"UI_RESIZE\">).payload;\n    const w = Math.max(720, Math.min(1600, Math.floor(payload.width)));\n    const h = Math.max(420, Math.min(1200, Math.floor(payload.height)));\n    figma.ui.resize(w, h);\n    try {\n        await figma.clientStorage.setAsync(\"uiSize\", { width: w, height: h });\n    } catch {}\n}\n\n// Respond to preview requests by exporting the closest match and pushing it to the W3C preview pane.\nasync function handlePreviewRequest(msg: UiToPlugin): Promise<void> {\n    const payload = (msg as MessageOfType<\"PREVIEW_REQUEST\">).payload;\n    const collectionName = payload.collection ? String(payload.collection) : \"\";\n    const modeName = payload.mode ? String(payload.mode) : \"\";\n    const styleDictionary = !!payload.styleDictionary;\n    const flatTokens = !!payload.flatTokens;\n\n    const per = await exportDtcg({\n        format: \"perMode\",\n        styleDictionary,\n        flatTokens,\n    });\n\n    const prettyExact = `${collectionName} - ${modeName}.json`;\n    const prettyLoose = `${collectionName} - ${modeName}`;\n    const legacy1 = `${collectionName}_mode=${modeName}`;\n    const legacy2 = `${collectionName}/mode=${modeName}`;\n    const legacy3 = safeKeyFromCollectionAndMode(collectionName, modeName);\n\n    const picked = per.files.find((f) => {\n        const n = String(f?.name || \"\");\n        return (\n            n === prettyExact ||\n            n === prettyLoose ||\n            n.includes(`${collectionName} - ${modeName}`)\n        );\n    }) ||\n        per.files.find((f) => {\n            const n = String(f?.name || \"\");\n            return (\n                n.includes(legacy1) ||\n                n.includes(legacy2) ||\n                n.includes(legacy3)\n            );\n        }) ||\n        per.files[0] || { name: \"tokens-empty.json\", json: {} };\n\n    send({\n        type: \"W3C_PREVIEW\",\n        payload: { name: picked.name, json: picked.json },\n    });\n}\n\nconst coreHandlers = new Map<UiToPlugin[\"type\"], Handler>([\n    [\"UI_READY\", handleUiReady],\n    [\"FETCH_COLLECTIONS\", handleFetchCollections],\n    [\"IMPORT_DTCG\", handleImportDtcg],\n    [\"EXPORT_DTCG\", handleExportDtcg],\n    [\"EXPORT_TYPOGRAPHY\", handleExportTypography],\n    [\"SAVE_LAST\", handleSaveLast],\n    [\"SAVE_PREFS\", handleSavePrefs],\n    [\"UI_RESIZE\", handleUiResize],\n    [\"PREVIEW_REQUEST\", handlePreviewRequest],\n]);\n\nfigma.ui.onmessage = async (msg: UiToPlugin) => {\n    try {\n        const handler = coreHandlers.get(msg.type as UiToPlugin[\"type\"]);\n        if (handler) {\n            await handler(msg);\n            return;\n        }\n\n        if (await github.handle(msg)) return;\n    } catch (e) {\n        let message = \"Unknown error\";\n        if (e && (e as Error).message) message = (e as Error).message;\n        figma.notify(\"Plugin error: \" + message, { timeout: 4000 });\n        send({ type: \"ERROR\", payload: { message } });\n        // eslint-disable-next-line no-console\n        console.error(e);\n    }\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAGA,iBAAsB,2BAQnB;AACD,QAAI,OAAO,MAAM,eAAe,YAAY,MAAM,eAAe,SAAS;AACxE,aAAO;AAAA,QACL,aAAa,CAAC;AAAA,QACd,SACE;AAAA,MAEJ;AAAA,IACF;AACA,QACE,OAAO,MAAM,cAAc,eAC3B,OAAO,MAAM,UAAU,qCAAqC,cAC5D,OAAO,MAAM,UAAU,yBAAyB,YAChD;AACA,aAAO;AAAA,QACL,aAAa,CAAC;AAAA,QACd,SACE;AAAA,MACJ;AAAA,IACF;AAEA,UAAM,SAA+B,MAAM,MAAM,UAAU,iCAAiC;AAE5F,UAAM,MAKD,CAAC;AACN,UAAM,WAAqB,CAAC;AAE5B,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,YAAM,IAAI,OAAO,CAAC;AAClB,UAAI,CAAC,EAAG;AAER,YAAM,QAA6C,CAAC;AACpD,eAAS,KAAK,GAAG,KAAK,EAAE,MAAM,QAAQ,MAAM;AAC1C,cAAM,IAAI,EAAE,MAAM,EAAE;AACpB,cAAM,KAAK,EAAE,IAAI,EAAE,QAAQ,MAAM,EAAE,KAAK,CAAC;AAAA,MAC3C;AAEA,YAAM,WAA8D,CAAC;AACrE,eAAS,KAAK,GAAG,KAAK,EAAE,YAAY,QAAQ,MAAM;AAChD,cAAM,QAAQ,EAAE,YAAY,EAAE;AAC9B,cAAM,IAAI,MAAM,MAAM,UAAU,qBAAqB,KAAK;AAC1D,YAAI,CAAC,EAAG;AACR,iBAAS,KAAK,EAAE,IAAI,EAAE,IAAI,MAAM,EAAE,MAAM,MAAM,EAAE,aAAa,CAAC;AAAA,MAChE;AAEA,UAAI,KAAK,EAAE,IAAI,EAAE,IAAI,MAAM,EAAE,MAAM,OAAc,WAAW,SAAS,CAAC;AAEtE,eAAS,KAAK,iBAAiB,EAAE,OAAO,OAAO,EAAE,KAAK,GAAG;AACzD,YAAM,YAAsB,MAAM,IAAI,OAAK,EAAE,IAAI;AACjD,eAAS,KAAK,eAAe,UAAU,SAAS,IAAI,UAAU,KAAK,IAAI,IAAI,SAAS;AACpF,eAAS,KAAK,kBAAkB,OAAO,SAAS,MAAM,IAAI,IAAI;AAC9D,eAAS,KAAK,GAAG,KAAK,SAAS,QAAQ,MAAM;AAC3C,iBAAS,KAAK,WAAW,SAAS,EAAE,EAAE,OAAO,OAAO,SAAS,EAAE,EAAE,OAAO,GAAG;AAAA,MAC7E;AACA,eAAS,KAAK,EAAE;AAAA,IAClB;AAEA,QAAI,IAAI,WAAW,GAAG;AACpB,eAAS,KAAK,sCAAsC;AACpD,eAAS,KAAK,wDAAwD;AAAA,IACxE;AAEA,QAAI,OAAO,MAAM,uBAAuB,YAAY;AAClD,YAAM,aAAa,MAAM,mBAAmB;AAC5C,eAAS,KAAK,EAAE;AAChB,eAAS,KAAK,kBAAkB,OAAO,WAAW,MAAM,CAAC;AACzD,eAAS,KAAK,GAAG,KAAK,WAAW,QAAQ,MAAM;AAC7C,cAAM,QAAQ,WAAW,EAAE;AAC3B,iBAAS,KAAK,SAAS,MAAM,IAAI;AAAA,MACnC;AACA,UAAI,WAAW,WAAW,GAAG;AAC3B,iBAAS,KAAK,iCAAiC;AAAA,MACjD;AAAA,IACF;AAEA,WAAO,EAAE,aAAa,KAAK,SAAS,SAAS,KAAK,IAAI,EAAE;AAAA,EAC1D;AAEO,WAAS,6BAA6B,gBAAwB,UAA0B;AAC7F,UAAM,OAAO,iBAAiB,WAAW;AACzC,QAAI,MAAM;AACV,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,YAAM,KAAK,KAAK,OAAO,CAAC;AACxB,aAAQ,OAAO,OAAO,OAAO,QAAQ,OAAO,MAAO,MAAM;AAAA,IAC3D;AACA,WAAO;AAAA,EACT;AAEA,iBAAsB,sBAAsB,gBAAwB,UAKjE;AACD,QAAI;AACF,YAAM,OAAO,MAAM,yBAAyB;AAC5C,YAAM,MAAM,KAAK,YAAY,KAAK,OAAK,EAAE,SAAS,cAAc;AAChE,UAAI,CAAC,IAAK,QAAO,EAAE,IAAI,OAAO,SAAS,eAAe,cAAc,4BAA4B;AAChG,UAAI,CAAC,IAAI,aAAa,IAAI,UAAU,WAAW,GAAG;AAChD,eAAO,EAAE,IAAI,OAAO,SAAS,eAAe,cAAc,4BAA4B;AAAA,MACxF;AACA,YAAM,OAAO,IAAI,MAAM,KAAK,OAAK,EAAE,SAAS,QAAQ;AACpD,UAAI,CAAC,KAAM,QAAO,EAAE,IAAI,OAAO,SAAS,SAAS,QAAQ,8BAA8B,cAAc,KAAK;AAE1G,UAAI,aAAa;AACjB,iBAAW,KAAK,IAAI,WAAW;AAC7B,cAAM,OAAO,MAAM,MAAM,UAAU,qBAAqB,EAAE,EAAE;AAC5D,YAAI,QAAQ,KAAK,gBAAiB,KAAK,MAAM,KAAK,aAAe;AAAA,MACnE;AACA,aAAO,EAAE,IAAI,MAAM,eAAe,IAAI,UAAU,QAAQ,qBAAqB,WAAW;AAAA,IAC1F,SAAS,GAAG;AACV,aAAO,EAAE,IAAI,OAAO,UAAU,uBAAa,YAAW,kBAAkB;AAAA,IAC1E;AAAA,EACF;;;ACrHO,WAAS,YAAY,GAAmB;AAC7C,WAAO,OAAO,CAAC,EACZ,KAAK,EACL,QAAQ,QAAQ,GAAG,EACnB,QAAQ,OAAO,GAAG,EAClB,YAAY;AAAA,EACjB;AAMO,WAAS,cAAc,YAAoB,cAAgC;AAChF,UAAM,OAAO,OAAO,YAAY,EAC7B,MAAM,GAAG,EACT,IAAI,OAAK,EAAE,KAAK,CAAC,EACjB,OAAO,OAAO;AACjB,WAAO,CAAC,YAAY,GAAG,IAAI;AAAA,EAC7B;AAEO,WAAS,MAAM,MAAwB;AAC5C,QAAI,IAAI,GAAG,IAAI;AACf,SAAK,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AAChC,UAAI,IAAI,EAAG,MAAK;AAChB,WAAK,KAAK,CAAC;AAAA,IACb;AACA,WAAO;AAAA,EACT;AAuBO,WAAS,UAAU,OAA+B;AACvD,QAAI,OAA2B,CAAC;AAChC,QAAI,OAAoB,CAAC;AACzB,QAAI,IAAI;AACR,SAAK,IAAI,GAAG,IAAI,MAAM,OAAO,QAAQ,KAAK;AACxC,UAAI,IAAI,MAAM,OAAO,CAAC;AACtB,UAAI,MAAM,UAAU,EAAE,IAAI;AAC1B,UAAI,CAAC,KAAK,GAAG,GAAG;AACd,aAAK,GAAG,IAAI;AACZ,aAAK,KAAK,CAAC;AAAA,MACb;AAAA,IACF;AACA,SAAK,KAAK,SAAU,GAAG,GAAG;AACxB,UAAI,KAAK,MAAM,EAAE,IAAI;AACrB,UAAI,KAAK,MAAM,EAAE,IAAI;AACrB,UAAI,KAAK,GAAI,QAAO;AACpB,UAAI,KAAK,GAAI,QAAO;AACpB,aAAO;AAAA,IACT,CAAC;AACD,WAAO,EAAE,QAAQ,KAAK;AAAA,EACxB;AAEA,WAAS,UAAU,MAAwB;AACzC,QAAI,IAAI,GAAG,IAAI;AACf,SAAK,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AAChC,UAAI,IAAI,EAAG,MAAK;AAChB,WAAK,KAAK,CAAC;AAAA,IACb;AACA,WAAO;AAAA,EACT;;;ACjBA,MAAM,aAAoC;AAAA,IACxC,YAAY;AAAA,IACZ,WAAW;AAAA,IACX,YAAY;AAAA,IACZ,UAAU;AAAA,IACV,YAAY;AAAA,IACZ,eAAe;AAAA,IACf,kBAAkB;AAAA,IAClB,iBAAiB;AAAA,IACjB,UAAU;AAAA,IACV,gBAAgB;AAAA,IAChB,qBAAqB;AAAA,IACrB,mBAAmB;AAAA,IACnB,aAAa;AAAA,EACf;AAEA,WAAS,eAAe,GAAyB;AAC/C,WAAO,OAAO,MAAM,YAAY,SAAS,CAAC;AAAA,EAC5C;AAEA,WAAS,cAAc,KAAoC;AACzD,QAAI,OAAO,QAAQ,SAAU,QAAO;AACpC,UAAM,QAAQ,IAAI,KAAK,EAAE,YAAY;AACrC,QAAI,UAAU,WAAW,UAAU,YAAY,UAAU,KAAM,QAAO;AACtE,QAAI,UAAU,aAAa,UAAU,gBAAgB,UAAU,IAAK,QAAO;AAC3E,WAAO;AAAA,EACT;AAEA,WAAS,eAAe,KAAqC;AAC3D,QAAI,CAAC,OAAO,OAAO,QAAQ,SAAU,QAAO;AAC5C,UAAM,MAAM;AACZ,UAAM,QAAQ,IAAI;AAClB,UAAM,OAAO,cAAc,IAAI,IAAI;AACnC,QAAI,CAAC,eAAe,KAAK,KAAK,CAAC,KAAM,QAAO;AAC5C,WAAO,EAAE,OAAO,KAAK;AAAA,EACvB;AAEA,WAAS,oBAAoB,KAAqC;AAChE,QAAI,OAAO,OAAO,QAAQ,YAAY,CAAC,MAAM,QAAQ,GAAG,GAAG;AACzD,aAAO,eAAe,GAAG;AAAA,IAC3B;AACA,QAAI,eAAe,GAAG,GAAG;AACvB,aAAO,EAAE,OAAO,KAAK,MAAM,QAAQ;AAAA,IACrC;AACA,WAAO;AAAA,EACT;AAGO,WAAS,qBAAqB,KAAsC;AACzE,QAAI,CAAC,OAAO,OAAO,QAAQ,YAAY,MAAM,QAAQ,GAAG,EAAG,QAAO;AAClE,UAAM,MAAM;AACZ,UAAM,QAAyB,CAAC;AAChC,QAAI,aAAa;AAEjB,QAAI,OAAO,IAAI,eAAe,YAAY,IAAI,WAAW,KAAK,EAAE,SAAS,GAAG;AAC1E,YAAM,aAAa,IAAI;AACvB,mBAAa;AAAA,IACf;AACA,QAAI,OAAO,IAAI,cAAc,YAAY,IAAI,UAAU,KAAK,EAAE,SAAS,GAAG;AACxE,YAAM,YAAY,IAAI;AACtB,mBAAa;AAAA,IACf;AACA,QAAI,OAAO,IAAI,eAAe,YAAY,IAAI,WAAW,KAAK,EAAE,SAAS,GAAG;AAC1E,YAAM,aAAa,IAAI;AACvB,mBAAa;AAAA,IACf;AACA,QAAI,OAAO,IAAI,gBAAgB,YAAY,IAAI,YAAY,KAAK,EAAE,SAAS,GAAG;AAC5E,YAAM,cAAc,IAAI;AACxB,mBAAa;AAAA,IACf;AAEA,UAAM,WAAW,eAAe,IAAI,QAAQ;AAC5C,QAAI,UAAU;AACZ,YAAM,WAAW;AACjB,mBAAa;AAAA,IACf;AAEA,UAAM,gBAAgB,IAAI;AAC1B,QAAI,OAAO,kBAAkB,UAAU;AACrC,UAAI,eAAe,aAAa,GAAG;AACjC,cAAM,aAAa,EAAE,OAAO,gBAAgB,KAAK,MAAM,UAAU;AACjE,qBAAa;AAAA,MACf;AAAA,IACF,WAAW,OAAO,kBAAkB,UAAU;AAC5C,UAAI,cAAc,KAAK,EAAE,YAAY,MAAM,QAAQ;AACjD,cAAM,aAAa;AACnB,qBAAa;AAAA,MACf;AAAA,IACF,OAAO;AACL,YAAM,aAAa,eAAe,aAAa;AAC/C,UAAI,YAAY;AACd,cAAM,aAAa;AACnB,qBAAa;AAAA,MACf;AAAA,IACF;AAEA,UAAM,gBAAgB,eAAe,IAAI,aAAa;AACtD,QAAI,eAAe;AACjB,YAAM,gBAAgB;AACtB,mBAAa;AAAA,IACf;AAEA,UAAM,mBAAmB,oBAAoB,IAAI,gBAAgB;AACjE,QAAI,kBAAkB;AACpB,YAAM,mBAAmB;AACzB,mBAAa;AAAA,IACf;AAEA,UAAM,kBAAkB,oBAAoB,IAAI,eAAe;AAC/D,QAAI,iBAAiB;AACnB,YAAM,kBAAkB;AACxB,mBAAa;AAAA,IACf;AAEA,QAAI,OAAO,IAAI,aAAa,YAAY,IAAI,SAAS,KAAK,EAAE,SAAS,GAAG;AACtE,YAAM,WAAW,IAAI;AACrB,mBAAa;AAAA,IACf;AAEA,QAAI,OAAO,IAAI,mBAAmB,YAAY,IAAI,eAAe,KAAK,EAAE,SAAS,GAAG;AAClF,YAAM,iBAAiB,IAAI;AAC3B,mBAAa;AAAA,IACf;AAEA,QAAI,OAAO,IAAI,wBAAwB,YAAY,IAAI,oBAAoB,KAAK,EAAE,SAAS,GAAG;AAC5F,YAAM,sBAAsB,IAAI;AAChC,mBAAa;AAAA,IACf;AAEA,QAAI,OAAO,IAAI,sBAAsB,YAAY,IAAI,kBAAkB,KAAK,EAAE,SAAS,GAAG;AACxF,YAAM,oBAAoB,IAAI;AAC9B,mBAAa;AAAA,IACf;AAGA,eAAW,OAAO,OAAO,KAAK,GAAG,GAAG;AAClC,UAAI,WAAW,GAAG,EAAG;AACrB,YAAM,IAAI,IAAI,GAAG;AACjB,UAAI,OAAO,MAAM,YAAa;AAC9B,MAAC,MAAkC,GAAG,IAAI;AAAA,IAC5C;AAEA,WAAO,aAAa,QAAQ;AAAA,EAC9B;AAEA,WAAS,uCACP,eACA,YACsC;AACtC,QAAI,CAAC,cAAe,QAAO;AAC3B,QAAI,cAAc,SAAS,SAAS;AAClC,aAAO,EAAE,OAAO,cAAc,OAAO,MAAM,KAAK;AAAA,IAClD;AACA,QAAI,cAAc,SAAS,aAAa,OAAO,eAAe,UAAU;AACtE,aAAO,EAAE,OAAQ,cAAc,QAAQ,MAAO,YAAY,MAAM,KAAK;AAAA,IACvE;AACA,WAAO;AAAA,EACT;AAEA,WAAS,oCACP,YACA,YAC6B;AAC7B,QAAI,CAAC,WAAY,QAAO;AACxB,QAAI,eAAe,OAAQ,QAAO;AAClC,QAAI,WAAW,SAAS,WAAW;AACjC,aAAO,WAAW,QAAQ;AAAA,IAC5B;AACA,QAAI,WAAW,SAAS,WAAW,OAAO,eAAe,YAAY,eAAe,GAAG;AACrF,aAAO,WAAW,QAAQ;AAAA,IAC5B;AACA,WAAO;AAAA,EACT;AAGO,WAAS,yBAAyB,OAAiD;AACxF,UAAM,MAA+B,CAAC;AAEtC,QAAI,OAAO,MAAM,eAAe,SAAU,KAAI,aAAa,MAAM;AACjE,QAAI,OAAO,MAAM,eAAe,SAAU,KAAI,aAAa,MAAM;AAEjE,UAAM,cAAc,MAA0B;AAC5C,UAAI,CAAC,MAAM,SAAU,QAAO;AAC5B,UAAI,MAAM,SAAS,SAAS,SAAS;AACnC,cAAM,aAAuC,EAAE,OAAO,MAAM,SAAS,OAAO,MAAM,KAAK;AACvF,YAAI,WAAW;AACf,eAAO,MAAM,SAAS;AAAA,MACxB;AACA,aAAO;AAAA,IACT,GAAG;AAEH,UAAM,0BAA0B,uCAAuC,MAAM,eAAe,UAAU;AACtG,QAAI,yBAAyB;AAC3B,UAAI,gBAAgB;AAAA,IACtB;AAEA,UAAM,uBAAuB,oCAAoC,MAAM,YAAY,UAAU;AAC7F,QAAI,OAAO,yBAAyB,aAAa;AAC/C,UAAI,aAAa;AAAA,IACnB;AAEA,WAAO;AAAA,EACT;AAEA,WAAS,uBAAuB,KAAqD;AACnF,QAAI,CAAC,eAAe,GAAG,EAAG,QAAO;AACjC,WAAO,EAAE,OAAO,KAAK,MAAM,QAAQ;AAAA,EACrC;AAEA,MAAM,gBAA2C;AAAA,IAC/C,UAAU;AAAA,IACV,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,YAAY;AAAA,IACZ,mBAAmB;AAAA,EACrB;AAEA,MAAM,sBAAiD;AAAA,IACrD,MAAM;AAAA,IACN,WAAW;AAAA,IACX,eAAe;AAAA,EACjB;AAEA,MAAM,4BAAuD;AAAA,IAC3D,MAAM;AAAA,IACN,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,WAAW;AAAA,EACb;AAEA,MAAM,0BAAqD;AAAA,IACzD,KAAK;AAAA,IACL,QAAQ;AAAA,IACR,QAAQ;AAAA,EACV;AAEA,WAAS,eAAe,OAA+C;AACrE,QAAI,CAAC,MAAO,QAAO;AACnB,UAAM,QAAQ,MAAM,KAAK,EAAE,YAAY;AACvC,QAAI,MAAM,SAAS,QAAQ,KAAK,MAAM,SAAS,SAAS,EAAG,QAAO;AAClE,WAAO;AAAA,EACT;AAGO,WAAS,6BAA6B,OAAiD;AAC5F,UAAM,QAAyB,CAAC;AAChC,UAAMA,SAAkC,CAAC;AAEzC,UAAM,cAAc,CAClB,KACA,QACS;AACT,UAAI,OAAO,QAAQ,YAAa;AAChC,MAAAA,OAAM,GAAG,IAAI;AAAA,IACf;AAEA,UAAM,WAAW,MAAM;AACvB,QAAI,YAAY,OAAO,SAAS,WAAW,UAAU;AACnD,YAAM,aAAa,SAAS;AAAA,IAC9B;AACA,QAAI,YAAY,OAAO,SAAS,UAAU,UAAU;AAClD,YAAM,aAAa,SAAS;AAC5B,YAAM,cAAc,SAAS;AAC7B,YAAM,YAAY,eAAe,SAAS,KAAK;AAC/C,kBAAY,eAAe,SAAS,KAAK;AACzC,kBAAY,aAAa,SAAS,KAAK;AAAA,IACzC;AAEA,QAAI,eAAe,MAAM,QAAQ,GAAG;AAClC,YAAM,WAAW,EAAE,OAAO,MAAM,UAAU,MAAM,QAAQ;AAAA,IAC1D;AAEA,UAAM,aAAa,MAAM;AACzB,QAAI,cAAc,OAAO,WAAW,SAAS,UAAU;AACrD,YAAM,OAAO,WAAW;AACxB,UAAI,SAAS,QAAQ;AACnB,cAAM,aAAa;AACnB,oBAAY,cAAc,EAAE,MAAM,OAAO,CAAC;AAAA,MAC5C,WAAW,SAAS,YAAY,eAAe,WAAW,KAAK,GAAG;AAChE,cAAM,aAAa,EAAE,OAAO,WAAW,OAAO,MAAM,QAAQ;AAC5D,oBAAY,cAAc,EAAE,MAAM,UAAU,OAAO,WAAW,MAAM,CAAC;AAAA,MACvE,WAAW,SAAS,aAAa,eAAe,WAAW,KAAK,GAAG;AACjE,cAAM,aAAa,EAAE,OAAO,WAAW,OAAO,MAAM,UAAU;AAC9D,oBAAY,cAAc,EAAE,MAAM,WAAW,OAAO,WAAW,MAAM,CAAC;AAAA,MACxE;AAAA,IACF;AAEA,UAAM,gBAAgB,MAAM;AAC5B,QAAI,iBAAiB,OAAO,cAAc,SAAS,YAAY,eAAe,cAAc,KAAK,GAAG;AAClG,UAAI,cAAc,SAAS,UAAU;AACnC,cAAM,gBAAgB,EAAE,OAAO,cAAc,OAAO,MAAM,QAAQ;AAClE,oBAAY,iBAAiB,EAAE,MAAM,UAAU,OAAO,cAAc,MAAM,CAAC;AAAA,MAC7E,WAAW,cAAc,SAAS,WAAW;AAC3C,cAAM,gBAAgB,EAAE,OAAO,cAAc,OAAO,MAAM,UAAU;AACpE,oBAAY,iBAAiB,EAAE,MAAM,WAAW,OAAO,cAAc,MAAM,CAAC;AAAA,MAC9E;AAAA,IACF;AAEA,UAAM,mBAAmB,uBAAuB,MAAM,gBAAgB;AACtE,QAAI,kBAAkB;AACpB,YAAM,mBAAmB;AACzB,kBAAY,oBAAoB,iBAAiB,KAAK;AAAA,IACxD;AAEA,UAAM,kBAAkB,uBAAuB,MAAM,eAAe;AACpE,QAAI,iBAAiB;AACnB,YAAM,kBAAkB;AACxB,kBAAY,mBAAmB,gBAAgB,KAAK;AAAA,IACtD;AAEA,UAAM,WAAY,MAAgC;AAClD,QAAI,YAAY,OAAO,aAAa,UAAU;AAC5C,YAAM,WAAW,cAAc,QAAQ,KAAK,SAAS,YAAY;AACjE,kBAAY,YAAY,QAAQ;AAAA,IAClC;AAEA,UAAM,iBAAkB,MAAsC;AAC9D,QAAI,kBAAkB,OAAO,mBAAmB,UAAU;AACxD,YAAM,iBAAiB,oBAAoB,cAAc,KAAK,eAAe,YAAY;AACzF,kBAAY,kBAAkB,cAAc;AAAA,IAC9C;AAEA,UAAM,sBAAuB,MAA2C;AACxE,QAAI,uBAAuB,OAAO,wBAAwB,UAAU;AAClE,YAAM,sBAAsB,0BAA0B,mBAAmB,KAAK,oBAAoB,YAAY;AAC9G,kBAAY,uBAAuB,mBAAmB;AAAA,IACxD;AAEA,UAAM,oBAAqB,MAAyC;AACpE,QAAI,qBAAqB,OAAO,sBAAsB,UAAU;AAC9D,YAAM,oBAAoB,wBAAwB,iBAAiB,KAAK,kBAAkB,YAAY;AACtG,kBAAY,qBAAqB,iBAAiB;AAAA,IACpD;AAEA,UAAM,cAAe,MAAoC;AACzD,QAAI,OAAO,gBAAgB,YAAa,aAAY,eAAe,WAAW;AAE9E,UAAM,cAAe,MAAmC;AACxD,QAAI,eAAe,WAAW,EAAG,aAAY,eAAe,WAAW;AAEvE,UAAM,qBAAsB,MAA2C;AACvE,QAAI,OAAO,uBAAuB,UAAW,aAAY,sBAAsB,kBAAkB;AAEjG,UAAM,cAAe,MAAoC;AACzD,QAAI,OAAO,gBAAgB,UAAW,aAAY,eAAe,WAAW;AAE5E,UAAM,iBAAkB,MAAsC;AAC9D,QAAI,OAAO,mBAAmB,SAAU,aAAY,kBAAkB,cAAc;AAEpF,UAAM,QAAS,MAA8B;AAC7C,QAAI,OAAO,UAAU,YAAa,aAAY,SAAS,KAAK;AAE5D,UAAM,UAAW,MAAgC;AACjD,QAAI,OAAO,YAAY,YAAa,aAAY,WAAW,OAAO;AAGlE,UAAM,UAA2B,CAAC;AAClC,eAAW,OAAO,OAAO,KAAK,KAAK,GAAG;AACpC,YAAM,IAAK,MAAkC,GAAG;AAChD,UAAI,OAAO,MAAM,YAAa;AAC9B,cAAQ,GAAG,IAAI;AAAA,IACjB;AAEA,WAAO,EAAE,OAAO,SAAS,OAAAA,OAAM;AAAA,EACjC;AAEA,WAAS,yBAAyB,OAA0C;AAC1E,QAAI,OAAO,UAAU,SAAU,QAAO;AACtC,UAAM,UAAU,MAAM,KAAK;AAC3B,QAAI,CAAC,QAAS,QAAO;AACrB,UAAM,QAAQ,QAAQ,YAAY;AAClC,QAAI,UAAU,SAAU,QAAO;AAC/B,QAAI,UAAU,SAAU,QAAO;AAC/B,QAAI,UAAU,UAAW,QAAO;AAChC,WAAO;AAAA,EACT;AAOO,WAAS,4BAA4B,OAAkD;AAC5F,UAAM,SAAS,OAAO,MAAM,eAAe,WAAW,MAAM,WAAW,KAAK,IAAI;AAChF,QAAI,CAAC,QAAQ;AACX,aAAO,EAAE,UAAU,MAAM,cAAc,MAAM;AAAA,IAC/C;AAEA,UAAM,aAA4C;AAAA,MAChD,MAAM;AAAA,MACN,MAAM;AAAA,MACN,yBAAyB,MAAM,SAAS;AAAA,IAC1C;AAEA,eAAW,QAAQ,YAAY;AAC7B,UAAI,OAAO,SAAS,SAAU;AAC9B,YAAM,UAAU,KAAK,KAAK;AAC1B,UAAI,QAAQ,WAAW,EAAG;AAC1B,aAAO,EAAE,UAAU,EAAE,QAAQ,OAAO,QAAQ,GAAG,cAAc,MAAM;AAAA,IACrE;AAEA,WAAO,EAAE,UAAU,EAAE,QAAQ,OAAO,UAAU,GAAG,cAAc,KAAK;AAAA,EACtE;AAEA,WAAS,aAAa,KAAwC;AAC5D,QAAI,OAAO,QAAQ,SAAU,QAAO;AACpC,UAAM,UAAU,IAAI,KAAK;AACzB,QAAI,CAAC,QAAS,QAAO;AACrB,WAAO,QAAQ,YAAY;AAAA,EAC7B;AAEA,MAAM,wBAAqD;AAAA,IACzD,MAAM;AAAA,IACN,UAAU;AAAA,IACV,WAAW;AAAA,IACX,OAAO;AAAA,IACP,WAAW;AAAA,IACX,OAAO;AAAA,IACP,YAAY;AAAA,IACZ,OAAO;AAAA,IACP,WAAW;AAAA,IACX,cAAc;AAAA,IACd,iBAAiB;AAAA,IACjB,qBAAqB;AAAA,EACvB;AAEA,MAAM,8BAAiE;AAAA,IACrE,MAAM;AAAA,IACN,WAAW;AAAA,IACX,eAAe;AAAA,IACf,kBAAkB;AAAA,IAClB,aAAa;AAAA,IACb,gBAAgB;AAAA,EAClB;AAKA,MAAM,oCAAiF;AAAA,IACrF,MAAM;AAAA,IACN,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,SAAS;AAAA,IACT,WAAW;AAAA,EACb;AAEA,MAAM,kCAA6E;AAAA,IACjF,KAAK;AAAA,IACL,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,QAAQ;AAAA,EACV;AAEA,WAAS,mBAAmB,KAA0C;AACpE,UAAM,MAAM,aAAa,GAAG;AAC5B,QAAI,CAAC,IAAK,QAAO;AACjB,WAAO,sBAAsB,GAAG,KAAK;AAAA,EACvC;AAEA,WAAS,yBAAyB,KAAgD;AAChF,UAAM,MAAM,aAAa,GAAG;AAC5B,QAAI,CAAC,IAAK,QAAO;AACjB,WAAO,4BAA4B,GAAG,KAAK;AAAA,EAC7C;AAEA,WAAS,8BAA8B,KAA0D;AAC/F,UAAM,MAAM,aAAa,GAAG;AAC5B,QAAI,CAAC,IAAK,QAAO;AACjB,WAAO,kCAAkC,GAAG,KAAK;AAAA,EACnD;AAEA,WAAS,4BAA4B,KAAwD;AAC3F,UAAM,MAAM,aAAa,GAAG;AAC5B,QAAI,CAAC,IAAK,QAAO;AACjB,WAAO,gCAAgC,GAAG,KAAK;AAAA,EACjD;AAGO,WAAS,gCACd,OACA,OACA,MACU;AACV,UAAM,WAAqB,CAAC;AAE5B,QAAI,QAAQ,KAAK,UAAU;AACzB,YAAM,WAAW,KAAK;AAAA,IACxB;AAEA,UAAM,WAAW,QAAQ,KAAK,QAAQ,KAAK,QAAQ;AAEnD,QAAI,MAAM,UAAU;AAClB,UAAI,MAAM,SAAS,SAAS,SAAS;AACnC,cAAM,WAAW,MAAM,SAAS;AAAA,MAClC,OAAO;AACL,iBAAS,KAAK,uBAAkB,MAAM,SAAS,IAAI,4CAAuC;AAAA,MAC5F;AAAA,IACF;AAEA,UAAM,gBAAgB,qCAAU;AAChC,UAAM,aAAa,EAAE,MAAM,OAAO;AAClC,QAAI,eAAe;AACjB,UAAI,cAAc,SAAS,QAAQ;AACjC,cAAM,aAAa,EAAE,MAAM,OAAO;AAAA,MACpC,YACG,cAAc,SAAS,YAAY,cAAc,SAAS,cAC3D,eAAe,cAAc,KAAK,GAClC;AACA,cAAM,aAAa,EAAE,MAAM,cAAc,MAAM,OAAO,cAAc,MAAM;AAAA,MAI5E;AAAA,IACF,WAAW,MAAM,YAAY;AAC3B,UAAI,MAAM,eAAe,QAAQ;AAC/B,cAAM,aAAa,EAAE,MAAM,OAAO;AAAA,MACpC,WAAW,MAAM,WAAW,SAAS,SAAS;AAC5C,cAAM,aAAa,EAAE,MAAM,UAAU,OAAO,MAAM,WAAW,MAAM;AAAA,MACrE,WAAW,MAAM,WAAW,SAAS,WAAW;AAC9C,cAAM,aAAa,EAAE,MAAM,WAAW,OAAO,MAAM,WAAW,MAAM;AAAA,MACtE,OAAO;AACL,iBAAS,KAAK,yBAAqB,MAAM,WAA8B,IAAI,0BAAqB;AAAA,MAClG;AAAA,IACF;AAEA,UAAM,mBAAmB,qCAAU;AACnC,UAAM,gBAAgB,EAAE,MAAM,WAAW,OAAO,EAAE;AAClD,QAAI,kBAAkB;AACpB,WACG,iBAAiB,SAAS,YAAY,iBAAiB,SAAS,cACjE,eAAe,iBAAiB,KAAK,GACrC;AACA,cAAM,gBAAgB,EAAE,MAAM,iBAAiB,MAAM,OAAO,iBAAiB,MAAM;AAAA,MACrF;AAAA,IACF,WAAW,MAAM,eAAe;AAC9B,UAAI,MAAM,cAAc,SAAS,SAAS;AACxC,cAAM,gBAAgB,EAAE,MAAM,UAAU,OAAO,MAAM,cAAc,MAAM;AAAA,MAC3E,WAAW,MAAM,cAAc,SAAS,WAAW;AACjD,cAAM,gBAAgB,EAAE,MAAM,WAAW,OAAO,MAAM,cAAc,MAAM;AAAA,MAC5E,OAAO;AACL,iBAAS,KAAK,4BAAuB,MAAM,cAAc,IAAI,0BAAqB;AAAA,MACpF;AAAA,IACF;AAEA,UAAM,mBAAmB;AACzB,QAAI,YAAY,eAAe,SAAS,gBAAgB,GAAG;AACzD,YAAM,mBAAmB,SAAS;AAAA,IACpC,WAAW,MAAM,kBAAkB;AACjC,UAAI,MAAM,iBAAiB,SAAS,SAAS;AAC3C,cAAM,mBAAmB,MAAM,iBAAiB;AAAA,MAClD,OAAO;AACL,iBAAS,KAAK,+BAA0B,MAAM,iBAAiB,IAAI,4CAAuC;AAAA,MAC5G;AAAA,IACF;AAEA,UAAM,kBAAkB;AACxB,QAAI,YAAY,eAAe,SAAS,eAAe,GAAG;AACxD,YAAM,kBAAkB,SAAS;AAAA,IACnC,WAAW,MAAM,iBAAiB;AAChC,UAAI,MAAM,gBAAgB,SAAS,SAAS;AAC1C,cAAM,kBAAkB,MAAM,gBAAgB;AAAA,MAChD,OAAO;AACL,iBAAS,KAAK,8BAAyB,MAAM,gBAAgB,IAAI,4CAAuC;AAAA,MAC1G;AAAA,IACF;AAEA,QAAI,YAAY,OAAO,SAAS,aAAa,UAAU;AACrD,UAAI;AAAE,cAAM,WAAW,SAAS;AAAA,MAAsB,SAAQ;AAAA,MAAe;AAAA,IAC/E,OAAO;AACL,YAAM,WAAW,mBAAmB,MAAM,QAAQ;AAClD,UAAI,UAAU;AACZ,cAAM,WAAW;AAAA,MACnB,OAAO;AACL,YAAI,MAAM,SAAU,UAAS,KAAK,kBAAa,MAAM,QAAQ,0CAAqC;AAClG,cAAM,WAAW;AAAA,MACnB;AAAA,IACF;AAEA,QAAI,YAAY,OAAO,SAAS,mBAAmB,UAAU;AAC3D,UAAI;AAAE,cAAM,iBAAiB,SAAS;AAAA,MAAkC,SAAQ;AAAA,MAAe;AAAA,IACjG,OAAO;AACL,YAAM,iBAAiB,yBAAyB,MAAM,cAAc;AACpE,UAAI,gBAAgB;AAClB,cAAM,iBAAiB;AAAA,MACzB,OAAO;AACL,YAAI,MAAM,eAAgB,UAAS,KAAK,wBAAmB,MAAM,cAAc,0CAAqC;AACpH,cAAM,iBAAiB;AAAA,MACzB;AAAA,IACF;AAEA,UAAM,WAAW;AACjB,UAAM,8BAA8B,OAAO,SAAS,wBAAwB;AAC5E,UAAM,yBAAyB,YAAY,OAAO,SAAS,wBAAwB,WAC9E,SAAS,sBACV;AACJ,QAAI,wBAAwB;AAC1B,UAAI,6BAA6B;AAC/B,YAAI;AAAE,mBAAS,sBAAsB;AAAA,QAAwB,SAAQ;AAAA,QAAe;AAAA,MACtF,OAAO;AACL,iBAAS,KAAK,gFAAgF;AAAA,MAChG;AAAA,IACF,OAAO;AACL,YAAM,sBAAsB,8BAA8B,MAAM,mBAAmB;AACnF,UAAI,qBAAqB;AACvB,YAAI,6BAA6B;AAC/B,cAAI;AAAE,qBAAS,sBAAsB;AAAA,UAAqB,SAAQ;AAAA,UAAe;AAAA,QACnF,OAAO;AACL,mBAAS,KAAK,gFAAgF;AAAA,QAChG;AAAA,MACF,WAAW,MAAM,qBAAqB;AACpC,iBAAS,KAAK,6BAAwB,MAAM,mBAAmB,0CAAqC;AAAA,MACtG,WAAW,6BAA6B;AACtC,YAAI;AAAE,mBAAS,sBAAsB;AAAA,QAAQ,SAAQ;AAAA,QAAe;AAAA,MACtE;AAAA,IACF;AAEA,UAAM,4BAA4B,OAAO,SAAS,sBAAsB;AACxE,UAAM,uBAAuB,YAAY,OAAO,SAAS,sBAAsB,WAC1E,SAAS,oBACV;AACJ,QAAI,sBAAsB;AACxB,UAAI,2BAA2B;AAC7B,YAAI;AAAE,mBAAS,oBAAoB;AAAA,QAAsB,SAAQ;AAAA,QAAe;AAAA,MAClF,OAAO;AACL,iBAAS,KAAK,8EAA8E;AAAA,MAC9F;AAAA,IACF,OAAO;AACL,YAAM,oBAAoB,4BAA4B,MAAM,iBAAiB;AAC7E,UAAI,mBAAmB;AACrB,YAAI,2BAA2B;AAC7B,cAAI;AAAE,qBAAS,oBAAoB;AAAA,UAAmB,SAAQ;AAAA,UAAe;AAAA,QAC/E,OAAO;AACL,mBAAS,KAAK,8EAA8E;AAAA,QAC9F;AAAA,MACF,WAAW,MAAM,mBAAmB;AAClC,iBAAS,KAAK,2BAAsB,MAAM,iBAAiB,0CAAqC;AAAA,MAClG,WAAW,2BAA2B;AACpC,YAAI;AAAE,mBAAS,oBAAoB;AAAA,QAAO,SAAQ;AAAA,QAAe;AAAA,MACnE;AAAA,IACF;AAEA,QAAI,UAAU;AACZ,UAAI,eAAe,SAAS,WAAW,KAAK,OAAO,SAAS,gBAAgB,aAAa;AACvF,YAAI;AAAE,mBAAS,cAAc,SAAS;AAAA,QAAa,SAAQ;AAAA,QAAe;AAAA,MAC5E;AACA,UAAI,OAAO,SAAS,uBAAuB,aAAa,OAAO,SAAS,uBAAuB,aAAa;AAC1G,YAAI;AAAE,mBAAS,qBAAqB,SAAS;AAAA,QAAoB,SAAQ;AAAA,QAAe;AAAA,MAC1F;AACA,UAAI,OAAO,SAAS,gBAAgB,aAAa,OAAO,SAAS,gBAAgB,aAAa;AAC5F,YAAI;AAAE,mBAAS,cAAc,SAAS;AAAA,QAAa,SAAQ;AAAA,QAAe;AAAA,MAC5E;AACA,UAAI,OAAO,SAAS,gBAAgB,eAAe,OAAO,SAAS,gBAAgB,aAAa;AAC9F,YAAI;AAAE,mBAAS,cAAc,SAAS;AAAA,QAAa,SAAQ;AAAA,QAAe;AAAA,MAC5E;AACA,UAAI,OAAO,SAAS,mBAAmB,YAAY,OAAO,SAAS,mBAAmB,aAAa;AACjG,YAAI;AAAE,mBAAS,iBAAiB,SAAS;AAAA,QAAgB,SAAQ;AAAA,QAAe;AAAA,MAClF;AACA,UAAI,OAAO,SAAS,UAAU,eAAe,OAAO,SAAS,UAAU,aAAa;AAClF,YAAI;AAAE,mBAAS,QAAQ,SAAS;AAAA,QAAO,SAAQ;AAAA,QAAe;AAAA,MAChE;AACA,UAAI,OAAO,SAAS,YAAY,eAAe,OAAO,SAAS,YAAY,aAAa;AACtF,YAAI;AAAE,mBAAS,UAAU,SAAS;AAAA,QAAS,SAAQ;AAAA,QAAe;AAAA,MACpE;AAAA,IACF;AAEA,WAAO;AAAA,EACT;;;ACxtBO,WAAS,yBAAyB,SAA6D;AACpG,UAAM,QAAQ,OAAO,OAAO,EAAE,YAAY;AAC1C,WAAO,MAAM,SAAS,YAAY,IAAI,eAAe;AAAA,EACvD;AAGA,MAAM,8BAA8B,oBAAI,IAAI,CAAC,QAAQ,YAAY,CAAU;AAMpE,WAAS,sBAAsB,OAA8C;AAClF,QAAI,CAAC,SAAS,OAAO,UAAU,UAAU;AACvC,aAAO,EAAE,IAAI,OAAO,QAAQ,gBAAgB;AAAA,IAC9C;AAEA,UAAM,KAAK,OAAO,MAAM,cAAc,EAAE,EAAE,YAAY;AACtD,QAAI,CAAC,4BAA4B,IAAI,EAAS,GAAG;AAC/C,aAAO,EAAE,IAAI,OAAO,QAAQ,iCAA4B,MAAM,UAAU,UAAK;AAAA,IAC/E;AAEA,QAAI,CAAC,MAAM,QAAQ,MAAM,UAAU,KAAK,MAAM,WAAW,WAAW,GAAG;AACrE,aAAO,EAAE,IAAI,OAAO,QAAQ,0CAA0C;AAAA,IACxE;AAGA,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,YAAM,IAAI,MAAM,WAAW,CAAC;AAC5B,UAAI,OAAO,MAAM,YAAY,CAAC,OAAO,SAAS,CAAC,GAAG;AAChD,eAAO,EAAE,IAAI,OAAO,QAAQ,aAAa,CAAC,0BAA0B;AAAA,MACtE;AACA,UAAI,IAAI,KAAK,IAAI,GAAG;AAClB,eAAO,EAAE,IAAI,OAAO,QAAQ,aAAa,CAAC,kBAAkB,CAAC,IAAI;AAAA,MACnE;AAAA,IACF;AAGA,QAAI,OAAO,MAAM,UAAU,aAAa;AACtC,UAAI,OAAO,MAAM,UAAU,YAAY,CAAC,OAAO,SAAS,MAAM,KAAK,GAAG;AACpE,eAAO,EAAE,IAAI,OAAO,QAAQ,+BAA+B;AAAA,MAC7D;AACA,UAAI,MAAM,QAAQ,KAAK,MAAM,QAAQ,GAAG;AACtC,eAAO,EAAE,IAAI,OAAO,QAAQ,uBAAuB,MAAM,KAAK,IAAI;AAAA,MACpE;AAAA,IACF;AAEA,WAAO,EAAE,IAAI,KAAK;AAAA,EACpB;AAMO,WAAS,oCACd,YACA,SACS;AACT,UAAM,KAAK,OAAO,UAAU,EAAE,YAAY;AAC1C,UAAM,aAAa,yBAAyB,OAAO;AACnD,QAAI,eAAe,aAAc,QAAO,OAAO,UAAU,OAAO;AAChE,WAAO,OAAO;AAAA,EAChB;AAEA,WAAS,QAAQ,GAAmB;AAClC,QAAI,IAAI,EAAG,QAAO;AAClB,QAAI,IAAI,EAAG,QAAO;AAClB,WAAO;AAAA,EACT;AACA,WAAS,aAAa,GAAuB;AAC3C,QAAI,MAAgB,CAAC;AACrB,QAAI,IAAI;AACR,SAAK,IAAI,GAAG,IAAI,EAAE,QAAQ,IAAK,KAAI,KAAK,QAAQ,EAAE,CAAC,CAAC,CAAC;AACrD,WAAO;AAAA,EACT;AAGA,WAAS,WAAW,QAAwB;AAC1C,QAAI,UAAU,SAAW,QAAO,QAAQ;AACxC,WAAO,QAAQ,KAAK,IAAI,QAAQ,IAAI,GAAG,IAAI;AAAA,EAC7C;AACA,WAAS,WAAW,SAAyB;AAC3C,QAAI,WAAW,QAAS,QAAO,UAAU;AACzC,WAAO,KAAK,KAAK,UAAU,SAAS,OAAO,GAAG;AAAA,EAChD;AACA,MAAI,WAAW;AACf,MAAI,WAAW;AAEf,WAAS,KAAK,GAAe,GAAuB;AAClD,WAAO;AAAA,MACL,EAAE,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC;AAAA,MAC/C,EAAE,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC;AAAA,MAC/C,EAAE,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC;AAAA,IACjD;AAAA,EACF;AAGA,MAAM,gBAAgB;AAAA,IACpB,CAAC,WAAW,WAAW,SAAS;AAAA,IAChC,CAAC,WAAW,WAAW,QAAS;AAAA,IAChC,CAAC,WAAW,UAAW,SAAS;AAAA,EAClC;AACA,MAAM,gBAAgB;AAAA,IACpB,CAAC,WAAW,YAAY,UAAU;AAAA,IAClC,CAAC,WAAY,WAAW,QAAS;AAAA,IACjC,CAAC,WAAW,YAAY,SAAS;AAAA,EACnC;AAEA,MAAM,cAAc;AAAA,IAClB,CAAC,oBAAoB,qBAAqB,kBAAkB;AAAA,IAC5D,CAAC,oBAAoB,oBAAoB,iBAAkB;AAAA,IAC3D,CAAC,GAAoB,qBAAqB,iBAAkB;AAAA,EAC9D;AACA,MAAM,cAAc;AAAA,IAClB,CAAC,mBAAmB,qBAAqB,oBAAoB;AAAA,IAC7D,CAAC,qBAAqB,oBAAoB,mBAAmB;AAAA,IAC7D,CAAC,qBAAqB,sBAAsB,kBAAkB;AAAA,EAChE;AAEA,WAAS,OAAO,OAA8B,WAA+B;AAC3E,QAAI,UAAU,aAAc,QAAO,CAAC,SAAS,UAAU,CAAC,CAAC,GAAG,SAAS,UAAU,CAAC,CAAC,GAAG,SAAS,UAAU,CAAC,CAAC,CAAC;AAC1G,WAAO,CAAC,WAAW,UAAU,CAAC,CAAC,GAAG,WAAW,UAAU,CAAC,CAAC,GAAG,WAAW,UAAU,CAAC,CAAC,CAAC;AAAA,EACtF;AACA,WAAS,OAAO,OAA8B,YAAgC;AAC5E,QAAI,UAAU,aAAc,QAAO,CAAC,SAAS,WAAW,CAAC,CAAC,GAAG,SAAS,WAAW,CAAC,CAAC,GAAG,SAAS,WAAW,CAAC,CAAC,CAAC;AAC7G,WAAO,CAAC,WAAW,WAAW,CAAC,CAAC,GAAG,WAAW,WAAW,CAAC,CAAC,GAAG,WAAW,WAAW,CAAC,CAAC,CAAC;AAAA,EACzF;AAEA,WAAS,gBAAgB,KAAe,KAA4B,KAAsC;AACxG,QAAI,QAAQ,IAAK,QAAO,aAAa,GAAG;AACxC,QAAI,MAAM,OAAO,KAAK,aAAa,GAAG,CAAC;AACvC,QAAI,MAAgB,QAAQ,SAAS,KAAK,eAAe,GAAG,IAAI,KAAK,aAAa,GAAG;AACrF,QAAI,SAAmB,QAAQ,SAAS,KAAK,eAAe,GAAG,IAAI,KAAK,aAAa,GAAG;AACxF,QAAI,MAAM,OAAO,KAAK,MAAM;AAC5B,WAAO,aAAa,GAAG;AAAA,EACzB;AAEA,WAAS,WAAW,KAAuB;AACzC,QAAI,IAAI,KAAK,MAAM,QAAQ,IAAI,CAAC,CAAC,IAAI,GAAG;AACxC,QAAI,IAAI,KAAK,MAAM,QAAQ,IAAI,CAAC,CAAC,IAAI,GAAG;AACxC,QAAI,IAAI,KAAK,MAAM,QAAQ,IAAI,CAAC,CAAC,IAAI,GAAG;AACxC,aAAS,IAAI,GAAmB;AAAE,UAAI,IAAI,EAAE,SAAS,EAAE;AAAG,aAAO,EAAE,WAAW,IAAI,MAAM,IAAI;AAAA,IAAG;AAC/F,WAAO,MAAM,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC;AAAA,EACtC;AACA,WAAS,WAAW,MAA8D;AAChF,QAAI,IAAI,KAAK,MAAM,QAAQ,KAAK,CAAC,IAAI,GAAG;AACxC,QAAI,IAAI,KAAK,MAAM,QAAQ,KAAK,CAAC,IAAI,GAAG;AACxC,QAAI,IAAI,KAAK,MAAM,QAAQ,KAAK,CAAC,IAAI,GAAG;AACxC,QAAI,IAAI,KAAK,MAAM,QAAQ,KAAK,CAAC,IAAI,GAAG;AACxC,aAAS,IAAI,GAAmB;AAAE,UAAI,IAAI,EAAE,SAAS,EAAE;AAAG,aAAO,EAAE,WAAW,IAAI,MAAM,IAAI;AAAA,IAAG;AAC/F,WAAO,MAAM,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC;AAAA,EAC/C;AAEA,WAAS,cAAc,MAAuB;AAC5C,QAAI,QAAQ,MAAM,QAAQ,GAAI,QAAO;AACrC,QAAI,QAAQ,MAAM,QAAQ,GAAI,QAAO;AACrC,QAAI,QAAQ,MAAM,QAAQ,IAAK,QAAO;AACtC,WAAO;AAAA,EACT;AACA,WAAS,cAAc,IAAY,IAAoB;AACrD,aAAS,IAAI,GAAmB;AAC9B,UAAI,KAAK,MAAM,KAAK,GAAI,QAAO,IAAI;AACnC,UAAI,KAAK,MAAM,KAAK,GAAI,QAAO,IAAI;AACnC,UAAI,KAAK,MAAM,KAAK,IAAK,QAAO,IAAI;AACpC,aAAO;AAAA,IACT;AACA,WAAQ,IAAI,EAAE,KAAK,IAAK,IAAI,EAAE;AAAA,EAChC;AAEO,WAAS,mBAAmB,KAA6D;AAC9F,QAAI,IAAI;AACR,QAAI,EAAE,SAAS,KAAK,EAAE,OAAO,CAAC,MAAM,IAAK,KAAI,EAAE,UAAU,CAAC;AAE1D,QAAI,IAAI;AACR,SAAK,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AAC7B,UAAI,CAAC,cAAc,EAAE,WAAW,CAAC,CAAC,EAAG,OAAM,IAAI,MAAM,wBAAwB,GAAG;AAAA,IAClF;AAEA,QAAI,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI;AAE7B,QAAI,EAAE,WAAW,KAAK,EAAE,WAAW,GAAG;AACpC,UAAI,OAAO,EAAE,WAAW,CAAC;AACzB,UAAI,OAAO,EAAE,WAAW,CAAC;AACzB,UAAI,OAAO,EAAE,WAAW,CAAC;AACzB,UAAI,OAAO,EAAE,WAAW,IAAI,EAAE,WAAW,CAAC,IAAI;AAC9C,UAAI,cAAc,MAAM,IAAI;AAC5B,UAAI,cAAc,MAAM,IAAI;AAC5B,UAAI,cAAc,MAAM,IAAI;AAC5B,UAAI,cAAc,MAAM,IAAI;AAAA,IAC9B,WAAW,EAAE,WAAW,KAAK,EAAE,WAAW,GAAG;AAC3C,UAAI,cAAc,EAAE,WAAW,CAAC,GAAG,EAAE,WAAW,CAAC,CAAC;AAClD,UAAI,cAAc,EAAE,WAAW,CAAC,GAAG,EAAE,WAAW,CAAC,CAAC;AAClD,UAAI,cAAc,EAAE,WAAW,CAAC,GAAG,EAAE,WAAW,CAAC,CAAC;AAClD,UAAI,EAAE,WAAW,EAAG,KAAI,cAAc,EAAE,WAAW,CAAC,GAAG,EAAE,WAAW,CAAC,CAAC;AAAA,IACxE,OAAO;AACL,YAAM,IAAI,MAAM,yBAAyB,GAAG;AAAA,IAC9C;AAEA,WAAO,EAAE,GAAG,QAAQ,IAAI,GAAG,GAAG,GAAG,QAAQ,IAAI,GAAG,GAAG,GAAG,QAAQ,IAAI,GAAG,GAAG,GAAG,QAAQ,IAAI,GAAG,EAAE;AAAA,EAC9F;AAEA,WAAS,qBAAqB,SAA0D;AACtF,WAAO,yBAAyB,OAAO,MAAM,eAAe,eAAe;AAAA,EAC7E;AAGO,WAAS,gBACd,OACA,YACgD;AAChD,QAAI,QAAQ,OAAO,MAAM,UAAU,WAAW,MAAM,QAAQ;AAC5D,QAAI,MAAM,qBAAqB,UAAU;AAEzC,QAAI,QAAQ,MAAM;AAClB,QAAI,SAAS,MAAM,UAAU,GAAG;AAC9B,UAAI,QAAQ,MAAM;AAClB,UAAI,UAAU,UAAU,UAAU,cAAc;AAC9C,YAAI,YAAY,gBAAgB,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,GAAG,OAAO,GAAG;AAC1E,eAAO,EAAE,GAAG,UAAU,CAAC,GAAG,GAAG,UAAU,CAAC,GAAG,GAAG,UAAU,CAAC,GAAG,GAAG,QAAQ,KAAK,EAAE;AAAA,MAChF;AACA,YAAM,IAAI,MAAM,6BAA6B,QAAQ,gCAAgC;AAAA,IACvF;AAEA,QAAI,MAAM,OAAO,OAAO,MAAM,QAAQ,UAAU;AAC9C,UAAI,UAAU,mBAAmB,MAAM,GAAG;AAC1C,UAAI,IAAI,OAAO,MAAM,UAAU,WAAW,QAAQ,MAAM,KAAK,IAAI,QAAQ;AACzE,UAAI,QAAQ,OAAQ,QAAO,EAAE,GAAG,QAAQ,GAAG,GAAG,QAAQ,GAAG,GAAG,QAAQ,GAAG,EAAK;AAC5E,UAAI,QAAQ,gBAAgB,CAAC,QAAQ,GAAG,QAAQ,GAAG,QAAQ,CAAC,GAAG,QAAQ,GAAG;AAC1E,aAAO,EAAE,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,EAAK;AAAA,IACvD;AAEA,UAAM,IAAI,MAAM,uCAAuC;AAAA,EACzD;AAGO,WAAS,gBACd,MACA,YACY;AACZ,QAAI,MAAM,qBAAqB,UAAU;AACzC,QAAI,MAAM,CAAC,QAAQ,KAAK,CAAC,GAAG,QAAQ,KAAK,CAAC,GAAG,QAAQ,KAAK,CAAC,CAAC;AAC5D,QAAI,IAAI,QAAQ,KAAK,CAAC;AAEtB,QAAI,aAAoC;AACxC,QAAI,aAAuC,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;AAElE,QAAI,UAAU,QAAQ,SAAS,MAAM,gBAAgB,KAAK,cAAc,MAAM;AAC9E,QAAI,MAAM,WAAW,OAAO;AAE5B,WAAO,EAAE,YAAwB,YAAwB,OAAO,GAAG,IAAS;AAAA,EAC9E;AAYO,WAAS,eAAe,KAAkD;AAC/E,WAAO,WAAW,CAAC,QAAQ,IAAI,CAAC,GAAG,QAAQ,IAAI,CAAC,GAAG,QAAQ,IAAI,CAAC,CAAC,CAAC;AAAA,EACpE;AAKO,WAAS,sBAAsB,OAA2B;AAC/D,UAAM,QAAQ,MAAM,QAAQ,MAAM,UAAU,IAAI,MAAM,aAAa,CAAC,GAAG,GAAG,CAAC;AAC3E,UAAM,OAAO,MAAM,eAAe,eAC9B,gBAAgB,OAAO,cAAc,MAAM,IAC3C,aAAa,KAAK;AAEtB,UAAM,UAAU,OAAO,MAAM,QAAQ,YAAY,MAAM,IAAI,SAAS,IAC/D,MAAM,IAAI,OAAO,CAAC,MAAM,MAAM,MAAM,MAAO,MAAM,MAAM,MACxD,WAAW,IAAI;AAEnB,QAAI,OAAO,MAAM,UAAU,UAAU;AACnC,YAAM,QAAQ,QAAQ,MAAM,KAAK;AACjC,UAAI,QAAQ,GAAG;AACb,eAAO,WAAW,EAAE,GAAG,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,GAAG,GAAG,MAAM,CAAC;AAAA,MACpE;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AACO,WAAS,eAAe,KAAyB;AACtD,QAAI,OAAO,mBAAmB,GAAG;AACjC,QAAI,QAAkC,CAAC,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAC7D,WAAO,EAAE,YAAY,QAAQ,YAAY,OAAO,OAAO,KAAK,GAAG,KAAK,eAAe,EAAE,GAAG,KAAK,GAAG,GAAG,KAAK,GAAG,GAAG,KAAK,EAAE,CAAC,EAAE;AAAA,EAC1H;AAUO,WAAS,4BAA4B,GAK1C;AACA,QAAI,CAAC,KAAK,OAAO,MAAM,SAAU,QAAO;AACxC,UAAM,IAAI;AACV,QAAI,CAAC,MAAM,QAAQ,EAAE,UAAU,KAAK,EAAE,WAAW,SAAS,EAAG,QAAO;AACpE,QAAI,OAAO,EAAE,WAAW,CAAC,MAAM,YAC7B,OAAO,EAAE,WAAW,CAAC,MAAM,YAC3B,OAAO,EAAE,WAAW,CAAC,MAAM,SAAU,QAAO;AAC9C,WAAO;AAAA,EACT;AAQO,WAAS,wBAAwB,OAKzB;AACb,aAASC,SAAQ,GAAmB;AAClC,UAAI,CAAC,OAAO,SAAS,CAAC,EAAG,QAAO;AAChC,UAAI,IAAI,EAAG,QAAO;AAClB,UAAI,IAAI,EAAG,QAAO;AAClB,aAAO;AAAA,IACT;AACA,UAAM,QAAQ;AAAA,MACZA,SAAQ,OAAO,MAAM,WAAW,CAAC,CAAC,CAAC;AAAA,MACnCA,SAAQ,OAAO,MAAM,WAAW,CAAC,CAAC,CAAC;AAAA,MACnCA,SAAQ,OAAO,MAAM,WAAW,CAAC,CAAC,CAAC;AAAA,IACrC;AAEA,UAAM,QACJ,OAAO,MAAM,UAAU,WAAWA,SAAQ,MAAM,KAAK,IAAI;AAG3D,UAAM,KAAK,MAAM,eAAe,eAAe,eAAe;AAE9D,WAAO;AAAA,MACL,YAAY;AAAA,MACZ,YAAY;AAAA,OACR,UAAU,SAAY,EAAE,MAAM,IAAI,CAAC,IACnC,OAAO,MAAM,QAAQ,WAAW,EAAE,KAAK,MAAM,IAAI,IAAI,CAAC;AAAA,EAE9D;;;AC5VA,WAAS,aAAa,KAAsB;AAjB5C;AAkBE,QAAI;AACF,UAAI,OAAO,UAAU,iBAAe,WAAM,OAAN,mBAAU,cAAa;AACzD,cAAM,GAAG,YAAY,EAAE,MAAM,QAAQ,SAAS,EAAE,SAAS,IAAI,EAAE,CAAC;AAChE,eAAO;AAAA,MACT;AAAA,IACF,SAAQ;AAAA,IAAe;AACvB,WAAO;AAAA,EACT;AAEA,WAAS,QAAQ,KAAa;AA3B9B;AA4BE,QAAI,aAAa,GAAG,EAAG;AACvB,QAAI;AAAE,6BAAW,YAAX,mBAAoB,QAApB,4BAA0B;AAAA,IAAM,SAAQ;AAAA,IAAe;AAAA,EAC/D;AAEA,WAAS,QAAQ,KAAa;AAhC9B;AAiCE,UAAM,UAAU,cAAc;AAC9B,QAAI,aAAa,OAAO,EAAG;AAC3B,QAAI;AAAE,6BAAW,YAAX,mBAAoB,SAApB,4BAA2B;AAAA,IAAU,SACrC;AACJ,UAAI;AAAE,+BAAW,YAAX,mBAAoB,QAApB,4BAA0B;AAAA,MAAU,SAAQC,IAAA;AAAA,MAAe;AAAA,IACnE;AAAA,EACF;AAIA,WAAS,OAAO,GAAY,GAAoB;AAC9C,WAAO,CAAC,CAAC,KAAK,OAAO,MAAM,YAAY,OAAO,UAAU,eAAe,KAAK,GAAG,CAAC;AAAA,EAClF;AAGA,WAAS,cAAc,GAAyB;AAC9C,WAAO,OAAO,MAAM,YAAY,EAAE,WAAW,GAAG,KAAK,EAAE,SAAS,GAAG,KAAK,EAAE,SAAS;AAAA,EACrF;AAGA,WAAS,qBAAqB,GAAqB;AAEjD,WAAO,EAAE,MAAM,GAAG,EAAE,EAAE,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC;AAAA,EACpD;AAGA,WAAS,kBAAkB,GAAyB;AAClD,WAAO,OAAO,MAAM,YACf,wDAAwD,KAAK,EAAE,KAAK,CAAC;AAAA,EAC5E;AAGA,WAAS,gBAAgB,KAAkC;AACzD,QAAI,CAAC,OAAO,OAAO,QAAQ,SAAU,QAAO;AAC5C,UAAM,IAAK,IAAY,cAAc;AACrC,QAAI,OAAO,MAAM,UAAU;AACzB,YAAM,IAAI,EAAE,KAAK;AACjB,UAAI,EAAE,SAAS,EAAG,QAAO;AAAA,IAC3B;AACA,WAAO;AAAA,EACT;AAUA,WAAS,uBACP,KACA,iBACgD;AAEhD,QAAI,OAAO,QAAQ,UAAU;AAC3B,UAAI,CAAC,gBAAiB,QAAO;AAC7B,UAAI,CAAC,kBAAkB,GAAG,EAAG,QAAO;AACpC,UAAI;AACF,eAAO,EAAE,OAAO,eAAe,GAAG,GAAG,gBAAgB,KAAK;AAAA,MAC5D,SAAQ;AACN,eAAO;AAAA,MACT;AAAA,IACF;AAGA,QAAI,OAAO,OAAO,QAAQ,UAAU;AAClC,YAAM,MAAM;AACZ,YAAM,YAAiB,gEAEjB,OAAO,IAAI,eAAe,WAAW,EAAE,YAAY,IAAI,WAAW,IAAI,CAAC,IACvE,MAAM,QAAQ,IAAI,UAAU,IAAI,EAAE,YAAY,IAAI,WAAW,MAAM,GAAG,CAAC,EAAE,IAAI,CAAC,IAE7E,WAAW,MAAO,EAAE,OAAO,IAAI,MAAM,IAAI,CAAC,IAC3C,OAAO,IAAI,QAAQ,WAAW,EAAE,KAAK,IAAI,IAAI,IAAI,CAAC;AAGxD,YAAM,QAAQ,sBAAsB,SAAS;AAC7C,UAAI,CAAC,MAAM,GAAI,QAAO;AACtB,aAAO,EAAE,OAAO,WAAW,gBAAgB,MAAM;AAAA,IACnD;AAEA,WAAO;AAAA,EACT;AAQA,WAAS,kBAAkB,MAAgB,KAAiD;AA5H5F;AA6HE,UAAM,SAAS,KAAK,MAAM;AAC1B,QAAI,OAAO;AACX,UAAM,MAAM,OAAO,KAAK,aAAa,IAAK,IAAY,aAAa,IAA+B;AAClG,UAAM,KAAK,OAAO,OAAO,QAAQ,WAAY,IAAY,WAAW,IAAI;AACxE,QAAI,MAAM,OAAO,OAAO,YAAY,OAAQ,GAAW,aAAa,UAAU;AAC5E,aAAQ,GAAW;AAAA,IACrB;AACA,UAAM,cAAa,YAAO,CAAC,MAAR,YAAa;AAChC,WAAO,EAAE,QAAQ,KAAK,GAAG,UAAU,IAAI,IAAI,GAAG;AAAA,EAChD;AAOO,WAAS,aAAa,MAAe,OAA0B,CAAC,GAAe;AACpF,UAAM,kBAAkB,CAAC,CAAC,KAAK;AAC/B,UAAM,SAAsB,CAAC;AAC7B,UAAM,eAAe,oBAAI,IAAuB;AAChD,UAAM,cAA+E,CAAC;AAEtF,aAAS,cAAc,OAAwB;AAC7C,aAAO,KAAK,KAAK;AACjB,mBAAa,IAAI,MAAM,KAAK,KAAK,GAAG,GAAG,KAAK;AAAA,IAC9C;AAEA,aAAS,MAAM,KAAc,MAAgB,eAA2C;AACtF,UAAI,CAAC,OAAO,OAAO,QAAQ,SAAU;AAGrC,UAAI,YAAkC;AACtC,UAAI,OAAO,KAAK,OAAO,KAAK,OAAQ,IAAY,UAAU,UAAU;AAClE,cAAM,IAAI,OAAQ,IAAY,KAAK;AACnC,YAAI,MAAM,WAAW,MAAM,YAAY,MAAM,YAAY,MAAM,aAAa,MAAM,cAAc;AAC9F,sBAAY;AAAA,QACd;AAAA,MACF;AAGA,UAAI,OAAO,KAAK,QAAQ,GAAG;AACzB,cAAM,SAAU,IAAY;AAG5B,cAAM,OAAO,gBAAgB,GAAG;AAIhC,YAAI,cAAc,MAAM,GAAG;AACzB,gBAAM,OAAO,qBAAqB,MAAM;AACxC,gBAAM,EAAE,QAAAC,SAAQ,KAAAC,KAAI,IAAI,kBAAkB,MAAM,GAAG;AACnD,gBAAMC,SAAuC,CAAC;AAC9C,UAAAA,OAAMD,IAAG,IAAI,EAAE,MAAM,SAAS,MAAM,KAAK;AAEzC,gBAAM,QAAmB;AAAA,YACvB,MAAMD;AAAA,YACN,MAAM,gCAAa;AAAA,YACnB,WAAWE;AAAA,aACP,OAAO,EAAE,aAAa,KAAK,IAAI,CAAC,IAChC,OAAO,KAAK,aAAa,IAAI,EAAE,YAAa,IAAY,aAAa,EAA6B,IAAI,CAAC;AAE7G,wBAAc,KAAK;AACnB,sBAAY,KAAK,EAAE,OAAO,cAAc,gCAAa,KAAK,CAAC;AAC3D;AAAA,QACF;AAGA,YAAI,cAAc,SAAS;AACzB,gBAAM,EAAE,QAAAF,SAAQ,KAAAC,KAAI,IAAI,kBAAkB,MAAM,GAAG;AACnD,gBAAM,SAAS,uBAAuB,QAAQ,eAAe;AAE7D,cAAI,CAAC,QAAQ;AACX,gBAAI,OAAO,WAAW,UAAU;AAC9B,kBAAI,iBAAiB;AACnB,wBAAQ,mCAA8BD,QAAO,KAAK,GAAG,CAAC,0HAAgH;AAAA,cACxK,OAAO;AACL,wBAAQ,mCAA8BA,QAAO,KAAK,GAAG,CAAC,gKAAsJ;AAAA,cAC9M;AAAA,YACF,OAAO;AACL,sBAAQ,mCAA8BA,QAAO,KAAK,GAAG,CAAC,4GAAkG;AAAA,YAC1J;AACA;AAAA,UACF;AAEF,cAAI,OAAO,gBAAgB;AACzB,oBAAQ,qDAAgDA,QAAO,KAAK,GAAG,CAAC,SAAI;AAAA,UAC9E;AAEE,gBAAME,SAAuC,CAAC;AAC9C,UAAAA,OAAMD,IAAG,IAAI,EAAE,MAAM,SAAS,OAAO,OAAO,MAAM;AAElD,wBAAc;AAAA,YACZ,MAAMD;AAAA,YACN,MAAM;AAAA,YACN,WAAWE;AAAA,aACP,OAAO,EAAE,aAAa,KAAK,IAAI,CAAC,IAChC,OAAO,KAAK,aAAa,IAAI,EAAE,YAAa,IAAY,aAAa,EAA6B,IAAI,CAAC,EAC5G;AACD;AAAA,QACF;AAGA,cAAM,eAAe;AACrB,YAAI,CAAC,cAAc;AACjB,kBAAQ,uBAAkB,KAAK,KAAK,GAAG,CAAC,yDAA+C;AACvF;AAAA,QACF;AAEA,YAAI,gBAA+B;AACnC,YAAI,SAA8B;AAElC,YAAI,iBAAiB,YAAY,OAAO,WAAW,UAAU;AAC3D,mBAAS,EAAE,MAAM,UAAU,OAAO,OAAO;AAAA,QAC3C,WAAW,iBAAiB,aAAa,OAAO,WAAW,WAAW;AACpE,mBAAS,EAAE,MAAM,WAAW,OAAO,OAAO;AAAA,QAC5C,WAAW,iBAAiB,YAAY,OAAO,WAAW,UAAU;AAClE,mBAAS,EAAE,MAAM,UAAU,OAAO,OAAO;AAAA,QAC3C;AAIA,YAAI,CAAC,UAAW,iBAAiB,YAAa,OAAO,WAAW,UAAU;AACxE,gBAAM,MAAM,OAAO,KAAK,aAAa,IAAK,IAAY,aAAa,IAA+B;AAClG,gBAAM,MAAM,OAAO,OAAO,QAAQ,WAAY,IAAY,WAAW,IAAI;AACzE,gBAAM,UAAU,OAAO,OAAO,QAAQ,WAAY,IAAY,cAAc,IAAI;AAChF,cAAI,YAAY,WAAW;AACzB,kBAAM,MAAM,OAAO,KAAK,EAAE,YAAY;AACtC,gBAAI,QAAQ,UAAU,QAAQ,SAAS;AACrC,uBAAS,EAAE,MAAM,WAAW,OAAQ,QAAQ,OAAQ;AAEpD,sBAAQ,8BAAyB,MAAM,gFAAsE,KAAK,KAAK,GAAG,CAAC,SAAI;AAC/H,8BAAgB;AAAA,YAClB;AAAA,UACF;AAAA,QACF;AAEA,YAAI,CAAC,UAAU,iBAAiB,cAAc;AAC5C,gBAAM,mBAAmB,qBAAqB,MAAM;AACpD,cAAI,CAAC,kBAAkB;AACrB,oBAAQ,uBAAkB,KAAK,KAAK,GAAG,CAAC,mDAAyC;AACjF;AAAA,UACF;AAEA,gBAAM,EAAE,QAAAF,SAAQ,KAAAC,KAAI,IAAI,kBAAkB,MAAM,GAAG;AACnD,gBAAMC,SAAuC,CAAC;AAC9C,UAAAA,OAAMD,IAAG,IAAI,EAAE,MAAM,cAAc,OAAO,iBAAiB;AAE3D,wBAAc;AAAA,YACZ,MAAMD;AAAA,YACN,MAAM;AAAA,YACN,WAAWE;AAAA,aACP,OAAO,EAAE,aAAa,KAAK,IAAI,CAAC,IAChC,OAAO,KAAK,aAAa,IAAI,EAAE,YAAa,IAAY,aAAa,EAA6B,IAAI,CAAC,EAC5G;AACD;AAAA,QACF;AAEA,YAAI,CAAC,QAAQ;AACX,gBAAM,WAAW,OAAO;AACxB,kBAAQ,uBAAkB,KAAK,KAAK,GAAG,CAAC,gCAAsB,YAAY,cAAc,QAAQ,GAAG;AACnG;AAAA,QACF;AAEA,cAAM,EAAE,QAAQ,IAAI,IAAI,kBAAkB,MAAM,GAAG;AACnD,cAAM,QAAuC,CAAC;AAC9C,cAAM,GAAG,IAAI;AAEb,sBAAc;AAAA,UACZ,MAAM;AAAA,UACN,MAAM;AAAA,UACN,WAAW;AAAA,WACP,OAAO,EAAE,aAAa,KAAK,IAAI,CAAC,IAChC,OAAO,KAAK,aAAa,IAAI,EAAE,YAAa,IAAY,aAAa,EAA6B,IAAI,CAAC,EAC5G;AACD;AAAA,MACF;AAGA,iBAAW,KAAK,KAAgC;AAC9C,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,KAAK,CAAC,EAAG;AACnD,YAAI,EAAE,WAAW,GAAG,EAAG;AACvB,cAAM,QAAS,IAAgC,CAAC;AAChD,cAAM,UAAU,KAAK,OAAO,CAAC,CAAC,CAAC;AAC/B,cAAM,OAAO,SAAS,SAAS;AAAA,MACjC;AAAA,IACF;AAEA,UAAM,MAAM,CAAC,GAAG,IAAI;AAEpB,UAAM,gBAAgB,IAAI,IAAI,YAAY,IAAI,OAAK,EAAE,KAAK,CAAC;AAC3D,UAAM,oBAAoB,oBAAI,IAAkC;AAChE,UAAM,gBAAgB,oBAAI,IAAe;AAEzC,aAAS,mBAAmB,UAAoB,OAA0C;AACxF,YAAM,MAAM,SAAS,KAAK,GAAG;AAC7B,UAAI,kBAAkB,IAAI,GAAG,EAAG,QAAO,kBAAkB,IAAI,GAAG;AAChE,UAAI,MAAM,IAAI,GAAG,GAAG;AAClB,0BAAkB,IAAI,KAAK,IAAI;AAC/B,eAAO;AAAA,MACT;AAEA,YAAM,SAAS,aAAa,IAAI,GAAG;AACnC,UAAI,CAAC,QAAQ;AACX,0BAAkB,IAAI,KAAK,IAAI;AAC/B,eAAO;AAAA,MACT;AAEA,UAAI,CAAC,cAAc,IAAI,MAAM,GAAG;AAC9B,0BAAkB,IAAI,KAAK,OAAO,IAAI;AACtC,eAAO,OAAO;AAAA,MAChB;AAEA,YAAM,IAAI,GAAG;AACb,UAAI,WAAiC;AACrC,YAAM,YAAY,OAAO,OAAO,OAAO,SAAS;AAChD,iBAAW,UAAU,WAAW;AAC9B,YAAI,CAAC,UAAU,OAAO,SAAS,SAAS;AACtC,qBAAW;AACX;AAAA,QACF;AACA,cAAM,SAAS,mBAAmB,OAAO,MAAM,KAAK;AACpD,YAAI,CAAC,QAAQ;AACX,qBAAW;AACX;AAAA,QACF;AACA,YAAI,CAAC,SAAU,YAAW;AAAA,iBACjB,aAAa,QAAQ;AAC5B,qBAAW;AACX;AAAA,QACF;AAAA,MACF;AACA,YAAM,OAAO,GAAG;AAChB,wBAAkB,IAAI,KAAK,QAAQ;AACnC,aAAO;AAAA,IACT;AAEA,eAAW,EAAE,OAAO,aAAa,KAAK,aAAa;AACjD,YAAM,WAAW,MAAM,KAAK,KAAK,GAAG;AACpC,UAAI,eAAqC;AACzC,UAAI,aAAa;AAEjB,iBAAW,UAAU,OAAO,OAAO,MAAM,SAAS,GAAG;AACnD,YAAI,CAAC,UAAU,OAAO,SAAS,SAAS;AACtC,uBAAa;AACb;AAAA,QACF;AACA,cAAM,QAAQ,oBAAI,IAAY,CAAC,QAAQ,CAAC;AACxC,cAAM,aAAa,mBAAmB,OAAO,MAAM,KAAK;AACxD,YAAI,CAAC,YAAY;AACf,uBAAa;AACb;AAAA,QACF;AACA,YAAI,CAAC,aAAc,gBAAe;AAAA,iBACzB,iBAAiB,YAAY;AACpC,uBAAa;AACb;AAAA,QACF;AAAA,MACF;AAEA,UAAI,CAAC,gBAAgB,YAAY;AAC/B,gBAAQ,uBAAkB,MAAM,KAAK,KAAK,GAAG,CAAC,6CAAmC;AACjF,sBAAc,IAAI,KAAK;AACvB;AAAA,MACF;AAEA,UAAI,gBAAgB,iBAAiB,cAAc;AACjD,gBAAQ,eAAU,MAAM,KAAK,KAAK,GAAG,CAAC,yBAAoB,YAAY,oBAAoB,YAAY,wBAAwB;AAAA,MAChI;AAEA,YAAM,OAAO;AACb,mBAAa,IAAI,UAAU,KAAK;AAAA,IAClC;AAEA,UAAM,cAAc,OAAO,OAAO,OAAK,CAAC,cAAc,IAAI,CAAC,CAAC;AAC5D,WAAO,EAAE,QAAQ,YAAY;AAAA,EAC/B;;;ACpYA,WAAS,OAAO,MAAwB;AACtC,WAAO,KAAK,KAAK,GAAG;AAAA,EACtB;AAGA,WAAS,aAAa,GAAmB;AACvC,WAAO,EACJ,KAAK,EACL,QAAQ,QAAQ,GAAG,EACnB,QAAQ,OAAO,GAAG,EAClB,YAAY;AAAA,EACjB;AAQA,WAAS,qBAAqB,GAAc,KAA4B;AA/BxE;AAgCE,UAAM,SAAU,EAAE,cAAc,OAAO,EAAE,eAAe,YACnD,OAAE,WAAmB,WAAW,MAAhC,YAAsC,EAAE,WAAmB,WAAW,IACvE;AAGJ,QAAI,aAAc,UAAU,OAAQ,OAAe,mBAAmB,WACjE,OAAe,iBAChB;AAEJ,QAAI,WAAY,UAAU,OAAQ,OAAe,iBAAiB,WAC7D,OAAe,eAChB;AAGJ,QAAI,OAAO,UAAU,OAAO,WAAW,YAAY,OAAQ,OAAe,eAAe,UAAU;AACjG,YAAM,WAAY,OAAe,WAAW,GAAG;AAC/C,UAAI,YAAY,OAAO,aAAa,UAAU;AAC5C,YAAI,OAAQ,SAAiB,mBAAmB,SAAU,cAAc,SAAiB;AACzF,YAAI,OAAQ,SAAiB,iBAAiB,SAAU,YAAY,SAAiB;AAAA,MACvF;AAAA,IACF;AAGA,QAAI,CAAC,WAAY,cAAa,EAAE,KAAK,CAAC;AACtC,QAAI,CAAC,SAAU,YAAW,EAAE,KAAK,MAAM,CAAC,EAAE,KAAK,GAAG;AAElD,WAAO,EAAE,YAAY,SAAS;AAAA,EAChC;AAIA,WAAS,sBAAsB,OAA8C;AAC3E,UAAM,QAAQ,oBAAI,IAA0B;AAE5C,eAAW,KAAK,MAAM,QAAQ;AAC5B,YAAM,UAAU,OAAO,EAAE,SAAS;AAClC,YAAM,YAAY,QAAQ,SAAS,IAAI,QAAQ,CAAC,IAAI;AAEpD,YAAM,EAAE,YAAY,SAAS,IAAI,qBAAqB,GAAG,SAAS;AAClE,YAAM,QAAsB,EAAE,YAAY,SAAS;AAGnD,YAAM,IAAI,OAAO,EAAE,IAAI,GAAG,KAAK;AAG/B,YAAM,cAAc,CAAC,YAAY,GAAG,OAAO,QAAQ,EAAE,MAAM,GAAG,CAAC;AAC/D,YAAM,IAAI,OAAO,WAAW,GAAG,KAAK;AAGpC,YAAM,WAAW,CAAC,aAAa,UAAU,GAAG,GAAG,OAAO,QAAQ,EAAE,MAAM,GAAG,EAAE,IAAI,CAAC,MAAc,aAAa,CAAC,CAAC,CAAC;AAC9G,YAAM,IAAI,OAAO,QAAQ,GAAG,KAAK;AAAA,IACnC;AAEA,WAAO;AAAA,EACT;AASO,WAAS,UAAU,OAAmB,MAA0C;AACrF,UAAM,OAAiC,CAAC;AACxC,UAAM,eAAe,sBAAsB,KAAK;AAEhD,eAAW,KAAK,MAAM,QAAQ;AAC5B,qBAAe,MAAM,GAAG,cAAc,IAAI;AAAA,IAC5C;AAEA,WAAO,EAAE,MAAM,KAAK;AAAA,EACtB;AAKA,WAAS,eACP,MACA,GACA,cACA,MACM;AAlHR;AAoHE,UAAM,UAAU,OAAO,EAAE,SAAS;AAClC,UAAM,YAAY,QAAQ,SAAS,IAAI,QAAQ,CAAC,IAAI;AAEpD,UAAM,SACJ,cAAc,UAAa,OAAE,UAAU,SAAS,MAArB,YAAuD,OAAO;AAK3F,UAAM,OAAO,MAAM,QAAQ,EAAE,IAAI,IAAI,EAAE,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC;AAC7D,UAAM,iBAAgB,UAAK,CAAC,MAAN,YAAW;AACjC,UAAM,eAAe,KAAK,MAAM,CAAC;AAGjC,UAAM,UAAU,CAAC,EAAE,QAAQ,KAAK;AAChC,UAAM,gBAAgB,UAClB,aAAa,MAAM,GAAG,EAAE,IACxB,CAAC,eAAe,GAAG,aAAa,MAAM,GAAG,EAAE,CAAC;AAChD,UAAM,OAAO,aAAa,SACtB,aAAa,aAAa,SAAS,CAAC,KACnC,UAAK,KAAK,SAAS,CAAC,MAApB,YAAyB;AAM9B,QAAI,MAAM;AACV,aAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC7C,YAAM,MAAM,cAAc,CAAC;AAC3B,UAAI,OAAO,IAAI,GAAG;AAClB,UAAI,CAAC,QAAQ,OAAO,SAAS,UAAU;AACrC,eAAO,CAAC;AACR,YAAI,GAAG,IAAI;AAAA,MACb;AACA,YAAM;AAAA,IACR;AAGA,UAAM,WAAqC,CAAC;AAE5C,UAAM,cAAe,EAAE,SAAS,YAAa,WAAW,EAAE;AAC1D,aAAS,OAAO,IAAI;AAGpB,QAAI,WAAW,MAAM;AACnB,cAAQ,OAAO,MAAM;AAAA,QACnB,KAAK,SAAS;AAEZ,gBAAM,SAAmB,MAAM,QAAS,OAAe,IAAI,IACrD,OAAe,KAAkB,MAAM,IACzC,OAAQ,OAAe,IAAI,EAAE,MAAM,GAAG,EAAE,IAAI,CAAC,MAAc,EAAE,KAAK,CAAC,EAAE,OAAO,OAAO;AAEvF,cAAI,UAAU,aAAa,IAAI,OAAO,MAAM,CAAC;AAC7C,cAAI,CAAC,SAAS;AAEZ,sBAAU,aAAa,IAAI,OAAO,OAAO,IAAI,CAAC,MAAc,aAAa,CAAC,CAAC,CAAC,CAAC;AAAA,UAC/E;AAEA,cAAI,CAAC,WAAW,OAAO,SAAS,GAAG;AAEjC,kBAAM,YAAY,aAAa,OAAO,CAAC,CAAC;AACxC,uBAAW,CAAC,CAAC,KAAK,aAAa,QAAQ,GAAG;AACxC,oBAAM,QAAQ,EAAE,MAAM,GAAG;AACzB,kBAAI,MAAM,WAAW,EAAG;AACxB,kBAAI,aAAa,MAAM,CAAC,CAAC,MAAM,WAAW;AACxC,sBAAM,QAAQ,CAAC,MAAM,CAAC,GAAG,GAAG,OAAO,MAAM,CAAC,CAAC;AAC3C,sBAAM,QAAQ,CAAC,MAAM,CAAC,GAAG,GAAG,OAAO,MAAM,CAAC,EAAE,IAAI,CAAC,MAAc,aAAa,CAAC,CAAC,CAAC;AAC/E,0BAAU,aAAa,IAAI,OAAO,KAAK,CAAC,KAAK,aAAa,IAAI,OAAO,KAAK,CAAC;AAC3E,oBAAI,QAAS;AAAA,cACf;AAAA,YACF;AAAA,UACF;AAEA,mBAAS,QAAQ,IAAI,UACjB,IAAI,CAAC,QAAQ,YAAY,GAAG,OAAO,QAAQ,QAAQ,EAAE,MAAM,GAAG,CAAC,EAAE,KAAK,GAAG,CAAC,MAC1E,IAAI,OAAO,KAAK,GAAG,CAAC;AACxB;AAAA,QACF;AAAA,QAEA,KAAK,SAAS;AACZ,gBAAM,KAAK,OAAO;AAClB,cAAI,QAAQ,KAAK,iBAAiB;AAChC,qBAAS,QAAQ,IAAI,sBAAsB,EAAE;AAAA,UAC/C,OAAO;AACL,kBAAM,MAAgC;AAAA,cACpC,YAAY,GAAG;AAAA,cACf,YAAY,CAAC,GAAG,WAAW,CAAC,GAAG,GAAG,WAAW,CAAC,GAAG,GAAG,WAAW,CAAC,CAAC;AAAA,YACnE;AACA,gBAAI,OAAO,GAAG,UAAU,SAAU,KAAI,OAAO,IAAI,GAAG;AACpD,gBAAI,OAAO,GAAG,QAAQ,SAAU,KAAI,KAAK,IAAI,GAAG;AAChD,qBAAS,QAAQ,IAAI;AAAA,UACvB;AACA;AAAA,QACF;AAAA,QAEA,KAAK;AAAA,QACL,KAAK,UAAU;AACb,mBAAS,QAAQ,IAAI,OAAO;AAC5B;AAAA,QACF;AAAA,QAEA,KAAK,WAAW;AAEd,mBAAS,QAAQ,IAAI,OAAO,QAAQ,SAAS;AAC7C;AAAA,QACF;AAAA,QAEA,KAAK,cAAc;AACjB,mBAAS,QAAQ,IAAI,yBAAyB,OAAO,KAAK;AAC1D;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAGA,QAAI,OAAO,EAAE,gBAAgB,YAAY,EAAE,YAAY,KAAK,MAAM,IAAI;AACpE,eAAS,cAAc,IAAI,EAAE;AAAA,IAC/B;AAGA,QAAI;AACJ,QAAI,EAAE,YAAY;AAChB,YAAM,YAAY,6BAA6B,EAAE,YAAuC,SAAS;AACjG,eAAU,gCAAc,EAAE;AAAA,IAC5B;AAGA,QAAI,EAAE,SAAS,WAAW;AACxB,UAAI,CAAC,OAAQ,UAAS,CAAC;AACvB,YAAM,MAAO,OAAO,WAAW,KAAK,OAAQ,OAAO,WAAW,MAAO,WAChE,OAAO,WAAW,IAClB,OAAO,WAAW,IAAI,CAAC;AAC5B,UAAI,IAAI,cAAc,MAAM,UAAW,KAAI,cAAc,IAAI;AAAA,IAC/D;AAEA,QAAI,OAAQ,UAAS,aAAa,IAAI;AAGtC,IAAC,IAAY,IAAI,IAAI;AAAA,EACvB;AAQA,WAAS,6BACP,KACA,KACgC;AAChC,QAAI,CAAC,OAAO,OAAO,QAAQ,SAAU,QAAO;AAE5C,UAAM,MAA+B,CAAC;AAGtC,eAAW,KAAK,KAAK;AACnB,UAAI,CAAC,OAAO,UAAU,eAAe,KAAK,KAAK,CAAC,EAAG;AACnD,UAAI,MAAM,eAAe,MAAM,aAAa;AAC1C,YAAI,CAAC,IAAK,IAAY,CAAC;AAAA,MACzB;AAAA,IACF;AAGA,UAAM,KAAM,IAAY,WAAW,IAC/B,cACE,IAAY,WAAW,IAAI,cAAc;AAE/C,QAAI,IAAI;AACN,YAAM,aAAc,IAAY,EAAE;AAClC,UAAI,cAAc,OAAO,eAAe,UAAU;AAChD,cAAM,OAAgC,CAAC;AAEvC,mBAAW,KAAK,OAAO,KAAK,UAAU,GAAG;AACvC,cAAI,MAAM,aAAc,MAAK,CAAC,IAAK,WAAmB,CAAC;AAAA,QACzD;AAEA,cAAM,MAAO,WAAmB,YAAY;AAC5C,YAAI,OAAO,OAAO,OAAO,QAAQ,UAAU;AACzC,gBAAM,UAAW,IAAY,GAAG;AAChC,cAAI,WAAW,OAAO,YAAY,UAAU;AAC1C,mBAAO,OAAO,MAAM,OAAO;AAAA,UAC7B;AAAA,QACF;AACA,YAAI,OAAO,KAAK,IAAI,EAAE,SAAS,GAAG;AAEhC,cAAI,WAAW,IAAI;AAAA,QACrB;AAAA,MACF;AAAA,IACF;AAEA,WAAO,OAAO,KAAK,GAAG,EAAE,SAAS,IAAI,MAAM;AAAA,EAC7C;AAEA,WAAS,OAAU,GAA6C;AAC9D,UAAM,MAAgB,CAAC;AACvB,QAAI,CAAC,EAAG,QAAO;AACf,eAAW,KAAK,EAAG,KAAI,OAAO,UAAU,eAAe,KAAK,GAAG,CAAC,EAAG,KAAI,KAAK,CAAC;AAC7E,WAAO;AAAA,EACT;;;AC5SA,iBAAsB,wBACpB,cAC8B;AAC9B,UAAM,cAAc,MAAM,aAAa,iCAAiC;AAExE,UAAM,qBAAqB,oBAAI,IAAoB;AACnD,eAAW,OAAO,aAAa;AAC7B,yBAAmB,IAAI,IAAI,IAAI,IAAI,IAAI;AAAA,IACzC;AAEA,UAAM,UAAU,oBAAI,IAAY;AAChC,UAAM,MAAgB,CAAC;AACvB,eAAW,OAAO,aAAa;AAC7B,iBAAW,MAAM,IAAI,aAAa;AAChC,YAAI,MAAM,CAAC,QAAQ,IAAI,EAAE,GAAG;AAC1B,kBAAQ,IAAI,EAAE;AACd,cAAI,KAAK,EAAE;AAAA,QACb;AAAA,MACF;AAAA,IACF;AAEA,UAAM,gBAAgB,oBAAI,IAAsB;AAChD,QAAI,IAAI,SAAS,GAAG;AAClB,YAAM,UAAU,MAAM,QAAQ,IAAI,IAAI,IAAI,QAAM,aAAa,qBAAqB,EAAE,CAAC,CAAC;AACtF,eAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,cAAM,WAAW,QAAQ,CAAC;AAC1B,YAAI,SAAU,eAAc,IAAI,IAAI,CAAC,GAAG,QAAQ;AAAA,MAClD;AAAA,IACF;AAEA,WAAO,EAAE,aAAa,eAAe,mBAAmB;AAAA,EAC1D;;;ACLO,WAAS,OAAO,YAAoB,MAAsB;AAC/D,WAAO,aAAa,MAAM;AAAA,EAC5B;;;AC/BA,WAAS,QAAQ,GAA4C;AAC3D,QAAI,MAAM,QAAS,QAAO;AAC1B,QAAI,MAAM,QAAS,QAAO;AAC1B,QAAI,MAAM,SAAU,QAAO;AAC3B,WAAO;AAAA,EACT;AAGA,WAAS,aAAa,GAAyD;AAC7E,WAAO,CAAC,CAAC,KAAK,OAAO,MAAM,YAAa,EAAwB,SAAS,oBAAoB,OAAQ,EAAuB,OAAO;AAAA,EACrI;AAGA,WAAS,OAAO,GAAiE;AAC/E,WAAO,CAAC,CAAC,KAAK,OAAO,MAAM,YACzB,OAAQ,EAAsB,MAAM,YACpC,OAAQ,EAAsB,MAAM,YACpC,OAAQ,EAAsB,MAAM,YACpC,OAAQ,EAAsB,MAAM;AAAA,EACxC;AAMA,iBAAsB,gBAAqC;AACzD,UAAM,UAAU,MAAM,KAAK;AAC3B,UAAM,eAAe,MAAM;AAE3B,UAAM,EAAE,aAAa,eAAe,mBAAmB,IAAI,MAAM,wBAAwB,YAAY;AAErG,UAAM,SAAsB,CAAC;AAE7B,eAAW,KAAK,aAAa;AAE3B,YAAM,eAAyC,CAAC;AAChD,iBAAW,KAAK,EAAE,MAAO,cAAa,EAAE,MAAM,IAAI,EAAE;AAEpD,iBAAW,OAAO,EAAE,aAAa;AAC/B,cAAM,KAAK,cAAc,IAAI,GAAG,KAAK,MAAM,aAAa,qBAAqB,GAAG;AAChF,YAAI,MAAM,CAAC,cAAc,IAAI,GAAG,EAAG,eAAc,IAAI,KAAK,EAAE;AAC5D,YAAI,CAAC,GAAI;AAGT,cAAM,OAAO,cAAc,EAAE,MAAM,GAAG,IAAI;AAE1C,cAAM,OAAO,QAAQ,GAAG,YAAY;AACpC,cAAM,YAA6C,CAAC;AAGpD,cAAM,aAMF,CAAC;AAGL,mBAAW,MAAM,EAAE,OAAO;AACxB,gBAAM,MAAM,OAAO,EAAE,MAAM,GAAG,IAAI;AAClC,gBAAM,KAAK,GAAG,aAAa,GAAG,MAAM;AAGpC,qBAAW,GAAG,IAAI;AAAA,YAChB,gBAAgB,EAAE;AAAA,YAClB,cAAc,EAAE;AAAA,YAChB,UAAU,GAAG;AAAA,YACb,QAAQ,GAAG;AAAA,YACX,cAAc,GAAG;AAAA,YACjB,YAAY,GAAG;AAAA,UACjB;AAEA,cAAI,aAAa,EAAE,GAAG;AACpB,kBAAM,SAAS,cAAc,IAAI,GAAG,EAAE,KAAK,MAAM,aAAa,qBAAqB,GAAG,EAAE;AACxF,gBAAI,UAAU,CAAC,cAAc,IAAI,OAAO,EAAE,EAAG,eAAc,IAAI,OAAO,IAAI,MAAM;AAChF,gBAAI,QAAQ;AACV,oBAAM,WAAW,mBAAmB,IAAI,OAAO,oBAAoB,KAAK,EAAE;AAC1E,oBAAM,QAAQ,cAAc,UAAU,OAAO,IAAI;AACjD,wBAAU,GAAG,IAAI,EAAE,MAAM,SAAS,MAAM,MAAM;AAAA,YAChD;AACA;AAAA,UACF;AAEA,cAAI,SAAS,WAAW,OAAO,EAAE,GAAG;AAClC,kBAAM,KAAK,gBAAgB,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,OAAO;AAC1E,sBAAU,GAAG,IAAI,EAAE,MAAM,SAAS,OAAO,GAAG;AAC5C;AAAA,UACF;AAEA,cAAI,OAAO,OAAO,UAAU;AAAE,sBAAU,GAAG,IAAI,EAAE,MAAM,UAAU,OAAO,GAAG;AAAG;AAAA,UAAU;AACxF,cAAI,OAAO,OAAO,WAAW;AAAE,sBAAU,GAAG,IAAI,EAAE,MAAM,WAAW,OAAO,GAAG;AAAG;AAAA,UAAU;AAC1F,cAAI,OAAO,OAAO,UAAU;AAAE,sBAAU,GAAG,IAAI,EAAE,MAAM,UAAU,OAAO,GAAG;AAAG;AAAA,UAAU;AAAA,QAE1F;AAEA,cAAM,WAAoC,EAAE,WAAW;AACvD,YAAI,SAAS,WAAW;AAEtB,mBAAS,cAAc,IAAI;AAAA,QAC7B;AAEA,cAAM,QAAmB;AAAA,UACvB;AAAA,UACA;AAAA,UACA;AAAA,WACI,GAAG,eAAe,GAAG,YAAY,SAAS,IAAI,EAAE,aAAa,GAAG,YAAY,IAAI,CAAC,IAJ9D;AAAA,UAKvB,YAAY;AAAA,YACV,aAAa;AAAA,UACf;AAAA,QACF;AAEA,eAAO,KAAK,KAAK;AAAA,MACnB;AAAA,IACF;AAEA,QAAI,OAAO,MAAM,uBAAuB,YAAY;AAClD,YAAM,aAAa,MAAM,mBAAmB;AAC5C,YAAM,oBAAoB;AAC1B,YAAM,cAAc;AACpB,iBAAW,SAAS,YAAY;AAC9B,cAAM,EAAE,OAAO,OAAO,gBAAgB,IAAI,6BAA6B,KAAK;AAC5E,cAAM,OAAO,cAAc,mBAAmB,MAAM,IAAI;AACxD,cAAM,MAAM,OAAO,mBAAmB,WAAW;AACjD,cAAM,YAA6C,CAAC;AACpD,kBAAU,GAAG,IAAI,EAAE,MAAM,cAAc,MAAM;AAE7C,cAAM,aAKF,CAAC;AACL,mBAAW,GAAG,IAAI;AAAA,UAChB,SAAS,MAAM;AAAA,UACf,WAAW,MAAM;AAAA,QACnB;AAEA,cAAM,aAAsC;AAAA,UAC1C,aAAa;AAAA,YACX,WAAW;AAAA,YACX,SAAS,MAAM;AAAA,YACf,WAAW,MAAM;AAAA,YACjB,YAAY;AAAA,YACZ;AAAA,UACF;AAAA,QACF;AAEA,eAAO,KAAK;AAAA,UACV;AAAA,UACA,MAAM;AAAA,UACN;AAAA,WACI,MAAM,eAAe,MAAM,YAAY,SAAS,IAAI,EAAE,aAAa,MAAM,YAAY,IAAI,CAAC,IAJpF;AAAA,UAKV;AAAA,QACF,EAAC;AAAA,MACH;AAAA,IACF;AAEA,WAAO,EAAE,OAAO;AAAA,EAClB;;;AC3IA,WAASC,SAAQ,KAAa;AAhC9B;AAiCE,QAAI;AAAE,kBAAM,OAAN,mBAAU,YAAY,EAAE,MAAM,QAAQ,SAAS,EAAE,SAAS,IAAI,EAAE;AAAA,IAAI,SAAQ;AAAA,IAAe;AAAA,EACnG;AACA,WAASC,SAAQ,KAAa;AAAE,IAAAD,SAAQ,cAAc,GAAG;AAAA,EAAG;AAC5D,WAAS,SAAS,KAAa;AAAE,IAAAA,SAAQ,YAAY,GAAG;AAAA,EAAG;AAO3D,WAAS,0BAA0B,GAAqC;AACtE,QAAI;AACF,YAAM,MAAM,EAAE,cAAc,OAAO,EAAE,eAAe,WAC/C,EAAE,WAAmB,WAAW,IACjC;AACJ,YAAM,KAAK,OAAO,OAAO,QAAQ,WAAY,IAAY,eAAe;AACxE,aAAO,OAAO,YAAY,YAAY;AAAA,IACxC,SAAQ;AAAE,aAAO;AAAA,IAAW;AAAA,EAC9B;AAGA,WAAS,mBAAmB,GAAyB;AACnD,WAAO,OAAO,MAAM,YAAY,kBAAkB,KAAK,EAAE,KAAK,CAAC;AAAA,EACjE;AAGA,WAAS,0BAA0B,GAAuB;AACxD,UAAM,QAAQ,EAAE,aAAa,CAAC;AAC9B,eAAW,KAAK,OAAO;AACrB,YAAM,IAAK,MAAc,CAAC;AAC1B,UAAI,CAAC,KAAK,EAAE,SAAS,QAAS;AAC9B,UAAI,EAAE,SAAS,YAAY,mBAAmB,EAAE,KAAK,EAAG,QAAO;AAAA,IACjE;AACA,WAAO;AAAA,EACT;AAGA,WAAS,oBAAoB,GAAuB;AAClD,UAAM,QAAQ,EAAE,aAAa,CAAC;AAC9B,eAAW,KAAK,OAAO;AACrB,YAAM,IAAI,MAAM,CAAC;AACjB,UAAI,CAAC,EAAG;AAER,UAAI,EAAE,SAAS,SAAS;AAEtB,YAAI,EAAE,SAAS,WAAW,4BAA4B,EAAE,KAAK,EAAG,QAAO;AAAA,MACzE,OAAO;AAEL,YAAI,EAAE,SAAS,EAAE,KAAM,QAAO;AAAA,MAChC;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAQA,WAAS,mCAAmC,GAAc,SAAqD;AAC7G,UAAM,mBAAmB,yBAAyB,OAAO;AACzD,UAAM,QAAQ,EAAE,aAAa,CAAC;AAC9B,QAAI;AACJ,QAAI,sBAAsB;AAC1B,eAAW,OAAO,OAAO;AACvB,YAAM,IAAK,MAAc,GAAG;AAC5B,UAAI,CAAC,KAAK,EAAE,SAAS,QAAS;AAE9B,UAAI,EAAE,SAAS,SAAS;AACtB,YAAI,EAAE,SAAS,QAAS;AAGxB,cAAM,QAAQ,sBAAsB,EAAE,KAAK;AAC3C,YAAI,CAAC,MAAM,IAAI;AACb,uBAAa,YAAY,GAAG,gBAAgB,MAAM,MAAM;AACxD;AAAA,QACF;AAGA,cAAM,MAAM,EAAE,MAAM,cAAc,QAAQ,YAAY;AACtD,YAAI,CAAC,oCAAoC,IAAI,gBAAgB,GAAG;AAC9D,uBAAa,oBAAe,EAAE,qDAA2C,gBAAgB;AACzF,cAAI,CAAC,qBAAqB;AACxB,YAAAC,SAAQ,0CAAqC,EAAE,KAAK,KAAK,GAAG,CAAC,aAAQ,GAAG,WAAM,UAAU,EAAE;AAC1F,kCAAsB;AAAA,UACxB;AACA;AAAA,QACF;AAEA,eAAO,EAAE,IAAI,KAAK;AAAA,MACpB,WAAW,EAAE,SAAS,YAAY,EAAE,SAAS,YAAY,EAAE,SAAS,WAAW;AAC7E,YAAI,EAAE,SAAS,EAAE,KAAM,QAAO,EAAE,IAAI,KAAK;AAAA,MAC3C;AAAA,IACF;AACA,QAAI,EAAE,SAAS,YAAY,EAAE,SAAS,YAAY,EAAE,SAAS,WAAW;AACtE,aAAO,EAAE,IAAI,MAAM;AAAA,IACrB;AACA,QAAI,qBAAqB;AACvB,aAAO,EAAE,IAAI,OAAO,cAAc,KAAK;AAAA,IACzC;AACA,WAAO,EAAE,IAAI,OAAO,QAAQ,cAAc,6EAA6E;AAAA,EACzH;AAGA,WAAS,gBAAgB,GAA4C;AACnE,QAAI,MAAM,QAAS,QAAO;AAC1B,QAAI,MAAM,SAAU,QAAO;AAC3B,QAAI,MAAM,SAAU,QAAO;AAC3B,WAAO;AAAA,EACT;AAEA,WAAS,WAAc,KAA+C;AACpE,UAAM,MAAgB,CAAC;AACvB,QAAI,CAAC,IAAK,QAAO;AACjB,eAAW,KAAK,IAAK,KAAI,OAAO,UAAU,eAAe,KAAK,KAAK,CAAC,EAAG,KAAI,KAAK,CAAC;AACjF,WAAO;AAAA,EACT;AAGA,WAAS,cAAc,GAAuB;AAC5C,UAAM,QAAQ,EAAE,aAAa,CAAC;AAC9B,eAAW,KAAK,OAAO;AACrB,YAAM,IAAI,MAAM,CAAC;AACjB,UAAI,KAAK,EAAE,SAAS,QAAS,QAAO;AAAA,IACtC;AACA,WAAO;AAAA,EACT;AAGA,WAAS,uBAAuB,GAAc,KAAa,mBAAwC;AACjG,QAAI;AACF,YAAM,SAAS,EAAE,cAAc,OAAO,EAAE,eAAe,WAAY,EAAE,WAAmB,WAAW,IAAI;AACvG,UAAI,CAAC,UAAU,OAAO,WAAW,SAAU;AAE3C,UAAI;AACJ,UAAI,OAAO,OAAO,QAAQ,SAAU,WAAU,OAAO;AACrD,YAAM,KAAK,OAAO,cAAc,OAAO,OAAO,eAAe,WAAW,OAAO,aAAa;AAC5F,UAAI,CAAC,WAAW,MAAM,GAAG,GAAG,KAAK,OAAO,GAAG,GAAG,EAAE,QAAQ,SAAU,WAAU,GAAG,GAAG,EAAE;AAEpF,UAAI,CAAC,WAAW,CAAC,kBAAmB;AACpC,YAAM,IAAI,QAAQ,KAAK,EAAE,YAAY;AACrC,YAAM,IAAI,kBAAkB,KAAK,EAAE,YAAY;AAC/C,UAAI,MAAM,EAAG,CAAAA,SAAQ,4BAAuB,EAAE,KAAK,KAAK,GAAG,CAAC,aAAQ,GAAG,kCAAkC;AAAA,IAC3G,SAAQ;AAAA,IAAiC;AAAA,EAC3C;AAGA,WAAS,uBACP,SACA,mBACA,eACA,kBACU;AACV,UAAM,OAAO,MAAM,QAAQ,OAAO,IAC9B,QAAQ,MAAM,IACd,OAAO,OAAO,EAAE,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,EAAE,OAAO,OAAO;AAEhE,QAAI,KAAK,WAAW,EAAG,QAAO,CAAC,iBAAiB;AAEhD,UAAM,QAAQ,KAAK,CAAC;AACpB,QAAI,iBAAiB,IAAI,KAAK,EAAG,QAAO;AAExC,UAAM,SAAS,cAAc,KAAK;AAClC,QAAI,UAAU,iBAAiB,IAAI,MAAM,GAAG;AAC1C,WAAK,CAAC,IAAI;AACV,aAAO;AAAA,IACT;AAGA,WAAO,CAAC,mBAAmB,GAAG,IAAI;AAAA,EACpC;AAMA,WAAS,qBAAqB,GAAgD;AAC5E,UAAM,MAAM,EAAE,cAAc,OAAO,EAAE,eAAe,WAC/C,EAAE,WAAmB,WAAW,IACjC;AAEJ,QAAI,CAAC,OAAO,OAAO,QAAQ,SAAU,QAAO,EAAE,IAAI,KAAK;AAEvD,UAAM,iBAAiB,EAAE,KAAK,CAAC;AAC/B,UAAM,eAAe,EAAE,KAAK,MAAM,CAAC,EAAE,KAAK,GAAG;AAE7C,QAAI,qBACF,OAAQ,IAAY,mBAAmB,WAAY,IAAY,iBAAiB;AAClF,QAAI,mBACF,OAAQ,IAAY,iBAAiB,WAAY,IAAY,eAAe;AAG9E,QAAI,CAAC,sBAAsB,CAAC,kBAAkB;AAC5C,YAAM,MAAO,IAAY;AACzB,UAAI,OAAO,OAAO,QAAQ,UAAU;AAClC,cAAM,UAAU,WAAW,EAAE,SAAS;AACtC,YAAI;AAEJ,mBAAW,KAAK,SAAS;AACvB,cAAI,IAAI,CAAC,KAAK,OAAO,IAAI,CAAC,MAAM,UAAU;AAAE,uBAAW;AAAG;AAAA,UAAO;AAAA,QACnE;AACA,YAAI,CAAC,UAAU;AACb,qBAAW,KAAK,KAAK;AACnB,gBAAI,OAAO,UAAU,eAAe,KAAK,KAAK,CAAC,KAAK,IAAI,CAAC,KAAK,OAAO,IAAI,CAAC,MAAM,UAAU;AACxF,yBAAW;AAAG;AAAA,YAChB;AAAA,UACF;AAAA,QACF;AAEA,YAAI,UAAU;AACZ,gBAAM,UAAU,IAAI,QAAQ;AAC5B,cAAI,CAAC,sBAAsB,OAAO,QAAQ,mBAAmB,SAAU,sBAAqB,QAAQ;AACpG,cAAI,CAAC,oBAAoB,OAAO,QAAQ,iBAAiB,SAAU,oBAAmB,QAAQ;AAAA,QAChG;AAAA,MACF;AAAA,IACF;AAEA,QAAI,OAAO,uBAAuB,YAAY,uBAAuB,gBAAgB;AACnF,aAAO;AAAA,QACL,IAAI;AAAA,QACJ,QACE,kBAAa,EAAE,KAAK,KAAK,GAAG,CAAC,6DAA8C,kBAAkB,gDAC/D,cAAc;AAAA,MAChD;AAAA,IACF;AAEA,QAAI,OAAO,qBAAqB,YAAY,qBAAqB,cAAc;AAC7E,aAAO;AAAA,QACL,IAAI;AAAA,QACJ,QACE,kBAAa,EAAE,KAAK,KAAK,GAAG,CAAC,2DAA4C,gBAAgB,8CAC7D,YAAY;AAAA,MAC5C;AAAA,IACF;AAEA,WAAO,EAAE,IAAI,KAAK;AAAA,EACpB;AAEA,WAAS,+BAA+B,GAAc,WAAqD;AACzG,UAAM,MAAM,EAAE,cAAc,OAAO,EAAE,eAAe,WAC/C,EAAE,WAAmB,WAAW,IACjC;AAEJ,QAAI,CAAC,OAAO,OAAO,QAAQ,SAAU,QAAO,EAAE,IAAI,KAAK;AAEvD,UAAM,WAAW,OAAQ,IAAY,cAAc,WAAY,IAAY,YAAY;AACvF,QAAI,YAAY,aAAa,WAAW;AACtC,aAAO;AAAA,QACL,IAAI;AAAA,QACJ,QAAQ,kBAAa,EAAE,KAAK,KAAK,GAAG,CAAC,wDAAyC,QAAQ,8CAA+B,SAAS;AAAA,MAChI;AAAA,IACF;AAEA,WAAO,EAAE,IAAI,KAAK;AAAA,EACpB;AAGA,WAAS,IAAI,MAAwB;AAAE,WAAO,KAAK,KAAK,GAAG;AAAA,EAAG;AAE9D,WAAS,aACP,KACA,mBACA,YACA,OACM;AACN,UAAM,UAAU;AAChB,UAAM,UAAU,YAAY,iBAAiB;AAC7C,UAAM,SAAS;AACf,UAAM,UAAU,WAAW,IAAI,OAAK,YAAY,CAAC,CAAC;AAGlD,QAAI,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,CAAC,IAAI;AAEjC,QAAI,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,CAAC,IAAI;AAElC,QAAI,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,CAAC,IAAI;AAEjC,QAAI,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,CAAC,IAAI;AAAA,EACpC;AAEA,iBAAsB,eAAe,OAAyC;AAC5E,UAAM,UAAU,MAAM,KAAK;AAC3B,UAAM,mBAAmB,yBAAyB,OAAO;AACzD,UAAM,eAAe,MAAM;AAE3B,IAAAD,SAAQ,kCAAkC,OAAO,OAAO,CAAC,eAAe,gBAAgB,IAAI;AAE5F,UAAM;AAAA,MACJ,aAAa;AAAA,MACb;AAAA,MACA;AAAA,IACF,IAAI,MAAM,wBAAwB,YAAY;AAE9C,UAAM,YAAoD,CAAC;AAC3D,eAAW,KAAK,oBAAqB,WAAU,EAAE,IAAI,IAAI;AAEzD,UAAM,yBAAoD,CAAC;AAC3D,eAAW,KAAK,qBAAqB;AACnC,YAAM,WAAW,EAAE;AACnB,iBAAW,OAAO,EAAE,aAAa;AAC/B,cAAM,WAAW,cAAc,IAAI,GAAG;AACtC,YAAI,CAAC,SAAU;AACf,cAAM,UAAU,SAAS,KAAK,MAAM,GAAG;AACvC,qBAAa,wBAAwB,UAAU,SAAS,SAAS,EAAE;AAAA,MACrE;AAAA,IACF;AAGA,UAAM,mBAAmB,IAAI,IAAY,OAAO,KAAK,SAAS,CAAC;AAC/D,UAAM,gBAA4C,CAAC;AACnD,eAAW,QAAQ,iBAAkB,eAAc,YAAY,IAAI,CAAC,IAAI;AACxE,eAAW,KAAK,MAAM,QAAQ;AAC5B,YAAM,OAAO,EAAE,KAAK,CAAC;AACrB,uBAAiB,IAAI,IAAI;AACzB,oBAAc,YAAY,IAAI,CAAC,IAAI;AAAA,IACrC;AAGA,UAAM,eAA4B,CAAC;AACnC,UAAM,kBAA+B,CAAC;AACtC,UAAM,mBAAgC,CAAC;AAEvC,eAAW,KAAK,MAAM,QAAQ;AAC5B,UAAI,EAAE,SAAS,cAAc;AAC3B,yBAAiB,KAAK,CAAC;AACvB;AAAA,MACF;AACA,YAAM,YAAY,oBAAoB,CAAC;AACvC,YAAM,WAAW,cAAc,CAAC;AAEhC,UAAI,WAAW;AACb,qBAAa,KAAK,CAAC;AAAA,MACrB,WAAW,UAAU;AACnB,wBAAgB,KAAK,CAAC;AAAA,MACxB,OAAO;AACL,QAAAC,SAAQ,WAAW,EAAE,IAAI,gBAAW,EAAE,KAAK,KAAK,GAAG,CAAC,yBAAe,EAAE,IAAI,gCAAgC;AAAA,MAC3G;AAGA,UAAI,EAAE,SAAS,YAAY,CAAC,0BAA0B,CAAC,KAAK,0BAA0B,CAAC,GAAG;AACxF,QAAAD,SAAQ,eAAU,EAAE,KAAK,KAAK,GAAG,CAAC,kHAA6G;AAAA,MACjJ;AAAA,IACF;AAIA,aAAS,iBAAiB,MAAkC;AAC1D,UAAI,MAAM,UAAU,IAAI;AACxB,UAAI,CAAC,KAAK;AACR,cAAM,aAAa,yBAAyB,IAAI;AAChD,kBAAU,IAAI,IAAI;AAClB,yBAAiB,IAAI,IAAI;AACzB,sBAAc,YAAY,IAAI,CAAC,IAAI;AACnC,2BAAmB,IAAI,IAAI,IAAI,IAAI;AAAA,MACrC;AACA,aAAO;AAAA,IACT;AAEA,QAAI,oBAAoB;AAExB,mBAAe,uBAAuB,QAAoC;AACxE,UAAI,OAAO,WAAW,EAAG;AAEzB,YAAM,gBAAgB,OAAO,MAAM,uBAAuB;AAC1D,YAAM,kBAAkB,OAAO,MAAM,oBAAoB;AACzD,UAAI,CAAC,iBAAiB,CAAC,iBAAiB;AACtC,QAAAC,SAAQ,qHAAqH;AAC7H;AAAA,MACF;AAEA,YAAM,aAAa,oBAAI,IAAuB;AAC9C,YAAM,eAAe,oBAAI,IAAuB;AAChD,YAAM,cAAc,MAAM,mBAAmB;AAC7C,iBAAW,SAAS,aAAa;AAC/B,mBAAW,IAAI,MAAM,IAAI,KAAK;AAC9B,qBAAa,IAAI,MAAM,MAAM,KAAK;AAAA,MACpC;AAEA,YAAM,cAAc,oBAAI,IAAY;AAEpC,iBAAW,SAAS,QAAQ;AAC1B,cAAM,gBAAgB,MAAM,KAAK,MAAM,CAAC;AACxC,cAAM,YAAY,cAAc,KAAK,GAAG;AACxC,YAAI,CAAC,WAAW;AACd,UAAAA,SAAQ,kCAA6B,MAAM,KAAK,KAAK,GAAG,CAAC,2DAAiD;AAC1G;AAAA,QACF;AAEA,cAAM,YAAY,+BAA+B,OAAO,SAAS;AACjE,YAAI,CAAC,UAAU,IAAI;AACjB,UAAAA,SAAQ,UAAU,MAAO;AACzB;AAAA,QACF;AAEA,cAAM,UAAU,WAAW,MAAM,SAAS;AAC1C,YAAI,kBAA0C;AAC9C,YAAI,qBAAqB;AACzB,mBAAW,OAAO,SAAS;AACzB,gBAAM,MAAM,MAAM,UAAU,GAAG;AAC/B,cAAI,CAAC,IAAK;AACV,cAAI,IAAI,SAAS,cAAc;AAC7B;AACA,gBAAI,CAAC,gBAAiB,mBAAkB,IAAI;AAAA,UAC9C,WAAW,IAAI,SAAS,SAAS;AAC/B,YAAAA,SAAQ,qCAAgC,MAAM,KAAK,KAAK,GAAG,CAAC,aAAQ,GAAG,6CAAwC;AAAA,UACjH,OAAO;AACL,YAAAA,SAAQ,uCAAkC,MAAM,KAAK,KAAK,GAAG,CAAC,aAAQ,GAAG,uCAAkC;AAAA,UAC7G;AAAA,QACF;AAEA,YAAI,CAAC,iBAAiB;AACpB,UAAAA,SAAQ,kCAA6B,MAAM,KAAK,KAAK,GAAG,CAAC,0CAAgC;AACzF;AAAA,QACF;AACA,YAAI,qBAAqB,GAAG;AAC1B,UAAAA,SAAQ,0BAAqB,MAAM,KAAK,KAAK,GAAG,CAAC,iEAA4D;AAAA,QAC/G;AAEA,cAAM,MAAM,MAAM,cAAc,OAAO,MAAM,eAAe,WACvD,MAAM,WAAmB,WAAW,IACrC;AACJ,cAAM,aAAa,OAAO,OAAO,QAAQ,YAAY,OAAQ,IAAY,YAAY,WACjF,OAAQ,IAAY,OAAO,IAC3B;AACJ,cAAM,gBAAgB,OAAO,OAAO,QAAQ,WACvC,IAAY,aACb;AAEJ,YAAI,QAA0B;AAC9B,YAAI,eAAe;AACnB,YAAI,YAAY;AACd,kBAAQ,WAAW,IAAI,UAAU,KAAK;AAAA,QACxC;AACA,YAAI,CAAC,OAAO;AACV,kBAAQ,aAAa,IAAI,SAAS,KAAK;AAAA,QACzC;AACA,YAAI,CAAC,OAAO;AACV,kBAAQ,MAAM,gBAAgB;AAC9B,yBAAe;AAAA,QACjB;AACA,cAAM,EAAE,UAAU,aAAa,IAAI,4BAA4B,eAAe;AAC9E,YAAI,cAA+B;AACnC,YAAI,YAAY;AAChB,cAAM,YAAY,MAAM,KAAK,KAAK,GAAG;AACrC,YAAI,UAAU;AACZ,gBAAM,MAAM,SAAS,SAAS,QAAQ,SAAS;AAC/C,cAAI,CAAC,YAAY,IAAI,GAAG,GAAG;AACzB,gBAAI;AACF,oBAAM,MAAM,cAAc,QAAQ;AAClC,0BAAY,IAAI,GAAG;AAAA,YACrB,SAAS,KAAK;AACZ,oBAAM,MAAM,eAAe,QAAQ,IAAI,UAAU,OAAO,GAAG;AAC3D,cAAAA,SAAQ,kCAA6B,SAAS,2CAA4B,SAAS,MAAM,IAAI,SAAS,KAAK,WAAM,GAAG,EAAE;AACtH,0BAAY;AAAA,YACd;AAAA,UACF;AACA,cAAI,CAAC,aAAa,YAAY,IAAI,GAAG,GAAG;AACtC,0BAAc;AACd,gBAAI,cAAc;AAChB,cAAAD,SAAQ,0BAAqB,MAAM,KAAK,KAAK,GAAG,CAAC,sDAA4C,SAAS,KAAK,SAAI;AAAA,YACjH;AAAA,UACF;AAAA,QACF,OAAO;AACL,UAAAC,SAAQ,kCAA6B,SAAS,uDAA6C;AAC3F,sBAAY;AAAA,QACd;AAEA,YAAI,aAAa,CAAC,aAAa;AAC7B,cAAI,cAAc;AAChB,gBAAI;AAAE,oBAAM,OAAO;AAAA,YAAG,SAAQ;AAAA,YAAe;AAAA,UAC/C;AACA;AAAA,QACF;AAEA,cAAM,WAAW,MAAM;AACvB,YAAI,MAAM,SAAS,WAAW;AAC5B,gBAAM,OAAO;AAAA,QACf;AACA,mBAAW,IAAI,MAAM,IAAI,KAAK;AAC9B,YAAI,YAAY,aAAa,IAAI,QAAQ,MAAM,OAAO;AACpD,uBAAa,OAAO,QAAQ;AAAA,QAC9B;AACA,qBAAa,IAAI,WAAW,KAAK;AAEjC,YAAI,OAAO,MAAM,gBAAgB,YAAY,MAAM,YAAY,KAAK,EAAE,SAAS,KAAK,MAAM,gBAAgB,MAAM,aAAa;AAC3H,cAAI;AAAE,kBAAM,cAAc,MAAM;AAAA,UAAa,SAAQ;AAAA,UAAe;AAAA,QACtE;AAEA,YAAI,cAAc;AAChB;AAAA,QACF;AAEA,cAAM,WAAW,gCAAgC,OAAO,iBAAiB;AAAA,UACvE,UAAU;AAAA,UACV,OAAO,wCAAiB;AAAA,QAC1B,CAAC;AACD,mBAAW,WAAW,UAAU;AAC9B,UAAAA,SAAQ,oBAAe,SAAS,WAAM,OAAO,EAAE;AAAA,QACjD;AAAA,MACF;AAAA,IACF;AAGA,UAAM,WAAsC,CAAC;AAE7C,aAAS,gBAAgB,MAAwB;AAE/C,aAAO,KAAK,MAAM,CAAC,EAAE,KAAK,GAAG,MAAM,KAAK,CAAC,KAAK;AAAA,IAChD;AAEA,eAAW,KAAK,cAAc;AAC5B,UAAI,EAAE,KAAK,SAAS,EAAG;AAGvB,YAAM,UAAU,qBAAqB,CAAC;AACtC,UAAI,CAAC,QAAQ,IAAI;AAAE,QAAAA,SAAQ,QAAQ,MAAO;AAAG;AAAA,MAAU;AAEvD,YAAM,iBAAiB,EAAE,KAAK,CAAC;AAC/B,YAAM,UAAU,gBAAgB,EAAE,IAAI;AAGtC,YAAM,cAAc,mCAAmC,GAAG,OAAO;AACjE,UAAI,CAAC,YAAY,IAAI;AACnB,YAAI,YAAY,QAAQ;AACtB,UAAAA,SAAQ,2BAA2B,EAAE,IAAI,gBAAW,EAAE,KAAK,KAAK,GAAG,CAAC,iBAAO,YAAY,MAAM,EAAE;AAAA,QACjG,WAAW,CAAC,YAAY,cAAc;AACpC,UAAAA,SAAQ,2BAA2B,EAAE,IAAI,gBAAW,EAAE,KAAK,KAAK,GAAG,CAAC,2FAAiF;AAAA,QACvJ;AACA;AAAA,MACF;AAEA,YAAM,MAAM,iBAAiB,cAAc;AAG3C,UAAI,gBAA+B;AACnC,iBAAW,OAAO,IAAI,aAAa;AACjC,cAAM,OAAO,cAAc,IAAI,GAAG,KAAK,MAAM,aAAa,qBAAqB,GAAG;AAClF,YAAI,QAAQ,CAAC,cAAc,IAAI,GAAG,KAAK,KAAM,eAAc,IAAI,KAAK,IAAI;AACxE,YAAI,QAAQ,KAAK,SAAS,SAAS;AAAE,0BAAgB,KAAK;AAAI;AAAA,QAAO;AAAA,MACvE;AAEA,UAAI,IAAqB;AACzB,UAAI,eAAe;AACjB,YAAI,cAAc,IAAI,aAAa,KAAK,MAAM,aAAa,qBAAqB,aAAa;AAC7F,YAAI,KAAK,CAAC,cAAc,IAAI,aAAa,EAAG,eAAc,IAAI,eAAe,CAAC;AAC9E,YAAI,CAAC,EAAG;AAAA,MACV,OAAO;AACL,cAAM,OAAO,0BAA0B,CAAC;AAExC,cAAM,WACH,SAAS,aAAa,EAAE,SAAS,WAAY,YAAY,gBAAgB,EAAE,IAAI;AAElF,YAAI,aAAa,eAAe,SAAS,KAAK,QAAQ;AACtD,sBAAc,IAAI,EAAE,IAAI,CAAC;AAAA,MAC3B;AAIA,UAAI,OAAO,EAAE,gBAAgB,YAAY,EAAE,YAAY,KAAK,EAAE,SAAS,KAAK,EAAE,gBAAgB,EAAE,aAAa;AAC3G,YAAI;AAAE,YAAE,cAAc,EAAE;AAAA,QAAa,SAAQ;AAAA,QAAe;AAAA,MAC9D;AAGA,YAAM,UAAU,QAAQ,MAAM,GAAG;AACjC,mBAAa,UAAU,gBAAgB,SAAS,EAAE,EAAE;AAAA,IACtD;AAGA,UAAM,UAAuB,gBAAgB,MAAM;AACnD,WAAO,QAAQ,QAAQ;AACrB,UAAI,WAAW;AACf,YAAM,YAAyB,CAAC;AAEhC,iBAAW,KAAK,SAAS;AAEvB,cAAM,UAAU,qBAAqB,CAAC;AACtC,YAAI,CAAC,QAAQ,IAAI;AAAE,UAAAA,SAAQ,QAAQ,MAAO;AAAG;AAAA,QAAU;AAEvD,cAAM,iBAAiB,EAAE,KAAK,CAAC;AAC/B,cAAM,UAAU,gBAAgB,EAAE,IAAI;AAGtC,cAAM,cAAc,QAAQ,MAAM,GAAG;AACrC,cAAM,WAAW,oBAAI,IAAY;AACjC,SAAC,SAAS,cAAc;AACtB,gBAAM,UAAU;AAChB,gBAAM,UAAU,YAAY,cAAc;AAC1C,gBAAM,SAAS;AACf,gBAAM,UAAU,YAAY,IAAI,OAAK,YAAY,CAAC,CAAC;AACnD,mBAAS,IAAI,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,CAAC;AACtC,mBAAS,IAAI,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,CAAC;AACvC,mBAAS,IAAI,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,CAAC;AACtC,mBAAS,IAAI,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,CAAC;AAAA,QACzC,GAAG;AAGH,YAAI,aAAa;AACjB,cAAM,UAAU,WAAW,EAAE,SAAS;AACtC,mBAAW,OAAO,SAAS;AACzB,gBAAM,MAAO,EAAE,UAAkB,GAAG;AACpC,cAAI,CAAC,OAAO,IAAI,SAAS,QAAS;AAElC,gBAAM,OAAO,uBAAuB,IAAI,MAAM,gBAAgB,eAAe,gBAAgB;AAC7F,gBAAM,WAAW,IAAI,IAAI;AAEzB,cAAI,SAAS,IAAI,QAAQ,EAAG;AAE5B,cAAI,SAAS,QAAQ,KAAK,uBAAuB,QAAQ,GAAG;AAC1D,yBAAa;AACb;AAAA,UACF;AAAA,QACF;AAEA,YAAI,CAAC,YAAY;AAEf,oBAAU,KAAK,CAAC;AAChB;AAAA,QACF;AAGA,cAAM,MAAM,iBAAiB,cAAc;AAG3C,YAAI,gBAA+B;AACrC,mBAAW,OAAO,IAAI,aAAa;AACjC,gBAAM,OAAO,cAAc,IAAI,GAAG,KAAK,MAAM,aAAa,qBAAqB,GAAG;AAClF,cAAI,QAAQ,CAAC,cAAc,IAAI,GAAG,EAAG,eAAc,IAAI,KAAK,IAAI;AAChE,cAAI,QAAQ,KAAK,SAAS,SAAS;AAAE,4BAAgB,KAAK;AAAI;AAAA,UAAO;AAAA,QACvE;AAEA,YAAI,IAAqB;AACzB,YAAI,eAAe;AACjB,cAAI,cAAc,IAAI,aAAa,KAAK,MAAM,aAAa,qBAAqB,aAAa;AAC7F,cAAI,KAAK,CAAC,cAAc,IAAI,aAAa,EAAG,eAAc,IAAI,eAAe,CAAC;AAC9E,cAAI,CAAC,EAAG;AAAA,QACV,OAAO;AACL,gBAAM,OAAO,0BAA0B,CAAC;AACxC,gBAAM,WACH,SAAS,aAAa,EAAE,SAAS,WAAY,YAAY,gBAAgB,EAAE,IAAI;AAElF,cAAI,aAAa,eAAe,SAAS,KAAK,QAAQ;AACtD,wBAAc,IAAI,EAAE,IAAI,CAAC;AAAA,QAC3B;AAIE,YAAI,OAAO,EAAE,gBAAgB,YAAY,EAAE,YAAY,KAAK,EAAE,SAAS,KAAK,EAAE,gBAAgB,EAAE,aAAa;AAC3G,cAAI;AAAE,cAAE,cAAc,EAAE;AAAA,UAAa,SAAQ;AAAA,UAAe;AAAA,QAC9D;AAGA,cAAM,UAAU,QAAQ,MAAM,GAAG;AACjC,qBAAa,UAAU,gBAAgB,SAAS,EAAE,EAAE;AAEpD,mBAAW;AAAA,MACb;AAEA,UAAI,CAAC,UAAU;AAEb,mBAAW,KAAK,WAAW;AACzB,UAAAA,SAAQ,oCAA+B,EAAE,KAAK,KAAK,GAAG,CAAC,+BAA0B;AAAA,QACnF;AACA;AAAA,MACF;AAGA,cAAQ,SAAS;AACjB,YAAM,UAAU,KAAK,MAAM,SAAS,SAAS;AAAA,IAC/C;AAEA,UAAM,uBAAuB,gBAAgB;AAG7C,UAAM,cAAyC,CAAC;AAChD,UAAM,WAAW,MAAM,aAAa,iCAAiC;AACrE,eAAW,KAAK,UAAU;AACxB,iBAAW,KAAK,EAAE,OAAO;AACvB,oBAAY,EAAE,OAAO,MAAM,EAAE,IAAI,IAAI,EAAE;AAAA,MACzC;AAAA,IACF;AAGA,eAAW,QAAQ,MAAM,QAAQ;AAE/B,YAAM,iBAAiB,KAAK,KAAK,CAAC;AAClC,YAAM,UAAU,KAAK,KAAK,MAAM,CAAC,EAAE,KAAK,GAAG;AAC3C,YAAM,UAAU,QAAQ,MAAM,GAAG;AACjC,YAAM,mBAA6B,CAAC;AACpC,OAAC,SAAS,cAAc;AACtB,cAAM,UAAU;AAChB,cAAM,UAAU,YAAY,cAAc;AAC1C,cAAM,SAAS;AACf,cAAM,UAAU,QAAQ,IAAI,OAAK,YAAY,CAAC,CAAC;AAC/C,yBAAiB;AAAA,UACf,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC;AAAA,UACxB,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC;AAAA,UACzB,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC;AAAA,UACxB,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC;AAAA,QAC3B;AAAA,MACF,GAAG;AACH,UAAI;AACJ,iBAAW,KAAK,kBAAkB;AAAE,gBAAQ,SAAS,CAAC;AAAG,YAAI,MAAO;AAAA,MAAO;AAC3E,UAAI,CAAC,MAAO;AAEZ,YAAM,YAAY,cAAc,IAAI,KAAK,KAAK,MAAM,aAAa,qBAAqB,KAAK;AAC3F,UAAI,aAAa,CAAC,cAAc,IAAI,KAAK,EAAG,eAAc,IAAI,OAAO,SAAS;AAC9E,UAAI,CAAC,UAAW;AAGhB,UAAI,OAAO,KAAK,gBAAgB,YAAY,KAAK,YAAY,KAAK,EAAE,SAAS,KAAK,UAAU,gBAAgB,KAAK,aAAa;AAC5H,YAAI;AAAE,oBAAU,cAAc,KAAK;AAAA,QAAa,SAAQ;AAAA,QAAe;AAAA,MACzE;AAEA,YAAM,UAAU,WAAW,KAAK,SAAS;AACzC,iBAAW,OAAO,SAAS;AACzB,cAAM,MAAM,KAAK,UAAU,GAAG;AAG9B,YAAI,SAAS,YAAY,GAAG;AAC5B,YAAI,CAAC,QAAQ;AACX,gBAAM,QAAQ,IAAI,MAAM,GAAG;AAC3B,gBAAM,QAAQ,MAAM,CAAC;AACrB,gBAAM,QAAQ,MAAM,MAAM,CAAC,EAAE,KAAK,GAAG,KAAK;AAC1C,gBAAM,MAAM,UAAU,KAAK;AAC3B,cAAI,KAAK;AACP,kBAAM,QAAQ,IAAI,MAAM,KAAK,OAAK,EAAE,SAAS,KAAK;AAClD,gBAAI,OAAO;AACT,uBAAS,MAAM;AACf,0BAAY,QAAQ,MAAM,KAAK,IAAI;AACnC,0BAAY,GAAG,IAAI;AAAA,YACrB,WACS,IAAI,MAAM,WAAW,GAAG;AAC/B,oBAAM,WAAW,IAAI,MAAM,CAAC;AAC5B,oBAAM,WAAW,SAAS;AAC1B,kBAAI,aAAa,OAAO;AACtB,gBAAAA,SAAQ,oBAAe,KAAK,sDAA4C,QAAQ,mBAAS,KAAK,SAAI;AAClG,oBAAI;AACF,sBAAI,WAAW,SAAS,QAAQ,KAAK;AACrC,2BAAS,OAAO;AAChB,wBAAM,SAAS,QAAQ,MAAM;AAC7B,yBAAO,YAAY,MAAM;AACzB,2BAAS,SAAS;AAClB,wBAAM,SAAS,QAAQ,MAAM;AAC7B,8BAAY,MAAM,IAAI;AACtB,8BAAY,GAAG,IAAI;AACnB,kBAAAD,SAAQ,sBAAiB,QAAQ,uBAAQ,KAAK,8BAAoB,KAAK,SAAI;AAAA,gBAC7E,SAAS,KAAK;AACZ,wBAAM,SAAS,eAAe,QAAQ,IAAI,UAAU,OAAO,GAAG;AAC9D,2BAAS,+BAA0B,QAAQ,mBAAS,KAAK,8BAAoB,KAAK,WAAM,MAAM,EAAE;AAAA,gBAClG;AAAA,cACF,OAAO;AACL,yBAAS,SAAS;AAClB,4BAAY,QAAQ,MAAM,KAAK,IAAI;AACnC,4BAAY,GAAG,IAAI;AAAA,cACrB;AAAA,YACF,OACK;AACH,kBAAI;AACF,yBAAS,IAAI,QAAQ,KAAK;AAC1B,4BAAY,QAAQ,MAAM,KAAK,IAAI;AACnC,4BAAY,GAAG,IAAI;AAAA,cACrB,SAAS,KAAK;AACZ,sBAAM,UAAU,eAAe,QAAQ,IAAI,UAAU,OAAO,GAAG;AAC/D,oBAAI,WAAW,QAAQ,SAAS,cAAc,GAAG;AAC/C,wBAAM,WAAW,IAAI,MAAM,CAAC;AAC5B,wBAAM,YAAW,qCAAU,SAAQ;AACnC,kBAAAC,SAAQ,4BAAuB,KAAK,8BAAoB,KAAK,8EAAoE,QAAQ,SAAI;AAC7I,sBAAI;AACF,wBAAI,UAAU;AACZ,0BAAI,WAAW,SAAS,QAAQ,KAAK;AACrC,+BAAS,OAAO;AAChB,4BAAM,SAAS,QAAQ,MAAM;AAC7B,6BAAO,YAAY,MAAM;AACzB,+BAAS,SAAS;AAClB,4BAAM,SAAS,QAAQ,MAAM;AAC7B,kCAAY,MAAM,IAAI;AACtB,kCAAY,GAAG,IAAI;AACnB,sBAAAD,SAAQ,sBAAiB,QAAQ,uBAAQ,KAAK,8BAAoB,KAAK,SAAI;AAAA,oBAC7E,OACK;AACH,+BAAS,6CAAwC,KAAK,iCAA4B;AAAA,oBACpF;AAAA,kBACF,SAAS,WAAW;AAClB,0BAAM,YAAY,qBAAqB,QAAQ,UAAU,UAAU,OAAO,SAAS;AACnF,6BAAS,+BAA0B,QAAQ,mBAAS,KAAK,8BAAoB,KAAK,WAAM,SAAS,EAAE;AAAA,kBACrG;AAAA,gBACF,OAAO;AACL,2BAAS,iCAA4B,KAAK,8BAAoB,KAAK,WAAM,OAAO,EAAE;AAAA,gBACpF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AACA,YAAI,CAAC,OAAQ;AAEb,YAAI,IAAI,SAAS,SAAS;AACxB,gBAAM,oBAAoB;AAG1B,gBAAM,UAAU,MAAM,QAAQ,IAAI,IAAI,IACjC,IAAI,KAAkB,MAAM,IAC7B,OAAO,IAAI,IAAI,EAAE,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,EAAE,OAAO,OAAO;AAEjE,gBAAM,aAAyB,CAAC;AAChC,cAAI,QAAQ,SAAS,EAAG,YAAW,KAAK,OAAO;AAC/C,qBAAW,KAAK,CAAC,mBAAmB,GAAG,OAAO,CAAC;AAC/C,cAAI,QAAQ,SAAS,KAAK,cAAc,QAAQ,CAAC,CAAC,GAAG;AACnD,uBAAW,KAAK,CAAC,cAAc,QAAQ,CAAC,CAAC,GAAG,GAAG,QAAQ,MAAM,CAAC,CAAC,CAAC;AAAA,UAClE;AAEA,cAAI;AACJ,qBAAW,QAAQ,YAAY;AAE7B,kBAAM,QAAQ,IAAI,IAAI;AACtB,kBAAM,eAAe,IAAI,CAAC,YAAY,KAAK,CAAC,KAAK,EAAE,GAAG,GAAG,KAAK,MAAM,CAAC,EAAE,IAAI,OAAK,YAAY,CAAC,CAAC,CAAC,CAAC;AAEhG,uBACE,SAAS,KAAK,KACd,SAAS,YAAY,KACrB,uBAAuB,KAAK,KAC5B,uBAAuB,YAAY;AAErC,gBAAI,SAAU;AAAA,UAChB;AAEA,cAAI,CAAC,UAAU;AACb,YAAAC,SAAQ,8CAAyC,KAAK,KAAK,KAAK,GAAG,CAAC,aAAQ,GAAG,yBAAyB;AACxG;AAAA,UACF;AAGA,cAAI,aAAa,UAAU,IAAI;AAC7B,YAAAA,SAAQ,uCAAkC,KAAK,KAAK,KAAK,GAAG,CAAC,aAAQ,GAAG,yBAAyB;AACjG;AAAA,UACF;AAEA,gBAAM,WAAW,MAAM,aAAa,6BAA6B,QAAQ;AACzE,oBAAU,gBAAgB,QAAQ,QAAQ;AAC1C;AAAA,QACF,WACS,IAAI,SAAS,SAAS;AAE7B,gBAAM,QAAQ,sBAAsB,IAAI,KAAK;AAC7C,cAAI,CAAC,MAAM,IAAI;AACb,YAAAA,SAAQ,mCAA8B,KAAK,KAAK,KAAK,GAAG,CAAC,aAAQ,GAAG,WAAM,MAAM,MAAM,GAAG;AACzF;AAAA,UACF;AAGA,gBAAM,MAAM,IAAI,MAAM,cAAc,QAAQ,YAAY;AACxD,cAAI,CAAC,oCAAoC,IAAI,gBAAgB,GAAG;AAC9D,gBAAI,OAAO,gBAAgB,qBAAqB,QAAQ;AACtD,cAAAA;AAAA,gBACE,iBAAY,KAAK,KAAK,KAAK,GAAG,CAAC,aAAQ,GAAG;AAAA,cAE5C;AAAA,YACF,OAAO;AACL,cAAAA,SAAQ,mCAA8B,KAAK,KAAK,KAAK,GAAG,CAAC,aAAQ,GAAG,4BAAkB,EAAE,qDAA2C,gBAAgB,IAAI;AAAA,YACzJ;AACA;AAAA,UACF;AAGA,gBAAM,OAAO,wBAAwB,IAAI,KAAK;AAC9C,iCAAuB,MAAM,KAAK,OAAO,KAAK,QAAQ,WAAW,KAAK,MAAM,IAAI;AAChF,gBAAM,OAAO,gBAAgB,MAAM,OAAO;AAC1C,oBAAU,gBAAgB,QAAQ,EAAE,GAAG,KAAK,GAAG,GAAG,KAAK,GAAG,GAAG,KAAK,GAAG,GAAG,KAAK,EAAE,CAAC;AAAA,QAElF,WAAW,IAAI,SAAS,YAAY,IAAI,SAAS,YAAY,IAAI,SAAS,WAAW;AAInF,cAAI,UAAU,iBAAiB,WAAW;AACxC,gBAAI,IAAI,SAAS,WAAW;AAC1B,wBAAU,gBAAgB,QAAQ,CAAC,CAAC,IAAI,KAAK;AAAA,YAC/C,WAAW,IAAI,SAAS,YAAY,mBAAmB,IAAI,KAAK,GAAG;AACjE,wBAAU,gBAAgB,QAAQ,UAAU,KAAK,IAAI,MAAM,KAAK,CAAC,CAAC;AAAA,YACpE,OAAO;AACL,cAAAA,SAAQ,gEAA2D,KAAK,KAAK,KAAK,GAAG,CAAC,aAAQ,GAAG,GAAG;AAAA,YACtG;AAAA,UACF,WAAW,IAAI,SAAS,WAAW;AAEjC,sBAAU,gBAAgB,QAAQ,IAAI,QAAQ,SAAS,OAAO;AAAA,UAChE,OAAO;AACL,sBAAU,gBAAgB,QAAQ,IAAI,KAAK;AAAA,UAC7C;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAGA,eAAW,QAAQ,OAAO,KAAK,SAAS,GAAG;AACzC,YAAM,MAAM,UAAU,IAAI;AAC1B,UAAI,OAAO,IAAI,YAAY,WAAW,GAAG;AACvC,YAAI;AAAE,cAAI,OAAO;AAAA,QAAG,SAAQ;AAAA,QAAe;AAC3C,yBAAiB,OAAO,IAAI;AAC5B,eAAO,UAAU,IAAI;AAAA,MACvB;AAAA,IACF;AACA,WAAO,EAAE,kBAAkB;AAAA,EAC7B;;;AC32BA,WAASC,QAAU,KAAmC;AACpD,QAAI,MAAgB,CAAC;AACrB,QAAI;AACJ,SAAK,KAAK,IAAK,KAAI,OAAO,UAAU,eAAe,KAAK,KAAK,CAAC,EAAG,KAAI,KAAK,CAAC;AAC3E,WAAO;AAAA,EACT;AAMA,MAAM,qBAAqB;AAE3B,WAAS,gBAAgB,GAAmB;AAC1C,QAAI,UAAU,OAAO,CAAC;AACtB,cAAU,QAAQ,QAAQ,oBAAoB,GAAG;AACjD,cAAU,QAAQ,QAAQ,QAAQ,GAAG,EAAE,KAAK;AAC5C,cAAU,QAAQ,QAAQ,WAAW,EAAE;AACvC,WAAO;AAAA,EACT;AAMA,WAAS,4BAA4B,GAAc,KAA+B;AAChF,QAAI,MAAM,EAAE,UAAU,GAAG;AACzB,QAAI,CAAC,IAAK,QAAO;AAGjB,QAAI,YAA2C,CAAC;AAChD,cAAU,GAAG,IAAI;AAEjB,WAAO;AAAA,MACL,OAAO,WAAY;AAAE,YAAI,MAAgB,CAAC;AAAG,YAAI,IAAI;AAAG,aAAK,IAAI,GAAG,IAAI,EAAE,KAAK,QAAQ,IAAK,KAAI,KAAK,EAAE,KAAK,CAAC,CAAC;AAAG,eAAO;AAAA,MAAK,GAAG;AAAA,MAChI,MAAM,EAAE;AAAA,MACR,WAAW;AAAA,MACX,aAAa,EAAE;AAAA,MACf,YAAY,EAAE;AAAA,IAChB;AAAA,EACF;AAEA,WAAS,yBAAyB,OAA6B;AAC7D,QAAI,OAAiB,CAAC;AACtB,QAAI,IAAI;AACR,SAAK,IAAI,GAAG,IAAI,MAAM,OAAO,QAAQ,KAAK;AACxC,UAAI,IAAI,MAAM,OAAO,CAAC;AACtB,UAAI,KAAKA,QAAO,EAAE,SAAS;AAC3B,UAAI,IAAI;AACR,WAAK,IAAI,GAAG,IAAI,GAAG,QAAQ,KAAK;AAC9B,YAAI,MAAM,GAAG,CAAC;AACd,YAAI,UAAU;AACd,YAAI,IAAI;AACR,aAAK,IAAI,GAAG,IAAI,KAAK,QAAQ,IAAK,KAAI,KAAK,CAAC,MAAM,KAAK;AAAE,oBAAU;AAAM;AAAA,QAAO;AAChF,YAAI,CAAC,QAAS,MAAK,KAAK,GAAG;AAAA,MAC7B;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAEA,WAAS,iBAAiB,MAAsC;AAC9D,QAAI,CAAC,KAAM,QAAO,CAAC;AACnB,QAAI,MAAgB,CAAC;AACrB,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,UAAI,MAAM,KAAK,CAAC;AAChB,UAAI,OAAO,QAAQ,SAAU;AAC7B,UAAI,UAAU,IAAI,KAAK;AACvB,UAAI,CAAC,QAAS;AACd,UAAI,SAAS;AACb,eAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,IAAK,KAAI,IAAI,CAAC,MAAM,SAAS;AAAE,iBAAS;AAAM;AAAA,MAAO;AACrF,UAAI,CAAC,OAAQ,KAAI,KAAK,OAAO;AAAA,IAC/B;AACA,WAAO;AAAA,EACT;AAEA,WAAS,sBAAsB,OAAmB,WAAoE;AACpH,QAAI,YAAY,yBAAyB,KAAK;AAC9C,QAAI,gBAAgB,iBAAiB,SAAS;AAE9C,QAAI,eAAsC,CAAC;AAC3C,aAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,KAAM,cAAa,UAAU,EAAE,CAAC,IAAI;AAE5E,QAAI,aAAoC,CAAC;AACzC,QAAI,mBAA6B,CAAC;AAClC,QAAI,gBAAgB;AAEpB,QAAI,cAAc,SAAS,GAAG;AAC5B,eAAS,KAAK,GAAG,KAAK,cAAc,QAAQ,MAAM;AAChD,YAAI,MAAM,cAAc,EAAE;AAC1B,YAAI,aAAa,GAAG,EAAG,YAAW,GAAG,IAAI;AAAA,YACpC,kBAAiB,KAAK,GAAG;AAAA,MAChC;AACA,UAAI,OAAO,KAAK,UAAU,EAAE,WAAW,KAAK,UAAU,SAAS,GAAG;AAChE,wBAAgB;AAChB,iBAAS,MAAM,GAAG,MAAM,UAAU,QAAQ,MAAO,YAAW,UAAU,GAAG,CAAC,IAAI;AAAA,MAChF;AAAA,IACF,OAAO;AACL,eAAS,MAAM,GAAG,MAAM,UAAU,QAAQ,MAAO,YAAW,UAAU,GAAG,CAAC,IAAI;AAAA,IAChF;AAEA,QAAI,cAAwB,CAAC;AAC7B,aAASC,WAAU,WAAY,KAAI,OAAO,UAAU,eAAe,KAAK,YAAYA,OAAM,EAAG,aAAY,KAAKA,OAAM;AACpH,gBAAY,KAAK;AAEjB,QAAI,cAA0D,CAAC;AAC/D,aAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC5C,UAAI,eAAe,UAAU,EAAE;AAC/B,UAAI,CAAC,WAAW,YAAY,GAAG;AAC7B,oBAAY,KAAK,EAAE,SAAS,cAAc,QAAQ,uCAAuC,CAAC;AAAA,MAC5F;AAAA,IACF;AACA,gBAAY,KAAK,SAAU,GAAG,GAAG;AAC/B,UAAI,EAAE,YAAY,EAAE,QAAS,QAAO;AACpC,aAAO,EAAE,UAAU,EAAE,UAAU,KAAK;AAAA,IACtC,CAAC;AAED,QAAI,iBAA8B,CAAC;AACnC,QAAI,gBAA2H,CAAC;AAEhI,aAAS,KAAK,GAAG,KAAK,MAAM,OAAO,QAAQ,MAAM;AAC/C,UAAI,MAAM,MAAM,OAAO,EAAE;AACzB,UAAI,OAAOD,QAAO,IAAI,SAAS;AAC/B,UAAI,KAAK,WAAW,GAAG;AAErB,YAAI,aAAwB;AAAA,UAC1B,MAAM,IAAI,KAAK,MAAM;AAAA,UACrB,MAAM,IAAI;AAAA,UACV,WAAW,CAAC;AAAA,QACd;AACA,YAAI,OAAO,IAAI,gBAAgB,YAAa,YAAW,cAAc,IAAI;AACzE,YAAI,OAAO,IAAI,eAAe,YAAa,YAAW,aAAa,IAAI;AACvE,uBAAe,KAAK,UAAU;AAC9B;AAAA,MACF;AAEA,UAAI,OAAiB,CAAC;AACtB,UAAI,UAAoB,CAAC;AACzB,UAAI,SAAwC,CAAC;AAE7C,eAAS,KAAK,GAAG,KAAK,KAAK,QAAQ,MAAM;AACvC,YAAI,MAAM,KAAK,EAAE;AACjB,YAAI,WAAW,GAAG,GAAG;AACnB,eAAK,KAAK,GAAG;AACb,iBAAO,GAAG,IAAI,IAAI,UAAU,GAAG;AAAA,QACjC,OAAO;AACL,kBAAQ,KAAK,GAAG;AAAA,QAClB;AAAA,MACF;AAEA,UAAI,KAAK,WAAW,GAAG;AACrB,sBAAc,KAAK;AAAA,UACjB,MAAM,IAAI,KAAK,KAAK,GAAG;AAAA,UACvB,iBAAiB,QAAQ,MAAM;AAAA,UAC/B,cAAc,CAAC;AAAA,UACf,QAAQ;AAAA,QACV,CAAC;AACD;AAAA,MACF;AAEA,UAAI,QAAQ,SAAS,GAAG;AACtB,sBAAc,KAAK;AAAA,UACjB,MAAM,IAAI,KAAK,KAAK,GAAG;AAAA,UACvB,iBAAiB,QAAQ,MAAM;AAAA,UAC/B,cAAc,KAAK,MAAM;AAAA,UACzB,QAAQ;AAAA,QACV,CAAC;AAAA,MACH;AAEA,UAAI,QAAmB;AAAA,QACrB,MAAM,IAAI,KAAK,MAAM;AAAA,QACrB,MAAM,IAAI;AAAA,QACV,WAAW;AAAA,MACb;AACA,UAAI,OAAO,IAAI,gBAAgB,YAAa,OAAM,cAAc,IAAI;AACpE,UAAI,OAAO,IAAI,eAAe,YAAa,OAAM,aAAa,IAAI;AAClE,qBAAe,KAAK,KAAK;AAAA,IAC3B;AAEA,kBAAc,KAAK,SAAU,GAAG,GAAG;AACjC,UAAI,EAAE,SAAS,EAAE,KAAM,QAAO;AAC9B,aAAO,EAAE,OAAO,EAAE,OAAO,KAAK;AAAA,IAChC,CAAC;AAED,WAAO;AAAA,MACL,OAAO,EAAE,QAAQ,eAAe;AAAA,MAChC,SAAS;AAAA,QACP,aAAa,MAAM,OAAO;AAAA,QAC1B,gBAAgB,eAAe;AAAA,QAC/B,eAAe;AAAA,QACf,mBAAmB,UAAU,MAAM,EAAE,KAAK;AAAA,QAC1C,iBAAiB;AAAA,QACjB,iBAAiB;AAAA,QACjB,0BAA0B;AAAA,QAC1B,oBAAoB;AAAA,QACpB,wBAAwB,gBAAgB,OAAO;AAAA,QAC/C,2BAA2B;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AAKA,iBAAsB,WAAW,MAAe,OAAmB,CAAC,GAA2B;AAQ7F,UAAM,UAAU,UAAU,aAAa,MAAM,EAAE,iBAAiB,CAAC,CAAC,KAAK,gBAAgB,CAAC,CAAC;AACzF,UAAM,WAAW,sBAAsB,SAAS,KAAK,YAAY,CAAC,CAAC;AACnE,UAAM,cAAc,MAAM,eAAe,SAAS,KAAK;AACvD,aAAS,QAAQ,gBAAgB,YAAY;AAC7C,WAAO,SAAS;AAAA,EAClB;AAIA,iBAAsB,WAAW,MAAyC;AACxE,QAAI,UAAU,MAAM,cAAc;AAClC,QAAI,QAAQ,UAAU,OAAO;AAC7B,QAAI,kBAAkB,CAAC,CAAC,KAAK;AAC7B,QAAI,aAAa,CAAC,CAAC,KAAK;AAExB,QAAI,KAAK,WAAW,cAAc;AAChC,UAAI,mBAAgC,CAAC;AACrC,eAAS,KAAK,GAAG,KAAK,MAAM,OAAO,QAAQ,MAAM;AAC/C,YAAI,MAAM,MAAM,OAAO,EAAE;AACzB,YAAI,IAAI,SAAS,cAAc;AAC7B,cAAI,YAAuB;AAAA,YACzB,MAAM,IAAI,KAAK,MAAM;AAAA,YACrB,MAAM,IAAI;AAAA,YACV,WAAW,CAAC;AAAA,UACd;AACA,cAAI,UAAUA,QAAO,IAAI,SAAS;AAClC,mBAAS,KAAK,GAAG,KAAK,QAAQ,QAAQ,MAAM;AAC1C,gBAAI,MAAM,QAAQ,EAAE;AACpB,sBAAU,UAAU,GAAG,IAAI,IAAI,UAAU,GAAG;AAAA,UAC9C;AACA,cAAI,OAAO,IAAI,gBAAgB,YAAa,WAAU,cAAc,IAAI;AACxE,cAAI,OAAO,IAAI,eAAe,YAAa,WAAU,aAAa,IAAI;AACtE,2BAAiB,KAAK,SAAS;AAAA,QACjC;AAAA,MACF;AAEA,UAAI,kBAA8B,EAAE,QAAQ,iBAAiB;AAC7D,UAAI,uBAAuB,UAAU,iBAAiB,EAAE,iBAAkC,WAAuB,CAAC;AAClH,UAAI,iBAAiB,qBAAqB;AAC1C,UAAI,CAAC,iBAAiB,QAAQ;AAC5B,yBAAiB,CAAC;AAAA,MACpB;AACA,aAAO,EAAE,OAAO,CAAC,EAAE,MAAM,mBAAmB,MAAM,eAAe,CAAC,EAAE;AAAA,IACtE;AAEA,QAAI,KAAK,WAAW,UAAU;AAE5B,UAAI,SAAS,UAAU,OAAO,EAAE,iBAAkC,WAAuB,CAAC;AAC1F,aAAO,EAAE,OAAO,CAAC,EAAE,MAAM,eAAe,MAAM,OAAO,KAAK,CAAC,EAAE;AAAA,IAC/D;AAGA,QAAI,WAAqB,CAAC;AAC1B,QAAI,IAAI;AACR,SAAK,IAAI,GAAG,IAAI,MAAM,OAAO,QAAQ,KAAK;AACxC,UAAI,IAAI,MAAM,OAAO,CAAC;AACtB,UAAI,KAAKA,QAAO,EAAE,SAAS;AAC3B,UAAI,IAAI;AACR,WAAK,IAAI,GAAG,IAAI,GAAG,QAAQ,KAAK;AAC9B,YAAI,IAAI,GAAG,CAAC;AAEZ,YAAI,QAAQ;AACZ,YAAI,IAAI;AACR,aAAK,IAAI,GAAG,IAAI,SAAS,QAAQ,IAAK,KAAI,SAAS,CAAC,MAAM,GAAG;AAAE,kBAAQ;AAAM;AAAA,QAAO;AACpF,YAAI,CAAC,MAAO,UAAS,KAAK,CAAC;AAAA,MAC7B;AAAA,IACF;AAGA,QAAI,QAAgD,CAAC;AACrD,QAAI,KAAK;AACT,SAAK,KAAK,GAAG,KAAK,SAAS,QAAQ,MAAM;AACvC,UAAI,MAAM,SAAS,EAAE;AAGrB,UAAI,WAAuB,EAAE,QAAQ,CAAC,EAAE;AACxC,UAAI,KAAK;AACT,WAAK,KAAK,GAAG,KAAK,MAAM,OAAO,QAAQ,MAAM;AAC3C,YAAI,MAAM,MAAM,OAAO,EAAE;AACzB,YAAI,MAAM,4BAA4B,KAAK,GAAG;AAC9C,YAAI,IAAK,UAAS,OAAO,KAAK,GAAG;AAAA,MACnC;AAGA,UAAI,SAAS,OAAO,WAAW,EAAG;AAElC,UAAI,MAAM,UAAU,UAAU,EAAE,iBAAkC,WAAuB,CAAC;AAI1F,UAAI,aAAa;AACjB,UAAI,OAAO;AAEX,UAAI,iBAAiB;AACrB,UAAI,WAAW;AACf,WAAK,KAAK,GAAG,KAAK,SAAS,OAAO,WAAW,CAAC,kBAAkB,CAAC,WAAW,MAAM;AAChF,YAAI,MAAM,SAAS,OAAO,EAAE;AAC5B,YAAI,CAAC,OAAO,CAAC,IAAI,WAAY;AAE7B,YAAI,WAAY,IAAI,WAAwC,WAAW;AAGvE,YAAI,CAAC,YAAY,OAAO,aAAa,SAAU;AAE/C,YAAI,SAAS,SAAS;AACtB,YAAI,CAAC,UAAU,OAAO,WAAW,SAAU;AAE3C,YAAI,UAAU,OAAO,GAAG;AACxB,YAAI,CAAC,WAAW,OAAO,YAAY,SAAU;AAE7C,YAAI,gBAAiB,QAAyC;AAC9D,YAAI,UAAW,QAAmC;AAElD,YAAI,OAAO,kBAAkB,YAAY,CAAC,gBAAgB;AACxD,uBAAa;AACb,2BAAiB;AAAA,QACnB;AACA,YAAI,OAAO,YAAY,YAAY,CAAC,UAAU;AAC5C,iBAAO;AACP,qBAAW;AAAA,QACb;AAAA,MACF;AAEA,UAAI,CAAC,kBAAkB,CAAC,UAAU;AAEhC,YAAI,QAAQ,IAAI,YAAY,GAAG;AAC/B,qBAAa,SAAS,IAAI,IAAI,UAAU,GAAG,KAAK,IAAI;AACpD,eAAO,SAAS,IAAI,IAAI,UAAU,QAAQ,CAAC,IAAI;AAAA,MACjD;AAEA,UAAI,QAAQ,gBAAgB,UAAU,IAAI,WAAW,gBAAgB,IAAI,IAAI;AAC7E,YAAM,KAAK,EAAE,MAAM,OAAO,MAAM,IAAI,KAAK,CAAC;AAAA,IAC5C;AAGA,QAAI,MAAM,WAAW,GAAG;AACtB,UAAI,WAAW,UAAU,OAAO,EAAE,iBAAkC,WAAuB,CAAC;AAC5F,YAAM,KAAK,EAAE,MAAM,eAAe,MAAM,SAAS,KAAK,CAAC;AAAA,IACzD;AAEA,WAAO,EAAE,MAAa;AAAA,EACxB;;;ACxYA,WAAS,UAAU,GAAQ,KAA4B;AACnD,QAAI;AACA,UAAI,KAAK,OAAO,EAAE,QAAQ,WAAY,QAAO,EAAE,IAAI,GAAG;AAAA,IAC1D,SAAQ;AAAA,IAAa;AACrB,WAAO;AAAA,EACX;AAQA,WAAS,UAAU,GAAgC;AAC/C,UAAM,eAAe,UAAU,GAAG,uBAAuB;AACzD,UAAM,WAAW,UAAU,GAAG,mBAAmB;AACjD,UAAM,OAAmB,CAAC;AAC1B,UAAM,MAAM,eAAe,SAAS,cAAc,EAAE,IAAI;AACxD,UAAM,MAAM,WAAW,SAAS,UAAU,EAAE,IAAI;AAChD,QAAI,OAAO,SAAS,GAAG,EAAG,MAAK,YAAY;AAC3C,QAAI,OAAO,SAAS,GAAG,EAAG,MAAK,gBAAgB;AAC/C,WAAQ,KAAK,cAAc,UAAa,KAAK,kBAAkB,SAAa,OAAO;AAAA,EACvF;AAGA,iBAAe,SAAS,KAA2B;AAC/C,QAAI;AAAE,aAAO,MAAM,IAAI,KAAK;AAAA,IAAG,SAAQ;AAAE,aAAO;AAAA,IAAI;AAAA,EACxD;AAGA,WAAS,IAAI,GAAmB;AAC5B,QAAI;AAGA,aAAO,KAAK,SAAS,mBAAmB,CAAC,CAAC,CAAC;AAAA,IAC/C,SAAQ;AAEJ,YAAM,MAAM,IAAI,YAAY;AAC5B,YAAM,QAAQ,IAAI,OAAO,CAAC;AAC1B,UAAI,MAAM;AACV,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,IAAK,QAAO,OAAO,aAAa,MAAM,CAAC,CAAC;AAC1E,aAAO,KAAK,GAAG;AAAA,IACnB;AAAA,EACJ;AAEA,MAAM,uBAAuB;AAE7B,WAAS,sBAAsB,MAA2E;AACtG,UAAM,YAAY,OAAO,QAAQ,EAAE,EAC9B,QAAQ,OAAO,GAAG,EAClB,QAAQ,WAAW,GAAG,EACtB,QAAQ,cAAc,EAAE;AAE7B,QAAI,CAAC,UAAW,QAAO,EAAE,IAAI,MAAM,MAAM,GAAG;AAE5C,UAAM,WAAW,UAAU,MAAM,GAAG,EAAE,OAAO,OAAO;AACpD,eAAW,OAAO,UAAU;AACxB,UAAI,CAAC,IAAK,QAAO,EAAE,IAAI,OAAO,SAAS,kCAAkC;AACzE,UAAI,QAAQ,OAAO,QAAQ,MAAM;AAC7B,eAAO,EAAE,IAAI,OAAO,SAAS,4CAA4C;AAAA,MAC7E;AACA,UAAI,qBAAqB,KAAK,GAAG,GAAG;AAChC,eAAO,EAAE,IAAI,OAAO,SAAS,mBAAmB,GAAG,iCAAiC;AAAA,MACxF;AAAA,IACJ;AAEA,WAAO,EAAE,IAAI,MAAM,MAAM,SAAS,KAAK,GAAG,EAAE;AAAA,EAChD;AAGA,WAAS,mBAAmB,MAAsB;AAC9C,UAAM,YAAY,sBAAsB,IAAI;AAC5C,QAAI,CAAC,UAAU,GAAI,OAAM,IAAI,MAAM,UAAU,OAAO;AACpD,QAAI,CAAC,UAAU,KAAM,QAAO;AAC5B,WAAO,UAAU,KAAK,MAAM,GAAG,EAAE,IAAI,kBAAkB,EAAE,KAAK,GAAG;AAAA,EACrE;AAGA,WAAS,mBAAmB,UAA0B;AAClD,UAAM,UAAU,OAAO,aAAa,WAAW,SAAS,KAAK,IAAI;AACjE,QAAI,CAAC,QAAS,QAAO;AACrB,UAAM,kBAAkB,QAAQ,QAAQ,QAAQ,EAAE;AAClD,QAAI,CAAC,gBAAiB,QAAO;AAE7B,UAAM,cAAc,CAAC,UAA8B;AAC/C,UAAI,OAAO,gBAAgB,aAAa;AACpC,YAAI;AACA,iBAAO,IAAI,YAAY,EAAE,OAAO,KAAK;AAAA,QACzC,SAAQ;AAAA,QAAe;AAAA,MAC3B;AACA,UAAI,OAAO;AACX,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,IAAK,SAAQ,OAAO,aAAa,MAAM,CAAC,CAAC;AAC3E,UAAI;AAEA,eAAO,mBAAmB,OAAO,IAAI,CAAC;AAAA,MAC1C,SAAQ;AACJ,eAAO;AAAA,MACX;AAAA,IACJ;AAEA,QAAI,OAAO,UAAU,eAAe,OAAO,MAAM,iBAAiB,YAAY;AAC1E,UAAI;AACA,eAAO,YAAY,MAAM,aAAa,eAAe,CAAC;AAAA,MAC1D,SAAQ;AAAA,MAAqB;AAAA,IACjC;AAEA,QAAI,OAAO,SAAS,YAAY;AAC5B,UAAI;AACA,cAAM,MAAM,KAAK,eAAe;AAChC,cAAM,QAAQ,IAAI,WAAW,IAAI,MAAM;AACvC,iBAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,IAAK,OAAM,CAAC,IAAI,IAAI,WAAW,CAAC;AAChE,eAAO,YAAY,KAAK;AAAA,MAC5B,SAAQ;AACJ,YAAI;AACA,iBAAO,mBAAmB,OAAO,KAAK,eAAe,CAAC,CAAC;AAAA,QAC3D,SAAQE,IAAA;AAAA,QAAe;AAAA,MAC3B;AAAA,IACJ;AAEA,UAAM,cAAe,WAAwG;AAC7H,QAAI,eAAe,OAAO,YAAY,SAAS,YAAY;AACvD,UAAI;AACA,eAAO,YAAY,KAAK,iBAAiB,QAAQ,EAAE,SAAS,MAAM;AAAA,MACtE,SAAQ;AAAA,MAAe;AAAA,IAC3B;AAEA,WAAO;AAAA,EACX;AAOA,iBAAsB,UAAU,OAAsC;AAClE,QAAI;AACA,YAAM,MAAM,MAAM,MAAM,+BAA+B;AAAA,QACnD,QAAQ;AAAA,QACR,SAAS;AAAA,UACL,iBAAiB,UAAU,KAAK;AAAA,UAChC,UAAU;AAAA,UACV,wBAAwB;AAAA,QAC5B;AAAA,MACJ,CAAC;AACD,UAAI,IAAI,WAAW,IAAK,QAAO,EAAE,IAAI,OAAO,OAAO,kBAAkB;AACrE,UAAI,CAAC,IAAI,GAAI,QAAO,EAAE,IAAI,OAAO,OAAO,QAAQ,IAAI,MAAM,GAAG;AAE7D,YAAM,OAAO,MAAM,IAAI,KAAK;AAC5B,YAAM,QAAQ,QAAO,6BAAM,WAAU,WAAW,KAAK,QAAQ;AAC7D,YAAM,OAAO,QAAO,6BAAM,UAAS,WAAW,KAAK,OAAO;AAC1D,UAAI,CAAC,MAAO,QAAO,EAAE,IAAI,OAAO,OAAO,yBAAyB;AAChE,aAAO,EAAE,IAAI,MAAM,MAAM,EAAE,OAAO,KAAK,EAAE;AAAA,IAC7C,SAAS,GAAG;AACR,aAAO,EAAE,IAAI,OAAO,QAAQ,uBAAa,YAAW,gBAAgB;AAAA,IACxE;AAAA,EACJ;AAkBA,iBAAe,mBAAmB,KAAa,MAAW,QAAQ,GAAG;AACjE,QAAI;AACJ,aAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC5B,UAAI;AAAE,eAAO,MAAM,MAAM,KAAK,IAAI;AAAA,MAAG,SAC9B,GAAG;AAAE,eAAO;AAAG,cAAM,IAAI,QAAQ,OAAK,WAAW,GAAG,GAAG,CAAC;AAAA,MAAG;AAAA,IACtE;AACA,UAAM;AAAA,EACV;AAGA,iBAAsB,YAAY,OAA2C;AACzE,QAAI;AACA,YAAM,OACF;AAGJ,YAAM,UAAU;AAAA,QACZ,iBAAiB,UAAU,KAAK;AAAA,QAChC,UAAU;AAAA,QACV,wBAAwB;AAAA,MAC5B;AAEA,YAAM,MAAgB,CAAC;AACvB,UAAI,OAAO;AAEX,aAAO,MAAM;AACT,cAAM,MAAM,MAAM,mBAAmB,GAAG,IAAI,SAAS,IAAI,IAAI,EAAE,QAAQ,GAAG,CAAC;AAC3E,YAAI,IAAI,WAAW,IAAK,QAAO,EAAE,IAAI,OAAO,OAAO,kBAAkB;AACrE,YAAI,CAAC,IAAI,IAAI;AACT,cAAI,IAAI,OAAQ,QAAO,EAAE,IAAI,MAAM,OAAO,IAAI;AAC9C,iBAAO,EAAE,IAAI,OAAO,OAAQ,MAAM,IAAI,KAAK,KAAM,QAAQ,IAAI,MAAM,GAAG;AAAA,QAC1E;AAEA,cAAM,MAAM,MAAM,IAAI,KAAK;AAC3B,YAAI,CAAC,MAAM,QAAQ,GAAG,KAAK,IAAI,WAAW,EAAG;AAE7C,mBAAW,KAAK,KAAK;AACjB,cAAI,uBAAG,WAAW;AACd,gBAAI,KAAK;AAAA,cACL,IAAI,EAAE;AAAA,cACN,MAAM,EAAE;AAAA,cACR,WAAW,EAAE;AAAA,cACb,SAAS,CAAC,CAAC,EAAE;AAAA,cACb,gBAAgB,EAAE,kBAAkB;AAAA,cACpC,OAAO,EAAE;AAAA,cACT,aAAa,EAAE;AAAA,cACf,MAAM,EAAE;AAAA,YACZ,CAAC;AAAA,UACL;AAAA,QACJ;AAEA,YAAI,IAAI,SAAS,IAAK;AACtB;AAAA,MACJ;AAEA,aAAO,EAAE,IAAI,MAAM,OAAO,IAAI;AAAA,IAClC,SAAS,GAAG;AACR,aAAO,EAAE,IAAI,OAAO,QAAQ,uBAAa,YAAW,gBAAgB;AAAA,IACxE;AAAA,EACJ;AA6BA,iBAAsB,eAClB,OACA,OACA,MACA,OAAO,GACP,QAAQ,OACqB;AAC7B,UAAM,cAAc,gCAAgC,KAAK,IAAI,IAAI;AACjE,UAAM,UAAU;AAAA,MACZ,iBAAiB,UAAU,KAAK;AAAA,MAChC,UAAU;AAAA,MACV,wBAAwB;AAAA,IAC5B;AAEA,UAAM,KAAK,QAAQ,QAAQ,KAAK,IAAI,CAAC,KAAK;AAE1C,QAAI;AACA,YAAM,cAAc,GAAG,WAAW,+BAA+B,IAAI,GAAG,EAAE;AAC1E,YAAM,MAAM,MAAM,MAAM,aAAa,EAAE,QAAQ,CAAC;AAEhD,YAAM,OAAO,UAAW,2BAAa,OAAO;AAC5C,YAAM,OAAO,UAAW,2BAAa,SAAS,eAAe;AAE7D,UAAI,IAAI,WAAW,OAAO,MAAM;AAC5B,eAAO;AAAA,UACH,IAAI;AAAA,UAAO;AAAA,UAAO;AAAA,UAAM,QAAQ;AAAA,UAChC,SAAS;AAAA,UAAqB,cAAc;AAAA,UAAM;AAAA,QACtD;AAAA,MACJ;AAEA,UAAI,CAAC,IAAI,IAAI;AACT,cAAM,OAAO,MAAM,SAAS,GAAG;AAC/B,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,IAAI,QAAQ,SAAS,QAAQ,QAAQ,IAAI,MAAM,IAAI,KAAK;AAAA,MACrG;AAEA,YAAM,MAAM,MAAM,IAAI,KAAK;AAC3B,YAAM,WAAoC,MAAM,QAAQ,GAAG,IACrD,IAAI,OAAO,OAAK,KAAK,OAAO,EAAE,SAAS,QAAQ,EAAE,IAAI,QAAM,EAAE,MAAM,EAAE,KAAK,EAAE,IAC5E,CAAC;AAEP,YAAM,OAAO,UAAW,2BAAa,SAAS,MAAM;AACpD,UAAI,UAAU;AACd,UAAI,QAAQ,gBAAgB,KAAK,IAAI,EAAG,WAAU;AAAA,eACzC,SAAS,WAAW,IAAK,WAAU;AAE5C,UAAI;AACJ,UAAI,SAAS,GAAG;AACZ,YAAI;AACA,gBAAM,UAAU,MAAM,MAAM,GAAG,WAAW,GAAG,QAAQ,QAAQ,KAAK,IAAI,CAAC,KAAK,EAAE,IAAI,EAAE,QAAQ,CAAC;AAC7F,cAAI,QAAQ,IAAI;AACZ,kBAAM,IAAI,MAAM,QAAQ,KAAK;AAC7B,gBAAI,KAAK,OAAO,EAAE,mBAAmB,SAAU,iBAAgB,EAAE;AAAA,UACrE;AAAA,QACJ,SAAQ;AAAA,QAAe;AAAA,MAC3B;AAEA,aAAO,EAAE,IAAI,MAAM,OAAO,MAAM,MAAM,UAAU,eAAe,SAAS,KAAK;AAAA,IACjF,SAAS,GAAG;AACR,aAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,GAAG,UAAU,uBAAa,YAAW,gBAAgB;AAAA,IAClG;AAAA,EACJ;AA2BA,iBAAsB,eAClB,OACA,OACA,MACA,WACA,YAC6B;AArXjC;AAsXI,UAAM,cAAc,gCAAgC,KAAK,IAAI,IAAI;AACjE,UAAM,UAAU;AAAA,MACZ,iBAAiB,UAAU,KAAK;AAAA,MAChC,UAAU;AAAA,MACV,wBAAwB;AAAA,IAC5B;AAEA,UAAM,aAAa,OAAO,aAAa,EAAE,EAAE,KAAK,EAAE,QAAQ,kBAAkB,EAAE;AAC9E,UAAM,WAAW,OAAO,cAAc,EAAE,EAAE,KAAK,EAAE,QAAQ,kBAAkB,EAAE;AAC7E,QAAI,CAAC,cAAc,CAAC,UAAU;AAC1B,aAAO,EAAE,IAAI,OAAO,OAAO,MAAM,YAAY,UAAU,WAAW,YAAY,QAAQ,KAAK,SAAS,uBAAuB;AAAA,IAC/H;AAEA,QAAI;AAEA,UAAI;AACA,cAAM,UAAU,MAAM,MAAM,aAAa,EAAE,QAAQ,CAAC;AACpD,cAAM,QAAQ,UAAW,mCAAiB,OAAO;AACjD,cAAM,QAAQ,UAAW,mCAAiB,SAAS,eAAe;AAClE,YAAI,QAAQ,WAAW,OAAO,OAAO;AACjC,iBAAO,EAAE,IAAI,OAAO,OAAO,MAAM,YAAY,UAAU,WAAW,YAAY,QAAQ,KAAK,SAAS,qBAAqB,cAAc,MAAM,MAAM,MAAM;AAAA,QAC7J;AACA,YAAI,CAAC,QAAQ,IAAI;AACb,gBAAM,OAAO,MAAM,SAAS,OAAO;AACnC,iBAAO,EAAE,IAAI,OAAO,OAAO,MAAM,YAAY,UAAU,WAAW,YAAY,QAAQ,QAAQ,QAAQ,SAAS,QAAQ,QAAQ,QAAQ,MAAM,GAAG;AAAA,QACpJ;AACA,cAAM,WAAW,MAAM,QAAQ,KAAK;AACpC,cAAM,cAAc,CAAC,GAAE,0CAAU,gBAAV,mBAAuB;AAC9C,aAAI,qCAAU,gBAAe,gBAAgB,MAAM;AAC/C,iBAAO,EAAE,IAAI,OAAO,OAAO,MAAM,YAAY,UAAU,WAAW,YAAY,QAAQ,KAAK,SAAS,uDAAuD,kBAAkB,MAAM,MAAM,MAAM;AAAA,QACnM;AAAA,MACJ,SAAQ;AAAA,MAAe;AAGvB,YAAM,SAAS,GAAG,WAAW,kBAAkB,mBAAmB,QAAQ,CAAC;AAC3E,YAAM,SAAS,MAAM,MAAM,QAAQ,EAAE,QAAQ,CAAC;AAC9C,YAAM,QAAQ,UAAW,iCAAgB,OAAO;AAChD,YAAM,QAAQ,UAAW,iCAAgB,SAAS,eAAe;AAEjE,UAAI,OAAO,WAAW,OAAO,OAAO;AAChC,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,YAAY,UAAU,WAAW,YAAY,QAAQ,KAAK,SAAS,qBAAqB,cAAc,MAAM,MAAM,MAAM;AAAA,MAC7J;AACA,UAAI,CAAC,OAAO,IAAI;AACZ,cAAM,OAAO,MAAM,SAAS,MAAM;AAClC,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,YAAY,UAAU,WAAW,YAAY,QAAQ,OAAO,QAAQ,SAAS,QAAQ,QAAQ,OAAO,MAAM,IAAI,MAAM,MAAM;AAAA,MAC/J;AAEA,YAAM,UAAU,MAAM,OAAO,KAAK;AAClC,YAAM,SAAO,wCAAS,WAAT,mBAAiB,SAAO,mCAAS,QAAO,IAAI,KAAK;AAC9D,UAAI,CAAC,KAAK;AACN,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,YAAY,UAAU,WAAW,YAAY,QAAQ,KAAK,SAAS,6BAA6B;AAAA,MACrI;AAGA,YAAM,YAAY,GAAG,WAAW;AAChC,YAAM,OAAO,KAAK,UAAU,EAAE,KAAK,cAAc,UAAU,IAAI,IAAI,CAAC;AACpE,YAAM,YAAY,MAAM,MAAM,WAAW,EAAE,QAAQ,QAAQ,SAAS,KAAK,CAAC;AAC1E,YAAM,QAAQ,UAAW,uCAAmB,OAAO;AACnD,YAAM,QAAQ,UAAW,uCAAmB,SAAS,eAAe;AAEpE,UAAI,UAAU,WAAW,OAAO,OAAO;AACnC,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,YAAY,UAAU,WAAW,YAAY,QAAQ,KAAK,SAAS,qBAAqB,cAAc,MAAM,MAAM,MAAM;AAAA,MAC7J;AACA,UAAI,CAAC,UAAU,IAAI;AACf,cAAM,OAAO,MAAM,SAAS,SAAS;AACrC,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,YAAY,UAAU,WAAW,YAAY,QAAQ,UAAU,QAAQ,SAAS,QAAQ,QAAQ,UAAU,MAAM,IAAI,MAAM,MAAM;AAAA,MACrK;AAEA,YAAM,WAAW,sBAAsB,KAAK,IAAI,IAAI,SAAS,mBAAmB,UAAU,CAAC;AAC3F,aAAO,EAAE,IAAI,MAAM,OAAO,MAAM,YAAY,UAAU,WAAW,YAAY,KAAK,UAAU,MAAM,MAAM;AAAA,IAC5G,SAAS,GAAG;AACR,aAAO,EAAE,IAAI,OAAO,OAAO,MAAM,YAAY,UAAU,WAAW,YAAY,QAAQ,GAAG,UAAU,uBAAa,YAAW,gBAAgB;AAAA,IAC/I;AAAA,EACJ;AAmCA,iBAAsB,UAClB,OACA,OACA,MACA,MACA,KACwB;AACxB,UAAM,cAAc,gCAAgC,KAAK,IAAI,IAAI;AACjE,UAAM,YAAY,sBAAsB,IAAI;AAC5C,QAAI,CAAC,UAAU,IAAI;AACf,aAAO;AAAA,QACH,IAAI;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,QACA,MAAM,OAAO,QAAQ,EAAE,EAAE,QAAQ,cAAc,EAAE;AAAA,QACjD,QAAQ;AAAA,QACR,SAAS,UAAU;AAAA,MACvB;AAAA,IACJ;AACA,UAAM,MAAM,UAAU,OAChB,UAAU,KAAK,MAAM,GAAG,EAAE,IAAI,kBAAkB,EAAE,KAAK,GAAG,IAC1D;AACN,UAAMC,iBAAgB,UAAU;AAChC,UAAM,MAAM,MACN,GAAG,WAAW,aAAa,GAAG,QAAQ,mBAAmB,GAAG,CAAC,QAAQ,KAAK,IAAI,CAAC,KAC/E,GAAG,WAAW,iBAAiB,mBAAmB,GAAG,CAAC,QAAQ,KAAK,IAAI,CAAC;AAC9E,UAAM,UAAU;AAAA,MACZ,iBAAiB,UAAU,KAAK;AAAA,MAChC,UAAU;AAAA,MACV,wBAAwB;AAAA,IAC5B;AAEA,QAAI;AACA,YAAM,MAAM,MAAM,MAAM,KAAK,EAAE,QAAQ,CAAC;AACxC,YAAM,OAAO,UAAW,2BAAa,OAAO;AAC5C,UAAI,CAAC,IAAI,IAAI;AACT,cAAM,MAAM,MAAM,SAAS,GAAG;AAC9B,eAAO;AAAA,UACH,IAAI;AAAA,UACJ;AAAA,UAAO;AAAA,UAAM;AAAA,UAAK,MAAMA;AAAA,UACxB,QAAQ,IAAI;AAAA,UACZ,SAAS,OAAO,QAAQ,IAAI,MAAM;AAAA,UAClC;AAAA,QACJ;AAAA,MACJ;AACA,YAAM,OAAO,MAAM,IAAI,KAAK;AAC5B,UAAI,CAAC,MAAM,QAAQ,IAAI,GAAG;AACtB,cAAM,OAAO,QAAO,6BAAM,UAAS,WAAW,KAAK,OAAO;AAC1D,cAAM,SAAS,SAAS,SAAS,MAAM;AACvC,cAAM,UAAU,SAAS,SACnB,0CACA;AACN,eAAO;AAAA,UACH,IAAI;AAAA,UACJ;AAAA,UAAO;AAAA,UAAM;AAAA,UACb,MAAMA;AAAA,UACN;AAAA,UACA;AAAA,UACA;AAAA,QACJ;AAAA,MACJ;AACA,YAAM,UAAwB,KAAK,IAAI,CAAC,QAAa;AAAA,QACjD,OAAM,yBAAI,UAAS,QAAQ,QAAQ;AAAA,QACnC,MAAM,QAAO,yBAAI,SAAQ,EAAE;AAAA,QAC3B,MAAM,QAAO,yBAAI,SAAQ,EAAE;AAAA,MAC/B,EAAE;AACF,aAAO;AAAA,QACH,IAAI;AAAA,QACJ;AAAA,QAAO;AAAA,QAAM;AAAA,QACb,MAAMA;AAAA,QACN;AAAA,QACA;AAAA,MACJ;AAAA,IACJ,SAAS,GAAG;AACR,aAAO;AAAA,QACH,IAAI;AAAA,QACJ;AAAA,QAAO;AAAA,QAAM;AAAA,QACb,MAAMA;AAAA,QACN,QAAQ;AAAA,QACR,UAAU,uBAAa,YAAW;AAAA,MACtC;AAAA,IACJ;AAAA,EACJ;AA2BA,iBAAsB,WAClB,OACA,OACA,MACA,QACA,OAAO,IACkB;AACzB,UAAM,MAAM,MAAM,UAAU,OAAO,OAAO,MAAM,MAAM,MAAM;AAC5D,QAAI,CAAC,IAAI,IAAI;AACT,aAAO;AAAA,QACH,IAAI;AAAA,QACJ;AAAA,QAAO;AAAA,QAAM;AAAA,QACb,MAAM,IAAI;AAAA,QACV,QAAQ,IAAI;AAAA,QACZ,SAAS,IAAI;AAAA,QACb,cAAc,YAAY,KAAK,IAAI,WAAW,EAAE,KAAK,IAAI,WAAW;AAAA,MACxE;AAAA,IACJ;AACA,UAAM,WAAW,IAAI,QAAQ,OAAO,OAAK,EAAE,SAAS,KAAK;AACzD,WAAO;AAAA,MACH,IAAI;AAAA,MACJ;AAAA,MAAO;AAAA,MAAM;AAAA,MACb,MAAM,IAAI;AAAA,MACV,SAAS;AAAA,MACT,MAAM,SAAS,IAAI,QAAM,EAAE,MAAM,EAAE,MAAM,MAAM,EAAE,KAAK,EAAE;AAAA,MACxD,MAAM,IAAI;AAAA,IACd;AAAA,EACJ;AA8BA,iBAAsB,eAClB,OACA,OACA,MACA,QACA,YAC6B;AA/oBjC;AAgpBI,UAAM,cAAc,gCAAgC,KAAK,IAAI,IAAI;AACjE,UAAM,UAAU;AAAA,MACZ,iBAAiB,UAAU,KAAK;AAAA,MAChC,UAAU;AAAA,MACV,wBAAwB;AAAA,IAC5B;AAEA,UAAM,YAAY,sBAAsB,UAAU;AAClD,QAAI,CAAC,UAAU,IAAI;AACf,aAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,YAAY,IAAI,QAAQ,KAAK,SAAS,UAAU,QAAQ;AAAA,IACrG;AACA,UAAM,OAAO,UAAU;AACvB,QAAI,CAAC,MAAM;AACP,aAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,YAAY,MAAM,QAAQ,KAAK,SAAS,oBAAoB;AAAA,IACzG;AAEA,QAAI;AAEA;AACI,cAAM,MAAM,mBAAmB,IAAI;AACnC,cAAM,MAAM,GAAG,WAAW,aAAa,GAAG,QAAQ,mBAAmB,MAAM,CAAC,QAAQ,KAAK,IAAI,CAAC;AAC9F,cAAM,MAAM,MAAM,MAAM,KAAK,EAAE,QAAQ,CAAC;AACxC,cAAM,OAAO,UAAW,2BAAa,OAAO;AAC5C,cAAM,OAAO,UAAW,2BAAa,SAAS,eAAe;AAE7D,YAAI,IAAI,WAAW,OAAO,MAAM;AAC5B,iBAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,YAAY,MAAM,QAAQ,KAAK,SAAS,qBAAqB,cAAc,MAAM,KAAK;AAAA,QACnI;AAEA,YAAI,IAAI,IAAI;AACR,iBAAO;AAAA,YACH,IAAI;AAAA,YACJ;AAAA,YAAO;AAAA,YAAM;AAAA,YACb,YAAY;AAAA,YACZ,SAAS;AAAA,YACT,UAAU,sBAAsB,KAAK,IAAI,IAAI,SAAS,mBAAmB,MAAM,CAAC,IAAI,mBAAmB,IAAI,CAAC;AAAA,YAC5G;AAAA,UACJ;AAAA,QACJ;AACA,YAAI,IAAI,WAAW,KAAK;AACpB,gBAAM,OAAO,MAAM,SAAS,GAAG;AAC/B,iBAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,YAAY,MAAM,QAAQ,IAAI,QAAQ,SAAS,QAAQ,QAAQ,IAAI,MAAM,IAAI,KAAK;AAAA,QAC/H;AAAA,MACJ;AAGA,YAAM,iBAAiB,GAAG,IAAI;AAC9B,YAAM,SAAS,GAAG,WAAW,aAAa,mBAAmB,cAAc,CAAC;AAC5E,YAAM,OAAO,KAAK,UAAU;AAAA,QACxB,SAAS,wBAAwB,IAAI;AAAA,QACrC,SAAS,IAAI,GAAG;AAAA,QAChB;AAAA,MACJ,CAAC;AAED,YAAM,SAAS,MAAM,MAAM,QAAQ,EAAE,QAAQ,OAAO,SAAS,KAAK,CAAC;AACnE,YAAM,QAAQ,UAAW,iCAAgB,OAAO;AAChD,YAAM,QAAQ,UAAW,iCAAgB,SAAS,eAAe;AAEjE,UAAI,OAAO,WAAW,OAAO,OAAO;AAChC,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,YAAY,MAAM,QAAQ,KAAK,SAAS,qBAAqB,cAAc,MAAM,MAAM,MAAM;AAAA,MAC1I;AACA,UAAI,CAAC,OAAO,IAAI;AACZ,cAAM,OAAO,MAAM,SAAS,MAAM;AAClC,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,YAAY,MAAM,QAAQ,OAAO,QAAQ,SAAS,QAAQ,QAAQ,OAAO,MAAM,IAAI,MAAM,MAAM;AAAA,MAC5I;AAEA,YAAM,IAAI,MAAM,OAAO,KAAK;AAC5B,YAAM,YAAU,4BAAG,YAAH,mBAAY,UAAO,4BAAG,WAAH,mBAAW,QAAO;AAErD,aAAO;AAAA,QACH,IAAI;AAAA,QACJ;AAAA,QAAO;AAAA,QAAM;AAAA,QACb,YAAY;AAAA,QACZ,SAAS;AAAA,QACT;AAAA,QACA,UAAU,sBAAsB,KAAK,IAAI,IAAI,SAAS,mBAAmB,MAAM,CAAC,IAAI,mBAAmB,IAAI,CAAC;AAAA,QAC5G,MAAM;AAAA,MACV;AAAA,IACJ,SAAS,GAAG;AACR,aAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,YAAY,MAAM,QAAQ,GAAG,UAAU,uBAAa,YAAW,gBAAgB;AAAA,IAC5H;AAAA,EACJ;AAqCA,iBAAsB,cAClB,OACA,OACA,MACA,QACA,SACA,OAC4B;AA7wBhC;AA8wBI,UAAM,OAAO,gCAAgC,KAAK,IAAI,IAAI;AAC1D,UAAM,UAAU;AAAA,MACZ,eAAe,UAAU,KAAK;AAAA,MAC9B,QAAQ;AAAA,MACR,wBAAwB;AAAA,IAC5B;AAEA,aAAS,SAAS,GAAmB;AACjC,YAAM,YAAY,sBAAsB,CAAC;AACzC,UAAI,CAAC,UAAU,GAAI,OAAM,IAAI,MAAM,UAAU,OAAO;AACpD,aAAO,UAAU;AAAA,IACrB;AAEA,UAAM,UAA0B,CAAC;AACjC,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,YAAM,MAAM,MAAM,CAAC;AACnB,UAAI;AACJ,UAAI;AACA,yBAAiB,SAAS,IAAI,IAAI;AAAA,MACtC,SAAS,KAAK;AACV,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,QAAQ,KAAK,UAAU,2BAAe,YAAW,eAAe;AAAA,MAC7G;AACA,UAAI,CAAC,eAAgB;AACrB,UAAI,OAAO,IAAI,YAAY,SAAU;AACrC,cAAQ,KAAK;AAAA,QACT,MAAM;AAAA,QACN,SAAS,IAAI;AAAA,QACb,MAAM,IAAI,QAAQ;AAAA,MACtB,CAAC;AAAA,IACL;AAEA,QAAI,QAAQ,WAAW,GAAG;AACtB,aAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,QAAQ,KAAK,SAAS,qBAAqB;AAAA,IACxF;AAEA,QAAI;AAEA,YAAM,YAAY,OAAO,KAAK,IAAI,CAAC;AACnC,YAAM,SAAS,MAAM,MAAM,GAAG,IAAI,kBAAkB,mBAAmB,MAAM,CAAC,IAAI,SAAS,IAAI,EAAE,QAAQ,CAAC;AAC1G,YAAM,QAAQ,UAAW,iCAAgB,OAAO;AAChD,UAAI,CAAC,OAAO,IAAI;AACZ,cAAM,OAAO,MAAM,SAAS,MAAM;AAClC,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,QAAQ,OAAO,QAAQ,SAAS,QAAQ,QAAQ,OAAO,MAAM,IAAI,MAAM,MAAM;AAAA,MAC1H;AACA,YAAM,UAAU,MAAM,OAAO,KAAK;AAClC,YAAM,mBAAyB,wCAAS,WAAT,mBAAiB,SAAO,mCAAS,QAAO,IAAI,KAAK;AAChF,UAAI,CAAC,eAAe;AAChB,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,QAAQ,KAAK,SAAS,uCAAuC,MAAM,MAAM;AAAA,MACtH;AAGA,YAAM,YAAY,MAAM,MAAM,GAAG,IAAI,gBAAgB,aAAa,IAAI,SAAS,IAAI,EAAE,QAAQ,CAAC;AAC9F,YAAM,QAAQ,UAAW,uCAAmB,OAAO;AACnD,UAAI,CAAC,UAAU,IAAI;AACf,cAAM,OAAO,MAAM,SAAS,SAAS;AACrC,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,QAAQ,UAAU,QAAQ,SAAS,QAAQ,QAAQ,UAAU,MAAM,IAAI,MAAM,MAAM;AAAA,MAChI;AACA,YAAM,aAAa,MAAM,UAAU,KAAK;AACxC,YAAM,iBAAuB,8CAAY,SAAZ,mBAAkB,QAAO,IAAI,KAAK;AAC/D,UAAI,CAAC,aAAa;AACd,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,QAAQ,KAAK,SAAS,mCAAmC,MAAM,MAAM;AAAA,MAClH;AAGA,YAAM,WAAqB,CAAC;AAC5B,eAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACrC,cAAM,UAAU,MAAM,MAAM,GAAG,IAAI,cAAc;AAAA,UAC7C,QAAQ;AAAA,UACR;AAAA,UACA,MAAM,KAAK,UAAU,EAAE,SAAS,QAAQ,CAAC,EAAE,SAAS,UAAU,QAAQ,CAAC;AAAA,QAC3E,CAAC;AACD,cAAM,QAAQ,UAAW,mCAAiB,OAAO;AACjD,YAAI,CAAC,QAAQ,IAAI;AACb,gBAAM,OAAO,MAAM,SAAS,OAAO;AACnC,iBAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,QAAQ,QAAQ,QAAQ,SAAS,QAAQ,QAAQ,QAAQ,MAAM,IAAI,MAAM,MAAM;AAAA,QAC5H;AACA,cAAM,WAAW,MAAM,QAAQ,KAAK;AACpC,cAAM,YAAmB,qCAAU,QAAO,IAAI,KAAK;AACnD,YAAI,CAAC,SAAS;AACV,iBAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,QAAQ,KAAK,SAAS,4BAA4B;AAAA,QAC/F;AACA,iBAAS,KAAK,OAAO;AAAA,MACzB;AAGA,YAAM,cAAc,QAAQ,IAAI,CAAC,GAAG,SAAS;AAAA,QACzC,MAAM,EAAE;AAAA,QAAM,MAAM;AAAA,QAAQ,MAAM,EAAE;AAAA,QAAO,KAAK,SAAS,GAAG;AAAA,MAChE,EAAE;AACF,YAAM,UAAU,MAAM,MAAM,GAAG,IAAI,cAAc;AAAA,QAC7C,QAAQ;AAAA,QACR;AAAA,QACA,MAAM,KAAK,UAAU,EAAE,WAAW,aAAa,MAAM,YAAY,CAAC;AAAA,MACtE,CAAC;AACD,YAAM,QAAQ,UAAW,mCAAiB,OAAO;AACjD,UAAI,CAAC,QAAQ,IAAI;AACb,cAAM,OAAO,MAAM,SAAS,OAAO;AACnC,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,QAAQ,QAAQ,QAAQ,SAAS,QAAQ,QAAQ,QAAQ,MAAM,IAAI,MAAM,MAAM;AAAA,MAC5H;AACA,YAAM,WAAW,MAAM,QAAQ,KAAK;AACpC,YAAM,eAAsB,qCAAU,QAAO,IAAI,KAAK;AACtD,UAAI,CAAC,YAAY;AACb,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,QAAQ,KAAK,SAAS,4BAA4B;AAAA,MAC/F;AAGA,YAAM,kBAAkB,MAAM,MAAM,GAAG,IAAI,gBAAgB;AAAA,QACvD,QAAQ;AAAA,QACR;AAAA,QACA,MAAM,KAAK,UAAU,EAAE,SAAS,MAAM,YAAY,SAAS,CAAC,aAAa,EAAE,CAAC;AAAA,MAChF,CAAC;AACD,YAAM,QAAQ,UAAW,mDAAyB,OAAO;AACzD,UAAI,CAAC,gBAAgB,IAAI;AACrB,cAAM,OAAO,MAAM,SAAS,eAAe;AAC3C,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,QAAQ,gBAAgB,QAAQ,SAAS,QAAQ,QAAQ,gBAAgB,MAAM,IAAI,MAAM,MAAM;AAAA,MAC5I;AACA,YAAM,YAAY,MAAM,gBAAgB,KAAK;AAC7C,YAAM,iBAAwB,uCAAW,QAAO,IAAI,KAAK;AACzD,UAAI,CAAC,cAAc;AACf,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,QAAQ,KAAK,SAAS,8BAA8B;AAAA,MACjG;AAGA,YAAM,eAAe,MAAM,MAAM,GAAG,IAAI,mBAAmB,mBAAmB,MAAM,CAAC,IAAI;AAAA,QACrF,QAAQ;AAAA,QACR;AAAA,QACA,MAAM,KAAK,UAAU,EAAE,KAAK,cAAc,OAAO,MAAM,CAAC;AAAA,MAC5D,CAAC;AACD,YAAM,QAAQ,UAAW,6CAAsB,OAAO;AACtD,UAAI,CAAC,aAAa,IAAI;AAClB,cAAM,OAAO,MAAM,SAAS,YAAY;AACxC,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,QAAQ,aAAa,QAAQ,SAAS,QAAQ,QAAQ,aAAa,MAAM,IAAI,MAAM,MAAM;AAAA,MACtI;AAEA,aAAO;AAAA,QACH,IAAI;AAAA,QACJ;AAAA,QAAO;AAAA,QAAM;AAAA,QACb,WAAW;AAAA,QACX,WAAW,sBAAsB,KAAK,IAAI,IAAI,WAAW,YAAY;AAAA,QACrE,SAAS,sBAAsB,KAAK,IAAI,IAAI,SAAS,mBAAmB,MAAM,CAAC;AAAA,QAC/E,MAAM;AAAA,MACV;AAAA,IACJ,SAAS,GAAG;AACR,aAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,QAAQ,GAAG,UAAU,uBAAa,YAAW,gBAAgB;AAAA,IAC1G;AAAA,EACJ;AAiCA,iBAAsB,kBAClB,OACA,OACA,MACA,QACA,MACgC;AAChC,UAAM,YAAY,sBAAsB,IAAI;AAC5C,QAAI,CAAC,UAAU,IAAI;AACf,aAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,MAAM,IAAI,QAAQ,KAAK,SAAS,UAAU,QAAQ;AAAA,IAC/F;AACA,QAAI,CAAC,UAAU,MAAM;AACjB,aAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,MAAM,IAAI,QAAQ,KAAK,SAAS,aAAa;AAAA,IAC1F;AACA,UAAM,YAAY,UAAU;AAC5B,UAAM,OAAO,gCAAgC,KAAK,IAAI,IAAI,aAAa,UAAU,MAAM,GAAG,EAAE,IAAI,kBAAkB,EAAE,KAAK,GAAG,CAAC;AAC7H,UAAM,MAAM,GAAG,IAAI,QAAQ,mBAAmB,MAAM,CAAC;AACrD,UAAM,UAAU;AAAA,MACZ,eAAe,UAAU,KAAK;AAAA,MAC9B,QAAQ;AAAA,MACR,wBAAwB;AAAA,IAC5B;AAEA,QAAI;AACA,YAAM,MAAM,MAAM,MAAM,KAAK,EAAE,QAAQ,CAAC;AACxC,YAAM,OAAO,UAAW,2BAAa,OAAO;AAC5C,YAAM,OAAO,UAAW,2BAAa,SAAS,eAAe;AAE7D,UAAI,IAAI,WAAW,OAAO,MAAM;AAC5B,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,MAAM,WAAW,QAAQ,KAAK,SAAS,qBAAqB,cAAc,MAAM,KAAK;AAAA,MAClI;AAEA,UAAI,CAAC,IAAI,IAAI;AACT,cAAMC,QAAO,MAAM,SAAS,GAAG;AAC/B,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,MAAM,WAAW,QAAQ,IAAI,QAAQ,SAASA,SAAQ,QAAQ,IAAI,MAAM,IAAI,KAAK;AAAA,MAC9H;AAEA,YAAM,OAAO,MAAM,IAAI,KAAK;AAC5B,UAAI,MAAM,QAAQ,IAAI,GAAG;AACrB,eAAO;AAAA,UACH,IAAI;AAAA,UACJ;AAAA,UACA;AAAA,UACA;AAAA,UACA,MAAM;AAAA,UACN,QAAQ;AAAA,UACR,SAAS;AAAA,UACT;AAAA,UACA,aAAa;AAAA,QACjB;AAAA,MACJ;AAEA,YAAM,WAAW,QAAO,6BAAM,cAAa,WAAW,KAAK,WAAW;AACtE,YAAM,UAAU,QAAO,6BAAM,aAAY,WAAW,KAAK,UAAU;AACnE,YAAM,MAAM,QAAO,6BAAM,SAAQ,WAAW,KAAK,MAAM;AACvD,YAAM,OAAO,QAAO,6BAAM,UAAS,WAAW,KAAK,OAAO;AAE1D,UAAI,CAAC,SAAS;AACV,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,MAAM,WAAW,QAAQ,KAAK,SAAS,uBAAuB,KAAK;AAAA,MAChH;AAEA,UAAI,OAAO;AACX,UAAI,aAAa,UAAU;AACvB,eAAO,mBAAmB,QAAQ,QAAQ,QAAQ,EAAE,CAAC;AAAA,MACzD;AAEA,aAAO;AAAA,QACH,IAAI;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,QACA,MAAM;AAAA,QACN;AAAA,QACA;AAAA,QACA,aAAa;AAAA,QACb;AAAA,QACA;AAAA,MACJ;AAAA,IACJ,SAAS,GAAG;AACR,aAAO,EAAE,IAAI,OAAO,OAAO,MAAM,QAAQ,MAAM,WAAW,QAAQ,GAAG,UAAU,uBAAa,YAAW,gBAAgB;AAAA,IAC3H;AAAA,EACJ;AAgCA,iBAAsB,oBAClB,OACA,OACA,MACA,QACkC;AAClC,UAAM,MAAM,gCAAgC,KAAK,IAAI,IAAI;AACzD,UAAM,UAAU;AAAA,MACZ,eAAe,UAAU,KAAK;AAAA,MAC9B,QAAQ;AAAA,MACR,wBAAwB;AAAA,IAC5B;AAEA,UAAM,QAAQ,OAAO,OAAO,SAAS,EAAE,EAAE,KAAK;AAC9C,UAAM,OAAO,OAAO,OAAO,QAAQ,EAAE,EAAE,KAAK;AAC5C,UAAM,OAAO,OAAO,OAAO,QAAQ,EAAE,EAAE,KAAK;AAC5C,UAAM,OAAO,OAAO,OAAO,SAAS,YAAY,OAAO,KAAK,SAAS,OAAO,OAAO;AAEnF,QAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,MAAM;AAC1B,aAAO,EAAE,IAAI,OAAO,OAAO,MAAM,MAAM,MAAM,QAAQ,KAAK,SAAS,wBAAwB;AAAA,IAC/F;AAEA,QAAI;AACA,YAAM,MAAM,MAAM,MAAM,KAAK;AAAA,QACzB,QAAQ;AAAA,QACR;AAAA,QACA,MAAM,KAAK,UAAU,EAAE,OAAO,MAAM,MAAM,KAAK,CAAC;AAAA,MACpD,CAAC;AACD,YAAM,OAAO,UAAW,2BAAa,OAAO;AAC5C,YAAM,OAAO,UAAW,2BAAa,SAAS,eAAe;AAE7D,UAAI,IAAI,WAAW,OAAO,MAAM;AAC5B,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,MAAM,MAAM,QAAQ,KAAK,SAAS,qBAAqB,cAAc,MAAM,KAAK;AAAA,MACrH;AAEA,UAAI,CAAC,IAAI,IAAI;AACT,cAAM,OAAO,MAAM,SAAS,GAAG;AAC/B,cAAM,MAAM,QAAQ,QAAQ,IAAI,MAAM;AACtC,cAAM,UAAU,IAAI,WAAW,OAAO,kBAAkB,KAAK,GAAG;AAChE,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,MAAM,MAAM,QAAQ,IAAI,QAAQ,SAAS,KAAK,MAAM,eAAe,QAAQ;AAAA,MAChH;AAEA,YAAM,OAAO,MAAM,IAAI,KAAK;AAC5B,YAAM,SAAS,QAAO,6BAAM,YAAW,WAAW,KAAK,SAAS;AAChE,YAAM,QAAQ,QAAO,6BAAM,cAAa,WAAW,KAAK,WAAW;AAEnE,UAAI,CAAC,UAAU,CAAC,OAAO;AACnB,eAAO,EAAE,IAAI,OAAO,OAAO,MAAM,MAAM,MAAM,QAAQ,KAAK,SAAS,uBAAuB,KAAK;AAAA,MACnG;AAEA,aAAO,EAAE,IAAI,MAAM,OAAO,MAAM,MAAM,MAAM,QAAQ,KAAK,OAAO,KAAK;AAAA,IACzE,SAAS,GAAG;AACR,aAAO,EAAE,IAAI,OAAO,OAAO,MAAM,MAAM,MAAM,QAAQ,GAAG,UAAU,uBAAa,YAAW,gBAAgB;AAAA,IAC9G;AAAA,EACJ;;;ACnmCA,MAAM,yBAAyB;AAU/B,WAAS,uBAAuB,UAAmC;AACjE,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,YAAM,MAAM,SAAS,CAAC;AACtB,UAAI,CAAC,IAAK,QAAO;AACjB,UAAI,QAAQ,OAAO,QAAQ,MAAM;AAC/B,eAAO;AAAA,MACT;AACA,UAAI,uBAAuB,KAAK,GAAG,GAAG;AACpC,eAAO,2BAA2B,GAAG;AAAA,MACvC;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAEO,WAAS,0BAA0B,KAAkC;AAC1E,UAAM,WAAW,oBAAO,IAAI,KAAK;AACjC,QAAI,CAAC,QAAS,QAAO,EAAE,IAAI,MAAM,SAAS,GAAG;AAC7C,QAAI,YAAY,OAAO,YAAY,QAAQ,YAAY,IAAK,QAAO,EAAE,IAAI,MAAM,SAAS,IAAI;AAE5F,UAAM,YAAY,QAAQ,QAAQ,OAAO,GAAG,EAAE,QAAQ,WAAW,GAAG;AACpE,UAAM,WAAW,UAAU,QAAQ,QAAQ,EAAE,EAAE,QAAQ,QAAQ,EAAE;AACjE,QAAI,CAAC,SAAU,QAAO,EAAE,IAAI,MAAM,SAAS,IAAI;AAE/C,UAAM,WAAW,SAAS,MAAM,GAAG,EAAE,OAAO,OAAO;AACnD,UAAM,MAAM,uBAAuB,QAAQ;AAC3C,QAAI,IAAK,QAAO,EAAE,IAAI,OAAO,SAAS,IAAI;AAC1C,WAAO,EAAE,IAAI,MAAM,SAAS,SAAS,KAAK,GAAG,EAAE;AAAA,EACjD;AAEO,WAAS,0BAA0B,QAAkC;AAC1E,QAAI,CAAC,OAAQ,QAAO,EAAE,IAAI,MAAM,MAAM,GAAG;AACzC,QAAI,WAAW,OAAO,WAAW,QAAQ,WAAW,IAAK,QAAO,EAAE,IAAI,MAAM,MAAM,GAAG;AAErF,UAAM,YAAY,OAAO,QAAQ,OAAO,GAAG,EAAE,QAAQ,WAAW,GAAG;AACnE,UAAM,WAAW,UAAU,QAAQ,QAAQ,EAAE,EAAE,QAAQ,QAAQ,EAAE;AACjE,QAAI,CAAC,SAAU,QAAO,EAAE,IAAI,MAAM,MAAM,GAAG;AAE3C,UAAM,WAAW,SAAS,MAAM,GAAG,EAAE,OAAO,OAAO;AACnD,UAAM,MAAM,uBAAuB,QAAQ;AAC3C,QAAI,IAAK,QAAO,EAAE,IAAI,OAAO,SAAS,IAAI;AAC1C,WAAO,EAAE,IAAI,MAAM,MAAM,SAAS,KAAK,GAAG,EAAE;AAAA,EAC9C;;;ACnDO,MAAM,0BAA0B;AACvC,MAAM,yBAAyB;AAC/B,MAAM,sBAAsB;AAMrB,WAAS,uBAAuB,KAA0D;AAC/F,UAAM,UAAU,OAAO,QAAQ,WAAW,MAAM;AAChD,UAAM,UAAU,QAAQ,KAAK;AAC7B,QAAI,CAAC,SAAS;AACZ,aAAO,EAAE,IAAI,OAAO,SAAS,gDAAgD;AAAA,IAC/E;AACA,QAAI,YAAY,OAAO,YAAY,MAAM;AACvC,aAAO,EAAE,IAAI,OAAO,SAAS,0CAA0C;AAAA,IACzE;AACA,QAAI,QAAQ,SAAS,qBAAqB;AACxC,aAAO,EAAE,IAAI,OAAO,SAAS,4BAA4B,mBAAmB,wBAAwB;AAAA,IACtG;AACA,QAAI,uBAAuB,KAAK,OAAO,GAAG;AACxC,aAAO,EAAE,IAAI,OAAO,SAAS,4EAA4E;AAAA,IAC3G;AACA,QAAI,CAAC,WAAW,KAAK,OAAO,GAAG;AAC7B,aAAO,EAAE,IAAI,OAAO,SAAS,wCAAwC;AAAA,IACvE;AACA,WAAO,EAAE,IAAI,MAAM,UAAU,QAAQ;AAAA,EACvC;;;AC0BA,MAAM,kBAAkB;AACxB,MAAM,qBAAqB;AAE3B,WAAS,YAAY,GAAmB;AACpC,QAAI;AACA,aAAO,KAAK,CAAC;AAAA,IACjB,SAAQ;AACJ,aAAO;AAAA,IACX;AAAA,EACJ;AAEA,WAAS,YAAY,GAAmB;AACpC,QAAI;AACA,aAAO,KAAK,CAAC;AAAA,IACjB,SAAQ;AACJ,aAAO;AAAA,IACX;AAAA,EACJ;AAEA,WAAS,MAAM,IAAY;AACvB,WAAO,IAAI,QAAc,CAAC,YAAY,WAAW,SAAS,EAAE,CAAC;AAAA,EACjE;AAEO,WAAS,uBAAuB,MAAqC;AACxE,QAAI,UAAyB;AAE7B,mBAAe,cAAmC;AAlFtD;AAmFQ,UAAI;AACA,gBAAQ,WAAM,MAAM,cAAc,SAAS,eAAe,MAAlD,YAAwD,CAAC;AAAA,MACrE,SAAQ;AACJ,eAAO,CAAC;AAAA,MACZ;AAAA,IACJ;AAEA,mBAAe,YAAY,KAAgC;AACvD,UAAI;AACA,cAAM,MAAM,cAAc,SAAS,iBAAiB,GAAG;AAAA,MAC3D,SAAQ;AAAA,MAER;AAAA,IACJ;AAEA,mBAAe,cACX,SACmB;AACnB,YAAM,UAAU,MAAM,YAAY;AAClC,YAAM,SAAS,kCAAK,UAAY;AAChC,YAAM,YAAY,MAAM;AAC5B,aAAO;AAAA,IACX;AAIA,mBAAe,yBAA0D;AACrE,UAAI;AACA,cAAM,SAAS,MAAM,MAAM,cAAc,SAAS,kBAAkB;AACpE,YACI,UACA,OAAO,WAAW,YAClB,OAAQ,OAAgC,WAAW,YACnD,OAAQ,OAAkC,aAAa,UACzD;AACE,iBAAO;AAAA,YACH,QAAS,OAA8B;AAAA,YACvC,UAAW,OAAgC;AAAA,YAC3C,OACI,OAAQ,OAA+B,UAAU,aAC/C,OAA+B,UAAU,SACtC,OAA+B,UAAU,cACzC,OAA+B,UAAU,gBACtC,OAAkC,QACpC;AAAA,UACd;AAAA,QACJ;AAAA,MACJ,SAAQ;AAAA,MAER;AACA,aAAO;AAAA,IACX;AAEA,mBAAe,uBAAuB,KAAqC;AACvE,UAAI;AACA,cAAM,MAAM,cAAc,SAAS,oBAAoB,GAAG;AAAA,MAC9D,SAAQ;AAAA,MAER;AAAA,IACJ;AAEI,aAAS,gBACL,OACA,gBACA,UACsC;AACtC,YAAM,cAAc,GAAG,cAAc,MAAM,QAAQ;AACnD,YAAM,cAAc,GAAG,cAAc,MAAM,QAAQ;AACnD,YAAM,UAAU,GAAG,cAAc,SAAS,QAAQ;AAClD,YAAM,UAAU,GAAG,cAAc,SAAS,QAAQ;AAClD,YAAM,UAAU,KAAK;AAAA,QACjB;AAAA,QACA;AAAA,MACJ;AAEA,UAAI,SAAS,MAAM,KAAK,CAAC,MAAM;AAC3B,cAAM,IAAI,QAAO,uBAAG,SAAQ,EAAE;AAC9B,eACI,MAAM,eACN,MAAM,eACN,EAAE,SAAS,GAAG,cAAc,MAAM,QAAQ,EAAE;AAAA,MAEpD,CAAC;AACD,UAAI,CAAC,QAAQ;AACT,iBAAS,MAAM,KAAK,CAAC,MAAM;AACvB,gBAAM,IAAI,QAAO,uBAAG,SAAQ,EAAE;AAC9B,iBACI,EAAE,SAAS,OAAO,KAClB,EAAE,SAAS,OAAO,KAClB,EAAE,SAAS,OAAO;AAAA,QAE1B,CAAC;AAAA,MACL;AACA,aAAO,UAAU;AAAA,IACrB;AAEA,mBAAe,iBAAiB,OAA8B;AAC1D,YAAM,MAAM,EAAE;AACd,UAAI,QAAQ,MAAM,YAAY,KAAK;AACnC,UACI,CAAC,MAAM,MACP,iCAAiC,KAAK,MAAM,SAAS,EAAE,GACzD;AACE,cAAM,MAAM,GAAG;AACf,gBAAQ,MAAM,YAAY,KAAK;AAAA,MACnC;AACA,UAAI,MAAM,IAAI;AACV,cAAM,UAAU,MAAM,MAAM,IAAI,CAAC,OAAO;AAAA,UACpC,WAAW,EAAE;AAAA,UACb,gBAAgB,EAAE;AAAA,UAClB,SAAS,CAAC,CAAC,EAAE;AAAA,QACjB,EAAE;AACF,aAAK,KAAK,EAAE,MAAM,gBAAgB,SAAS,EAAE,OAAO,QAAQ,EAAE,CAAC;AAAA,MACnE,OAAO;AACH,aAAK,KAAK;AAAA,UACN,MAAM;AAAA,UACN,SAAS;AAAA,YACL,SAAS,iCAAiC,MAAM,KAAK;AAAA,UACzD;AAAA,QACJ,CAAC;AACD,aAAK,KAAK,EAAE,MAAM,gBAAgB,SAAS,EAAE,OAAO,CAAC,EAAE,EAAE,CAAC;AAAA,MAC9D;AAAA,IACJ;AAEA,mBAAe,8BAA6C;AACxD,UAAI;AACA,cAAM,qBAAqB,MAAM,MAAM,cAClC,SAAS,oBAAoB,EAC7B,MAAM,MAAM,IAAI;AACrB,cAAM,eACF,OAAO,uBAAuB,YACxB,qBACA;AACV,YAAI,CAAC,cAAc;AACf,gBAAM,MAAM,cACP,YAAY,kBAAkB,EAC9B,MAAM,MAAM;AAAA,UAAC,CAAC;AACnB;AAAA,QACJ;AAEA,cAAM,SAAS,MAAM,MAAM,cACtB,SAAS,kBAAkB,EAC3B,MAAM,MAAM,IAAI;AACrB,YAAI,CAAC,UAAU,OAAO,WAAW,YAAY,OAAO,WAAW;AAC3D;AAEJ,cAAM,UAAU,YAAY,MAAM;AAClC,kBAAU;AAEV,cAAM,MAAM,MAAM,UAAU,OAAO;AACnC,YAAI,IAAI,IAAI;AACR,eAAK,KAAK;AAAA,YACN,MAAM;AAAA,YACN,SAAS;AAAA,cACL,IAAI;AAAA,cACJ,OAAO,IAAI,KAAK;AAAA,cAChB,MAAM,IAAI,KAAK;AAAA,cACf,UAAU;AAAA,YACd;AAAA,UACJ,CAAC;AACD,gBAAM,iBAAiB,OAAO;AAAA,QAClC,OAAO;AACH,eAAK,KAAK;AAAA,YACN,MAAM;AAAA,YACN,SAAS;AAAA,cACL,SAAS,iDAAiD,IAAI,KAAK;AAAA,YACvE;AAAA,UACJ,CAAC;AACD,eAAK,KAAK;AAAA,YACN,MAAM;AAAA,YACN,SAAS,EAAE,IAAI,OAAO,OAAO,IAAI,OAAO,UAAU,MAAM;AAAA,UAC5D,CAAC;AAAA,QACL;AAAA,MACJ,SAAQ;AAAA,MAER;AAAA,IACJ;AAEA,mBAAe,2BAA2B,WAAmB;AACzD,YAAM,qBAAqB,0BAA0B,SAAS;AAC9D,UAAI,CAAC,mBAAmB,IAAI;AACxB,eAAO;AAAA,MACX;AACA,YAAM,qBAAqB;AAAA,QACvB,mBAAmB;AAAA,MACvB;AACA,UAAI,CAAC,mBAAmB,IAAI;AACxB,eAAO;AAAA,MACX;AACA,aAAO;AAAA,QACH,IAAI;AAAA,QACJ,SAAS,mBAAmB;AAAA,QAC5B,MAAM,mBAAmB;AAAA,MAC7B;AAAA,IACJ;AAEF,mBAAe,yBACb,OACA,OACA,MACA,QACA,YACwE;AACpE,UAAI,CAAC,WAAY,QAAO,EAAE,IAAI,KAAK;AACnC,YAAM,WAAW,WAAW,MAAM,GAAG,EAAE,OAAO,OAAO;AACrD,UAAI,SAAS;AACb,eAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACtC,iBAAS,SAAS,GAAG,MAAM,IAAI,SAAS,CAAC,CAAC,KAAK,SAAS,CAAC;AACzD,cAAM,MAAM,MAAM,WAAW,OAAO,OAAO,MAAM,QAAQ,MAAM;AAC/D,YAAI,IAAI,GAAI;AACZ,cAAM,SAAS,OAAO,IAAI,WAAW,WAAW,IAAI,SAAS;AAC7D,YAAI,WAAW,IAAK;AACpB,YAAI,WAAW,KAAK;AAChB,iBAAO;AAAA,YACH,IAAI;AAAA,YACJ,QAAQ;AAAA,YACR,SAAS,YAAY,MAAM;AAAA,UAC/B;AAAA,QACJ;AACA,YAAI,IAAI,cAAc;AAClB,iBAAO;AAAA,YACH,IAAI;AAAA,YACJ,QAAQ;AAAA,YACR,SACI;AAAA,UACR;AAAA,QACJ;AACA,cAAM,UAAU,IAAI,WAAW,QAAQ,MAAM;AAC7C,eAAO,EAAE,IAAI,OAAO,QAAQ,UAAU,KAAK,QAAQ;AAAA,MAC3D;AACA,aAAO,EAAE,IAAI,KAAK;AAAA,IACpB;AAEA,mBAAe,kCAAiD;AAC9D,UAAI;AACF,cAAM,OAAO,MAAM,KAAK,yBAAyB;AACjD,cAAM,OAAO,MAAM,MAAM,cAAc,SAAS,eAAe,EAAE,MAAM,MAAM,IAAI;AACjF,cAAM,mBAAmB,MAAM,MAAM,cAAc,SAAS,eAAe,EAAE,MAAM,MAAM,KAAK;AAC9F,cAAM,yBAAyB,MAAM,MAAM,cAAc,SAAS,qBAAqB,EAAE,MAAM,MAAM,KAAK;AAC1G,cAAM,oBAAoB,MAAM,MAAM,cAAc,SAAS,gBAAgB,EAAE,MAAM,MAAM,KAAK;AAChG,cAAM,qBAAqB,MAAM,MAAM,cAAc,SAAS,cAAc,EAAE,MAAM,MAAM,IAAI;AAC9F,cAAM,2BAA2B,MAAM,MAAM,cAAc,SAAS,oBAAoB,EAAE,MAAM,MAAM,IAAI;AAC1G,cAAM,kBAAkB,OAAO,uBAAuB,YAAY,qBAAqB;AACvF,cAAM,wBAAwB,OAAO,6BAA6B,YAAY,2BAA2B;AACzG,cAAM,aAAa,QAAQ,OAAO,KAAK,eAAe,YAAY,OAAO,KAAK,SAAS,WACnF,OACA;AAEJ,aAAK,KAAK;AAAA,UACR,MAAM;AAAA,UACN,SAAS;AAAA,YACP,aAAa,KAAK;AAAA,YAClB,MAAM;AAAA,YACN,eAAe,CAAC,CAAC;AAAA,YACjB,qBAAqB,CAAC,CAAC;AAAA,YACvB,gBAAgB,CAAC,CAAC;AAAA,YAClB,cAAc;AAAA,YACd,oBAAoB;AAAA,UACtB;AAAA,QACF,CAAC;AACD,aAAK,KAAK,EAAE,MAAM,wBAAwB,SAAS,EAAE,MAAM,KAAK,QAAQ,EAAE,CAAC;AAAA,MAC7E,SAAS,KAAK;AACZ,cAAM,WAAW,2BAAe,YAAW;AAC3C,aAAK,KAAK,EAAE,MAAM,SAAS,SAAS,EAAE,SAAS,0CAA0C,OAAO,GAAG,EAAE,CAAC;AAAA,MACxG;AAAA,IACF;AAEE,mBAAe,OAAO,KAAmC;AA9V7D;AA+VQ,cAAQ,IAAI,MAAM;AAAA,QACd,KAAK,oBAAoB;AACrB,gBAAM,QAAQ,OAAO,IAAI,QAAQ,SAAS,EAAE,EAAE,KAAK;AACnD,gBAAM,WAAW,CAAC,CAAC,IAAI,QAAQ;AAE/B,cAAI,CAAC,OAAO;AACR,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS,EAAE,SAAS,uBAAuB;AAAA,YAC/C,CAAC;AACD,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ,OAAO;AAAA,gBACP,UAAU;AAAA,cACd;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AAEA,oBAAU;AACV,cAAI,UAAU;AACV,kBAAM,MAAM,cACP,SAAS,oBAAoB,YAAY,KAAK,CAAC,EAC/C,MAAM,MAAM;AAAA,YAAC,CAAC;AAAA,UACvB,OAAO;AACH,kBAAM,MAAM,cACP,YAAY,kBAAkB,EAC9B,MAAM,MAAM;AAAA,YAAC,CAAC;AAAA,UACvB;AAEA,gBAAM,MAAM,MAAM,UAAU,KAAK;AACjC,cAAI,IAAI,IAAI;AACR,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ,OAAO,IAAI,KAAK;AAAA,gBAChB,MAAM,IAAI,KAAK;AAAA,gBACf;AAAA,cACJ;AAAA,YACJ,CAAC;AACD,kBAAM,iBAAiB,KAAK;AAAA,UAChC,OAAO;AACH,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,SAAS,kCAAkC,IAAI,KAAK;AAAA,cACxD;AAAA,YACJ,CAAC;AACD,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ,OAAO,IAAI;AAAA,gBACX,UAAU;AAAA,cACd;AAAA,YACJ,CAAC;AACD,iBAAK,KAAK,EAAE,MAAM,gBAAgB,SAAS,EAAE,OAAO,CAAC,EAAE,EAAE,CAAC;AAAA,UAC9D;AACA,iBAAO;AAAA,QACX;AAAA,QAEA,KAAK,uBAAuB;AACxB,oBAAU;AACV,gBAAM,MAAM,cACP,YAAY,kBAAkB,EAC9B,MAAM,MAAM;AAAA,UAEb,CAAC;AACL,eAAK,KAAK;AAAA,YACN,MAAM;AAAA,YACN,SAAS,EAAE,SAAS,yBAAyB;AAAA,UACjD,CAAC;AACD,eAAK,KAAK;AAAA,YACN,MAAM;AAAA,YACN,SAAS,EAAE,IAAI,OAAO,UAAU,MAAM;AAAA,UAC1C,CAAC;AACD,eAAK,KAAK,EAAE,MAAM,gBAAgB,SAAS,EAAE,OAAO,CAAC,EAAE,EAAE,CAAC;AAC1D,iBAAO;AAAA,QACX;AAAA,QAEA,KAAK,sBAAsB;AACvB,gBAAM,MAAM,MAAM,YAAY;AAC9B,gBAAM,YAAY;AAAA,YACd,OAAO,IAAI,QAAQ;AAAA,YACnB,MAAM,IAAI,QAAQ;AAAA,YAClB,QAAQ,IAAI;AAAA,YACZ,QAAQ;AAAA,YACR,UAAU,IAAI;AAAA,YACd,eAAe,IAAI;AAAA,YACnB,OAAO,IAAI;AAAA,YACX,YAAY,IAAI;AAAA,YAChB,MAAM,IAAI;AAAA,YACV,UAAU,IAAI;AAAA,YACd,QAAQ,IAAI;AAAA,YACZ,SAAS,IAAI;AAAA,YACb,QAAQ,IAAI;AAAA,UAChB,CAAC;AACD,iBAAO;AAAA,QACX;AAAA,QAEA,KAAK,wBAAwB;AACzB,gBAAM,MAAM,MAAM,YAAY;AAC9B,gBAAM,YAAY;AAAA,YACd,OAAO,IAAI,QAAQ,SAAS,IAAI;AAAA,YAChC,MAAM,IAAI,QAAQ,QAAQ,IAAI;AAAA,YAC9B,QAAQ,IAAI,QAAQ;AAAA,YACpB,QAAQ;AAAA,YACR,UAAU,IAAI;AAAA,YACd,eAAe,IAAI;AAAA,YACnB,OAAO,IAAI;AAAA,YACX,YAAY,IAAI;AAAA,YAChB,MAAM,IAAI;AAAA,YACV,UAAU,IAAI;AAAA,YACd,QAAQ,IAAI;AAAA,YACZ,SAAS,IAAI;AAAA,YACb,QAAQ,IAAI;AAAA,UAChB,CAAC;AACD,iBAAO;AAAA,QACX;AAAA,QAEA,KAAK,qBAAqB;AACtB,gBAAM,eAAe;AAAA,YACjB,QAAO,SAAI,QAAQ,WAAZ,YAAsB,EAAE;AAAA,UACnC;AACA,cAAI,CAAC,aAAa,IAAI;AAClB,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS,EAAE,SAAS,aAAa,QAAQ;AAAA,YAC7C,CAAC;AACD,mBAAO;AAAA,UACX;AACA,gBAAM,SAAS,aAAa;AAC5B,gBAAM,MAAM,MAAM,YAAY;AAC9B,gBAAM,YAAY;AAAA,YACd,OAAO,IAAI,QAAQ,SAAS,IAAI;AAAA,YAChC,MAAM,IAAI,QAAQ,QAAQ,IAAI;AAAA,YAC9B,QAAQ,IAAI;AAAA,YACZ;AAAA,YACA,UAAU,IAAI;AAAA,YACd,eAAe,IAAI;AAAA,YACnB,OAAO,IAAI;AAAA,YACX,YAAY,IAAI;AAAA,YAChB,MAAM,IAAI;AAAA,YACV,UAAU,IAAI;AAAA,YACd,QAAQ,IAAI;AAAA,YACZ,SAAS,IAAI;AAAA,YACb,QAAQ,IAAI;AAAA,UAChB,CAAC;AACD,iBAAO;AAAA,QACX;AAAA,QAEA,KAAK,qBAAqB;AACtB,gBAAM,SAA8B,CAAC;AACrC,cAAI,OAAO,IAAI,QAAQ,UAAU;AAC7B,mBAAO,QAAQ,IAAI,QAAQ;AAC/B,cAAI,OAAO,IAAI,QAAQ,SAAS;AAC5B,mBAAO,OAAO,IAAI,QAAQ;AAC9B,cAAI,OAAO,IAAI,QAAQ,WAAW;AAC9B,mBAAO,SAAS,IAAI,QAAQ;AAChC,cAAI,OAAO,IAAI,QAAQ,WAAW,UAAU;AACxC,kBAAM,eAAe;AAAA,cACjB,IAAI,QAAQ;AAAA,YAChB;AACA,gBAAI,aAAa,GAAI,QAAO,SAAS,aAAa;AAAA;AAE9C,mBAAK,KAAK;AAAA,gBACN,MAAM;AAAA,gBACN,SAAS,EAAE,SAAS,aAAa,QAAQ;AAAA,cAC7C,CAAC;AAAA,UACT;AACA,cAAI,OAAO,IAAI,QAAQ,aAAa;AAChC,mBAAO,WAAW,IAAI,QAAQ,SAAS,KAAK;AAChD,cAAI,OAAO,IAAI,QAAQ,kBAAkB;AACrC,mBAAO,gBAAgB,IAAI,QAAQ;AACvC,cACI,IAAI,QAAQ,UAAU,SACtB,IAAI,QAAQ,UAAU,cACtB,IAAI,QAAQ,UAAU,cACxB;AACE,mBAAO,QAAQ,IAAI,QAAQ;AAAA,UAC/B;AACA,cAAI,OAAO,IAAI,QAAQ,eAAe;AAClC,mBAAO,aAAa,IAAI,QAAQ;AACpC,cAAI,OAAO,IAAI,QAAQ,SAAS;AAC5B,mBAAO,OAAO,IAAI,QAAQ;AAC9B,cAAI,OAAO,IAAI,QAAQ,oBAAoB;AACvC,mBAAO,kBAAkB,IAAI,QAAQ;AACzC,cAAI,OAAO,IAAI,QAAQ,eAAe;AAClC,mBAAO,aAAa,IAAI,QAAQ;AACpC,cAAI,OAAO,IAAI,QAAQ,aAAa;AAChC,mBAAO,WAAW,IAAI,QAAQ;AAClC,cAAI,OAAO,IAAI,QAAQ,WAAW;AAC9B,mBAAO,SAAS,IAAI,QAAQ;AAChC,cAAI,OAAO,IAAI,QAAQ,YAAY;AAC/B,mBAAO,UAAU,IAAI,QAAQ;AACjC,cAAI,OAAO,IAAI,QAAQ,WAAW;AAC9B,mBAAO,SAAS,IAAI,QAAQ;AAChC,gBAAM,cAAc,MAAM;AAC1B,iBAAO;AAAA,QACX;AAAA,QAEA,KAAK,yBAAyB;AAC1B,gBAAM,QAAQ,OAAO,IAAI,QAAQ,SAAS,EAAE;AAC5C,gBAAM,OAAO,OAAO,IAAI,QAAQ,QAAQ,EAAE;AAC1C,gBAAM,OAAO,OAAO,SAAS,IAAI,QAAQ,IAAI,IACvC,OAAO,IAAI,QAAQ,IAAI,IACvB;AACN,gBAAM,QAAQ,CAAC,CAAC,IAAI,QAAQ;AAE5B,cAAI,CAAC,SAAS;AACV,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL;AAAA,gBACA;AAAA,gBACA,QAAQ;AAAA,gBACR,SAAS;AAAA,cACb;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AAEA,gBAAM,MAAM,MAAM;AAAA,YACd;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACJ;AACA,cAAI,IAAI,IAAI;AACR,iBAAK,KAAK,EAAE,MAAM,mBAAmB,SAAS,IAAI,CAAC;AACnD,gBAAI,SAAS,KAAK,IAAI,eAAe;AACjC,oBAAM,cAAc;AAAA,gBAChB;AAAA,gBACA;AAAA,gBACA,QAAQ,IAAI;AAAA,gBACZ,QAAQ,IAAI;AAAA,cAChB,CAAC;AAAA,YACL;AAAA,UACJ,OAAO;AACH,iBAAK,KAAK,EAAE,MAAM,yBAAyB,SAAS,IAAI,CAAC;AAAA,UAC7D;AACA,iBAAO;AAAA,QACX;AAAA,QAEA,KAAK,sBAAsB;AACvB,gBAAM,QAAQ,OAAO,IAAI,QAAQ,SAAS,EAAE;AAC5C,gBAAM,OAAO,OAAO,IAAI,QAAQ,QAAQ,EAAE;AAC1C,gBAAM,SAAS,OAAO,IAAI,QAAQ,UAAU,EAAE;AAC9C,gBAAM,UAAU,OAAO,IAAI,QAAQ,QAAQ,EAAE;AAE7C,cAAI,CAAC,SAAS;AACV,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,MAAM;AAAA,gBACN,QAAQ;AAAA,gBACR,SAAS;AAAA,cACb;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AAEA,gBAAM,iBAAiB,0BAA0B,OAAO;AACxD,cAAI,CAAC,eAAe,IAAI;AACpB,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,MAAM;AAAA,gBACN,QAAQ;AAAA,gBACR,SAAS,eAAe;AAAA,cAC5B;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AACA,gBAAM,mBAAmB;AAAA,YACrB,eAAe;AAAA,UACnB;AACA,cAAI,CAAC,iBAAiB,IAAI;AACtB,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,MAAM;AAAA,gBACN,QAAQ;AAAA,gBACR,SAAS,iBAAiB;AAAA,cAC9B;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AAEA,gBAAM,aAAa,iBAAiB;AACpC,cAAI,YAAY;AACZ,kBAAM,YAAY,MAAM;AAAA,cACpB;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACJ;AACA,gBAAI,CAAC,UAAU,IAAI;AACf,mBAAK,KAAK;AAAA,gBACN,MAAM;AAAA,gBACN,SAAS;AAAA,kBACL,IAAI;AAAA,kBACJ;AAAA,kBACA;AAAA,kBACA;AAAA,kBACA,MAAM;AAAA,kBACN,QAAQ,UAAU;AAAA,kBAClB,SAAS,UAAU;AAAA,gBACvB;AAAA,cACJ,CAAC;AACD,qBAAO;AAAA,YACX;AAAA,UACJ;AAEA,gBAAM,MAAM,MAAM;AAAA,YACd;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA,iBAAiB;AAAA,UACrB;AACA,cAAI,IAAI,IAAI;AACR,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,MAAM,IAAI;AAAA,gBACV,SAAS,IAAI,KAAK,IAAI,CAAC,OAAO;AAAA,kBAC1B,MAAM;AAAA,kBACN,MAAM,EAAE;AAAA,kBACR,MAAM,EAAE;AAAA,gBACZ,EAAE;AAAA,gBACF,MAAM,IAAI;AAAA,cACd;AAAA,YACJ,CAAC;AAAA,UACL,OAAO;AACH,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,MAAM,IAAI;AAAA,gBACV,QAAQ,IAAI;AAAA,gBACZ,SAAS,IAAI;AAAA,gBACb,MAAM,IAAI;AAAA,cACd;AAAA,YACJ,CAAC;AAAA,UACL;AACA,iBAAO;AAAA,QACX;AAAA,QAEA,KAAK,wBAAwB;AACzB,gBAAM,QAAQ,OAAO,IAAI,QAAQ,SAAS,EAAE;AAC5C,gBAAM,OAAO,OAAO,IAAI,QAAQ,QAAQ,EAAE;AAC1C,gBAAM,SAAS,OAAO,IAAI,QAAQ,UAAU,EAAE;AAC9C,gBAAM,gBAAgB;AAAA,YACjB,IAAI,QAAgB,cAAc,IAAI,QAAQ,QAAQ;AAAA,UAC3D,EAAE,KAAK;AAEP,cAAI,CAAC,SAAS;AACV,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,YAAY;AAAA,gBACZ,QAAQ;AAAA,gBACR,SAAS;AAAA,cACb;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AAEA,gBAAM,mBACF,0BAA0B,aAAa;AAC3C,cAAI,CAAC,iBAAiB,IAAI;AACtB,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,YAAY;AAAA,gBACZ,QAAQ;AAAA,gBACR,SAAS,iBAAiB;AAAA,cAC9B;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AAEA,gBAAM,eAAe;AAAA,YACjB,iBAAiB;AAAA,UACrB;AACA,cAAI,CAAC,aAAa,IAAI;AAClB,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,YAAY;AAAA,gBACZ,QAAQ;AAAA,gBACR,SAAS,aAAa;AAAA,cAC1B;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AACA,cAAI,CAAC,aAAa,MAAM;AACpB,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,YAAY;AAAA,gBACZ,QAAQ;AAAA,gBACR,SAAS;AAAA,cACb;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AAEA,gBAAM,MAAM,MAAM;AAAA,YACd;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA,aAAa;AAAA,UACjB;AACA,eAAK,KAAK;AAAA,YACN,MAAM;AAAA,YACN,SAAS;AAAA,UACb,CAAC;AACD,iBAAO;AAAA,QACX;AAAA,QAEA,KAAK,wBAAwB;AACzB,gBAAM,QAAQ,OAAO,IAAI,QAAQ,SAAS,EAAE;AAC5C,gBAAM,OAAO,OAAO,IAAI,QAAQ,QAAQ,EAAE;AAC1C,gBAAM,aAAa,OAAO,IAAI,QAAQ,cAAc,EAAE;AACtD,gBAAM,YAAY,OAAO,IAAI,QAAQ,aAAa,EAAE;AAEpD,cAAI,CAAC,SAAS;AACV,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,QAAQ;AAAA,gBACR,SAAS;AAAA,cACb;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AACA,cAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,cAAc,CAAC,WAAW;AAC9C,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,QAAQ;AAAA,gBACR,SAAS;AAAA,cACb;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AAEA,gBAAM,MAAM,MAAM;AAAA,YACd;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACJ;AACA,cAAI,IAAI,IAAI;AACR,kBAAM,cAAc,EAAE,OAAO,MAAM,QAAQ,UAAU,CAAC;AAAA,UAC1D;AACA,eAAK,KAAK;AAAA,YACN,MAAM;AAAA,YACN,SAAS;AAAA,UACb,CAAC;AACD,iBAAO;AAAA,QACX;AAAA,QAEA,KAAK,uBAAuB;AACxB,gBAAM,QAAQ,OAAO,IAAI,QAAQ,SAAS,EAAE;AAC5C,gBAAM,OAAO,OAAO,IAAI,QAAQ,QAAQ,EAAE;AAC1C,gBAAM,SAAS,OAAO,IAAI,QAAQ,UAAU,EAAE;AAC9C,gBAAM,UAAU,OAAO,IAAI,QAAQ,QAAQ,EAAE;AAC7C,gBAAM,WAAW,CAAC,CAAC,IAAI,QAAQ;AAE/B,cAAI,CAAC,SAAS;AACV,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,MAAM;AAAA,gBACN,QAAQ;AAAA,gBACR,SAAS;AAAA,cACb;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AACA,cAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,KAAK,GAAG;AAC/C,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,MAAM;AAAA,gBACN,QAAQ;AAAA,gBACR,SAAS;AAAA,cACb;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AAEA,gBAAM,iBAAiB,0BAA0B,OAAO;AACxD,cAAI,CAAC,eAAe,IAAI;AACpB,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,MAAM;AAAA,gBACN,QAAQ;AAAA,gBACR,SAAS,eAAe;AAAA,cAC5B;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AACA,gBAAM,mBAAmB;AAAA,YACrB,eAAe;AAAA,UACnB;AACA,cAAI,CAAC,iBAAiB,IAAI;AACtB,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,MAAM;AAAA,gBACN,QAAQ;AAAA,gBACR,SAAS,iBAAiB;AAAA,cAC9B;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AACA,gBAAM,OAAO,iBAAiB;AAE9B,gBAAM,MAAM,MAAM;AAAA,YACd;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACJ;AACA,cAAI,CAAC,IAAI,IAAI;AACT,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,YACb,CAAC;AACD,gBAAI,IAAI,cAAc;AAClB,mBAAK,KAAK;AAAA,gBACN,MAAM;AAAA,gBACN,SAAS;AAAA,kBACL,SACI;AAAA,gBACR;AAAA,cACJ,CAAC;AAAA,YACL;AACA,mBAAO;AAAA,UACX;AAEA,cAAI;AACA,kBAAM,OAAO,KAAK,MAAM,IAAI,eAAe,IAAI;AAC/C,kBAAM,WAAW,MAAM,QAAQ,IAAI,QAAQ,QAAQ,IAC7C,IAAI,QAAQ,SAAS,IAAI,CAAC,MAAM,OAAO,CAAC,CAAC,IACzC,CAAC;AACP,kBAAM,UAAU,MAAM,KAAK,WAAW,MAAM;AAAA,cACxC,iBAAiB;AAAA,cACjB;AAAA,YACJ,CAAC;AACD,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS,EAAE,IAAI,MAAM,OAAO,MAAM,QAAQ,MAAM,KAAK;AAAA,YACzD,CAAC;AACD,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,SAAS,wBAAwB,KAAK,IAAI,IAAI,IAAI,MAAM,IAAI,IAAI;AAAA,cACpE;AAAA,YACJ,CAAC;AACD,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL;AAAA,gBACA,WAAW,KAAK,IAAI;AAAA,gBACpB,QAAQ;AAAA,cACZ;AAAA,YACJ,CAAC;AAED,kBAAM,gCAAgC;AAAA,UAC1C,SAAS,KAAK;AACV,kBAAM,WAAW,2BAAe,YAAW;AAC3C,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,QAAQ;AAAA,gBACR,SAAS;AAAA,cACb;AAAA,YACJ,CAAC;AACD,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,SAAS,yBAAyB,OAAO;AAAA,cAC7C;AAAA,YACJ,CAAC;AAAA,UACL;AACA,iBAAO;AAAA,QACX;AAAA,QAEA,KAAK,uBAAuB;AACxB,gBAAM,QACF,IAAI,QAAQ,UAAU,QAChB,QACA,IAAI,QAAQ,UAAU,eACtB,eACA;AACV,gBAAM,aAAa,OAAO,IAAI,QAAQ,cAAc,EAAE;AACtD,gBAAM,OAAO,OAAO,IAAI,QAAQ,QAAQ,EAAE;AAC1C,gBAAM,kBAAkB,CAAC,CAAC,IAAI,QAAQ;AACtC,gBAAM,aAAa,CAAC,CAAC,IAAI,QAAQ;AAEjC,cAAI;AACA,gBAAI,UAAU,OAAO;AACjB,oBAAM,MAAM,MAAM,KAAK,WAAW;AAAA,gBAC9B,QAAQ;AAAA,gBACR;AAAA,gBACA;AAAA,cACJ,CAAC;AACD,mBAAK,KAAK;AAAA,gBACN,MAAM;AAAA,gBACN,SAAS,EAAE,OAAO,IAAI,MAAM;AAAA,cAChC,CAAC;AAAA,YACL,WAAW,UAAU,cAAc;AAC/B,oBAAM,OAAO,MAAM,KAAK,WAAW;AAAA,gBAC/B,QAAQ;AAAA,cACZ,CAAC;AACD,mBAAK,KAAK;AAAA,gBACN,MAAM;AAAA,gBACN,SAAS,EAAE,OAAO,KAAK,MAAM;AAAA,cACjC,CAAC;AAAA,YACL,OAAO;AACH,kBAAI,CAAC,cAAc,CAAC,MAAM;AACtB,qBAAK,KAAK;AAAA,kBACN,MAAM;AAAA,kBACN,SAAS,EAAE,OAAO,CAAC,EAAE;AAAA,gBACzB,CAAC;AACD,qBAAK,KAAK;AAAA,kBACN,MAAM;AAAA,kBACN,SAAS;AAAA,oBACL,SACI;AAAA,kBACR;AAAA,gBACJ,CAAC;AACD,uBAAO;AAAA,cACX;AACA,oBAAM,MAAM,MAAM,KAAK,WAAW;AAAA,gBAC9B,QAAQ;AAAA,gBACR;AAAA,gBACA;AAAA,cACJ,CAAC;AACD,oBAAM,cAAc,GAAG,UAAU,MAAM,IAAI;AAC3C,oBAAM,cAAc,GAAG,UAAU,MAAM,IAAI;AAC3C,oBAAM,UAAU,GAAG,UAAU,SAAS,IAAI;AAC1C,oBAAM,UAAU,GAAG,UAAU,SAAS,IAAI;AAC1C,oBAAM,UAAU,KAAK;AAAA,gBACjB;AAAA,gBACA;AAAA,cACJ;AACA,kBAAI,SAAS,IAAI,MAAM,KAAK,CAAC,MAAM;AAC/B,sBAAM,IAAI,QAAO,uBAAG,SAAQ,EAAE;AAC9B,uBACI,MAAM,eACN,MAAM,eACN,EAAE,SAAS,GAAG,UAAU,MAAM,IAAI,EAAE;AAAA,cAE5C,CAAC;AACD,kBAAI,CAAC,QAAQ;AACT,yBAAS,IAAI,MAAM,KAAK,CAAC,MAAM;AAC3B,wBAAM,IAAI,QAAO,uBAAG,SAAQ,EAAE;AAC9B,yBACI,EAAE,SAAS,OAAO,KAClB,EAAE,SAAS,OAAO,KAClB,EAAE,SAAS,OAAO;AAAA,gBAE1B,CAAC;AAAA,cACL;AACA,oBAAM,QAAQ,SAAS,CAAC,MAAM,IAAI,IAAI;AACtC,mBAAK,KAAK;AAAA,gBACN,MAAM;AAAA,gBACN,SAAS,EAAE,MAAM;AAAA,cACrB,CAAC;AAAA,YACL;AAAA,UACJ,SAAS,KAAK;AACV,kBAAM,WACD,2BAAe,YAAW;AAC/B,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,SAAS,yBAAyB,OAAO;AAAA,cAC7C;AAAA,YACJ,CAAC;AACD,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS,EAAE,OAAO,CAAC,EAAE;AAAA,YACzB,CAAC;AAAA,UACL;AACA,iBAAO;AAAA,QACX;AAAA,QAEA,KAAK,4BAA4B;AAC7B,gBAAM,QAAQ,OAAO,IAAI,QAAQ,SAAS,EAAE;AAC5C,gBAAM,OAAO,OAAO,IAAI,QAAQ,QAAQ,EAAE;AAC1C,gBAAM,aAAa,OAAO,IAAI,QAAQ,UAAU,EAAE;AAClD,gBAAM,YACF,OAAO,IAAI,QAAQ,WAAW,WACxB,IAAI,QAAQ,SACZ;AACV,gBAAM,iBACF,OAAO,IAAI,QAAQ,iBAAiB,EAAE,KACtC,4BACF,KAAK;AACP,gBAAM,iBACF,IAAI,QAAQ,UAAU,QAChB,QACA,IAAI,QAAQ,UAAU,eACtB,eACA;AACV,cAAI,QAAqB;AACzB,gBAAM,aAAa,OAAO,IAAI,QAAQ,cAAc,EAAE;AACtD,gBAAM,OAAO,OAAO,IAAI,QAAQ,QAAQ,EAAE;AAC1C,gBAAM,kBAAkB,CAAC,CAAC,IAAI,QAAQ;AACtC,gBAAM,aAAa,CAAC,CAAC,IAAI,QAAQ;AACjC,gBAAM,WAAW,CAAC,CAAC,IAAI,QAAQ;AAC/B,gBAAM,eAAe,WACf,OAAO,IAAI,QAAQ,UAAU,EAAE,IAC/B;AACN,gBAAM,UACF,OAAO,IAAI,QAAQ,WAAW,aAAa,EAAE,KAAK,KAClD;AACJ,gBAAM,SACF,OAAO,IAAI,QAAQ,WAAW,WACxB,IAAI,QAAQ,SACZ;AACV,gBAAM,kBAAkB,MAAM,YAAY;AAC1C,gBAAM,sBACF,eACC,OAAO,gBAAgB,eAAe,WACjC,gBAAgB,aAChB;AACV,gBAAM,gBACF,SACC,OAAO,gBAAgB,SAAS,WAC3B,gBAAgB,OAChB;AACV,gBAAM,oBACF,OAAO,IAAI,QAAQ,aAAa,WAC1B,IAAI,QAAQ,WACZ,OAAO,gBAAgB,aAAa,WACpC,gBAAgB,WAChB;AACV,gBAAM,gBAAgB;AAAA,YAClB,gDAAqB;AAAA,UACzB;AACA,cAAI,CAAC,cAAc,IAAI;AACnB,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA,QAAQ;AAAA,gBACR,QAAQ;AAAA,gBACR,SAAS,cAAc;AAAA,gBACvB,QAAQ,aAAa;AAAA,gBACrB,UAAU;AAAA,cACd;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AACA,gBAAM,mBAAmB,cAAc;AAEvC,cAAI,CAAC,SAAS;AACV,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA,QAAQ;AAAA,gBACR,QAAQ;AAAA,gBACR,SAAS;AAAA,gBACT,QAAQ,aAAa;AAAA,gBACrB,UAAU;AAAA,cACd;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AACA,cAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,YAAY;AAChC,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA,QAAQ;AAAA,gBACR,QAAQ;AAAA,gBACR,SAAS;AAAA,gBACT,QAAQ,aAAa;AAAA,gBACrB,UAAU;AAAA,cACd;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AACA,cAAI,CAAC,eAAe;AAChB,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA,QAAQ;AAAA,gBACR,QAAQ;AAAA,gBACR,SAAS;AAAA,gBACT,QAAQ,aAAa;AAAA,gBACrB,UAAU;AAAA,cACd;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AAEA,gBAAM,aAAa,MAAM,2BAA2B,SAAS;AAC7D,cAAI,CAAC,WAAW,IAAI;AAChB,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA,QAAQ;AAAA,gBACR,QAAQ;AAAA,gBACR,SAAS,WAAW;AAAA,gBACpB,QAAQ,aAAa;AAAA,gBACrB,UAAU;AAAA,cACd;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AAEA,cAAI,WAAW,MAAM;AACjB,kBAAM,cAAc,MAAM;AAAA,cACtB;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA,WAAW;AAAA,YACf;AACA,gBAAI,CAAC,YAAY,IAAI;AACjB,mBAAK,KAAK;AAAA,gBACN,MAAM;AAAA,gBACN,SAAS;AAAA,kBACL,IAAI;AAAA,kBACJ;AAAA,kBACA;AAAA,kBACA,QAAQ;AAAA,kBACR,QAAQ,YAAY;AAAA,kBACpB,SAAS,YAAY;AAAA,kBACrB,QAAQ,WAAW;AAAA,kBACnB,UAAU;AAAA,gBACd;AAAA,cACJ,CAAC;AACD,qBAAO;AAAA,YACX;AAAA,UACJ;AAEA,cAAI,YAAY,CAAC,cAAc;AAC3B,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA,QAAQ;AAAA,gBACR,QAAQ;AAAA,gBACR,SACI;AAAA,gBACJ,QAAQ,WAAW;AAAA,gBACnB,UAAU;AAAA,cACd;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AACA,cAAI,YAAY,iBAAiB,YAAY;AACzC,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA,QAAQ;AAAA,gBACR,QAAQ;AAAA,gBACR,SACI;AAAA,gBACJ,QAAQ,WAAW;AAAA,gBACnB,UAAU;AAAA,cACd;AAAA,YACJ,CAAC;AACD,mBAAO;AAAA,UACX;AAEA,gBAAM,qBAAqB,WAAW;AACtC,gBAAM,mBAAmB,WAAW;AACpC,gBAAM,oBAAoB,mBACpB,GAAG,gBAAgB,IAAI,gBAAgB,KACvC;AACN,gBAAM,sBACD,MAAM,uBAAuB,KAAM;AACxC,gBAAM,yBACF,CAAC,CAAC,uBACF,oBAAoB,WAAW,cAC/B,oBAAoB,aAAa,qBACjC,oBAAoB,UAAU;AAElC,gBAAM,iBAAsC;AAAA,YACxC;AAAA,YACA;AAAA,YACA,QAAQ;AAAA,YACR,QAAQ,WAAW;AAAA,YACnB,UAAU;AAAA,YACV;AAAA,YACA;AAAA,YACA,iBAAiB,IAAI,QAAQ;AAAA,YAC7B,YAAY,IAAI,QAAQ;AAAA,YACxB;AAAA,YACA,QAAQ,WAAW,eAAe;AAAA,YAClC,SAAS,WAAW,UAAU;AAAA,YAC9B,QAAQ,WAAW,SAAS;AAAA,UAChC;AACA,cAAI;AACA,2BAAe,aAAa;AAChC,cAAI,cAAe,gBAAe,OAAO;AACzC,gBAAM,cAAc,cAAc;AAClC,gBAAM,gCAAgC;AAEtC,cAAI;AACA,kBAAM,QAAgD,CAAC;AAEvD,gBAAI,UAAU,OAAO;AACjB,oBAAM,MAAM,MAAM,KAAK,WAAW;AAAA,gBAC9B,QAAQ;AAAA,gBACR;AAAA,gBACA;AAAA,cACJ,CAAC;AACD,yBAAW,KAAK,IAAI;AAChB,sBAAM,KAAK,EAAE,MAAM,EAAE,MAAM,MAAM,EAAE,KAAK,CAAC;AAAA,YACjD,WAAW,UAAU,cAAc;AAC/B,oBAAM,OAAO,MAAM,KAAK,WAAW;AAAA,gBAC/B,QAAQ;AAAA,cACZ,CAAC;AACD,yBAAW,KAAK,KAAK;AACjB,sBAAM,KAAK,EAAE,MAAM,EAAE,MAAM,MAAM,EAAE,KAAK,CAAC;AAAA,YACjD,OAAO;AACH,kBAAI,CAAC,uBAAuB,CAAC,eAAe;AACxC,qBAAK,KAAK;AAAA,kBACN,MAAM;AAAA,kBACN,SAAS;AAAA,oBACL,IAAI;AAAA,oBACJ;AAAA,oBACA;AAAA,oBACA,QAAQ;AAAA,oBACR,QAAQ;AAAA,oBACR,SAAS;AAAA,oBACT,QAAQ;AAAA,oBACR,UAAU;AAAA,oBACV,UAAU;AAAA,kBACd;AAAA,gBACJ,CAAC;AACD,uBAAO;AAAA,cACX;AACA,oBAAM,MAAM,MAAM,KAAK,WAAW;AAAA,gBAC9B,QAAQ;AAAA,gBACR;AAAA,gBACA;AAAA,cACJ,CAAC;AACD,oBAAM,SAAS;AAAA,gBACX,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,cACJ;AACA,kBAAI,CAAC,QAAQ;AACT,sBAAM,YAAY,IAAI,MACjB,IAAI,CAAC,MAAM,EAAE,IAAI,EACjB,KAAK,IAAI;AACd,qBAAK,KAAK;AAAA,kBACN,MAAM;AAAA,kBACN,SAAS;AAAA,oBACL,IAAI;AAAA,oBACJ;AAAA,oBACA;AAAA,oBACA,QAAQ;AAAA,oBACR,QAAQ;AAAA,oBACR,SAAS,wBAAwB,mBAAmB,QAAQ,aAAa,kBAAkB,SAAS;AAAA,oBACpG,QAAQ;AAAA,oBACR,UAAU;AAAA,oBACV,UAAU;AAAA,kBACd;AAAA,gBACJ,CAAC;AACD,uBAAO;AAAA,cACX;AACA,oBAAM,KAAK,EAAE,MAAM,OAAO,MAAM,MAAM,OAAO,KAAK,CAAC;AAAA,YACvD;AAEA,gBAAI,MAAM,SAAS,GAAG;AAClB,mBAAK,KAAK;AAAA,gBACN,MAAM;AAAA,gBACN,SAAS;AAAA,kBACL,IAAI;AAAA,kBACJ;AAAA,kBACA;AAAA,kBACA,QAAQ;AAAA,kBACR,QAAQ;AAAA,kBACR,SACI;AAAA,kBACJ,QAAQ;AAAA,kBACR,UAAU;AAAA,kBACV,UAAU;AAAA,gBACd;AAAA,cACJ,CAAC;AACD,qBAAO;AAAA,YACX;AAEA,kBAAM,qBAAqB,CAAC,MACxB,KACA,OAAO,MAAM,YACb,CAAC,MAAM,QAAQ,CAAC,KAChB,OAAO,KAAK,CAAC,EAAE,WAAW;AAC9B,gBAAI,mBACA,MAAM,WAAW,KACjB,MAAM,MAAM,CAAC,MAAM,mBAAmB,EAAE,IAAI,CAAC;AAEjD,gBAAI,kBAAkB;AAClB,kBAAI,UAAU,cAAc;AACxB,sBAAM,iBACF;AACJ,qBAAK,KAAK;AAAA,kBACN,MAAM;AAAA,kBACN,SAAS;AAAA,oBACL,IAAI;AAAA,oBACJ;AAAA,oBACA;AAAA,oBACA,QAAQ;AAAA,oBACR,QAAQ;AAAA,oBACR,SAAS;AAAA,oBACT,QAAQ;AAAA,oBACR,UAAU;AAAA,oBACV,UAAU;AAAA,kBACd;AAAA,gBACJ,CAAC;AACD,uBAAO;AAAA,cACX;AACA,kBAAI,oBAAoB,UAAU,YAAY;AAC1C,sBAAM,OAAO,MAAM,KAAK;AAAA,kBACpB;AAAA,kBACA;AAAA,gBACJ;AACA,sBAAM,OAAO,KAAK,KACZ,SACI,KAAK,aACT,oBAAoB,mBAAmB,WACnC,UAAK,wBAAL,YAA4B,CAChC,qBAAqB,aAAa,OAClC,KAAK,WAAW;AACtB,qBAAK,KAAK;AAAA,kBACN,MAAM;AAAA,kBACN,SAAS;AAAA,oBACL,IAAI;AAAA,oBACJ;AAAA,oBACA;AAAA,oBACA,QAAQ;AAAA,oBACR,QAAQ;AAAA,oBACR,SAAS,eAAe,mBAAmB,QAAQ,aAAa,oCAAoC,IAAI;AAAA,oBACxG,QAAQ;AAAA,oBACR,UAAU;AAAA,oBACV,UAAU;AAAA,kBACd;AAAA,gBACJ,CAAC;AACD,uBAAO;AAAA,cACX;AACA,kBAAI,kBAAkB;AAClB,qBAAK,KAAK;AAAA,kBACN,MAAM;AAAA,kBACN,SAAS;AAAA,oBACL,IAAI;AAAA,oBACJ;AAAA,oBACA;AAAA,oBACA,QAAQ;AAAA,oBACR,QAAQ;AAAA,oBACR,SACI;AAAA,oBACJ,QAAQ;AAAA,oBACR,UAAU;AAAA,oBACV,UAAU;AAAA,kBACd;AAAA,gBACJ,CAAC;AACD,uBAAO;AAAA,cACX;AAAA,YACJ;AAEA,kBAAM,mBAAmB,CACrB,aACS;AACT,oBAAM,OACF,YAAY,OAAO,aAAa,WAC1B,WACA;AACV,oBAAM,IAAI,KAAK,MAAM,gCAAgC;AACrD,kBAAI,EAAG,QAAO,GAAG,EAAE,CAAC,EAAE,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,KAAK,CAAC;AAC7C,qBAAO,KAAK,SAAS,OAAO,IAAI,OAAO,OAAO;AAAA,YAClD;AACA,kBAAM,SAAS,mBACT,mBAAmB,MACnB;AACN,kBAAM,cAAc,MAAM,IAAI,CAAC,MAAM;AACjC,oBAAM,eACF,MAAM,WAAW,IACX,mBACA,iBAAiB,EAAE,IAAI;AACjC,qBAAO;AAAA,gBACH,MAAM,SAAS;AAAA,gBACf,SAAS,KAAK,UAAU,EAAE,MAAM,MAAM,CAAC,IAAI;AAAA,cAC/C;AAAA,YACJ,CAAC;AAED,kBAAM,sBAAsB,CAAC,SACzB,KAAK,QAAQ,SAAS,IAAI,EAAE,QAAQ;AACxC,kBAAM,eAAe,CACjB,SACsB;AACtB,kBAAI;AACA,uBAAO,KAAK,MAAM,IAAI;AAAA,cAC1B,SAAQ;AACJ,uBAAO;AAAA,cACX;AAAA,YACJ;AACA,kBAAM,mBAAmB,CAAC,UAA4B;AAClD,kBAAI,MAAM,QAAQ,KAAK,GAAG;AACtB,uBAAO,MAAM,IAAI,CAAC,SAAS,iBAAiB,IAAI,CAAC;AAAA,cACrD;AACA,kBAAI,SAAS,OAAO,UAAU,UAAU;AACpC,sBAAM,QAAQ,OAAO,eAAe,KAAK;AACzC,oBAAI,UAAU,OAAO,aAAa,UAAU,MAAM;AAC9C,wBAAM,SAAS;AACf,wBAAM,aAAa,OAAO,KAAK,MAAM,EAAE,KAAK;AAC5C,wBAAM,YAAqC,CAAC;AAC5C,6BAAW,OAAO;AACd,8BAAU,GAAG,IAAI;AAAA,sBACb,OAAO,GAAG;AAAA,oBACd;AACJ,yBAAO;AAAA,gBACX;AAAA,cACJ;AACA,qBAAO;AAAA,YACX;AACA,kBAAM,2BAA2B,CAAC,SAA0B;AACxD,oBAAM,SAAS,aAAa,IAAI;AAChC,oBAAM,gBAAgB,CAAC,UAA4B;AAC/C,oBAAI,CAAC,MAAO,QAAO;AACnB,oBAAI,OAAO,UAAU,UAAU;AAC3B,yBAAO,MAAM,YAAY,MAAM;AAAA,gBACnC;AACA,oBAAI,OAAO,UAAU,UAAU;AAC3B,sBACI,OAAO,UAAU,eAAe;AAAA,oBAC5B;AAAA,oBACA;AAAA,kBACJ,GACF;AACE,0BAAM,IAAK,MAER,OAAO;AACV,wBACI,OAAO,MAAM,YACb,EAAE,YAAY,MAAM,cACtB;AACE,6BAAO;AAAA,oBACX;AAAA,kBACJ;AACA,6BAAW,OAAO,OAEf;AACC,wBACI,OAAO,UAAU,eAAe;AAAA,sBAC5B;AAAA,sBACA;AAAA,oBACJ,KACA;AAAA,sBACK,MAEE,GAAG;AAAA,oBACV,GACF;AACE,6BAAO;AAAA,oBACX;AAAA,kBACJ;AAAA,gBACJ;AACA,uBAAO;AAAA,cACX;AACA,kBAAI,WAAW,QAAW;AACtB,uBAAO,cAAc,MAAM;AAAA,cAC/B;AACA,qBAAO,+BAA+B,KAAK,IAAI;AAAA,YACnD;AACA,kBAAM,gBAAgB,CAClB,UACA,gBACU;AACV,kBAAI,aAAa,YAAa,QAAO;AACrC,kBACI,oBAAoB,QAAQ,MAC5B,oBAAoB,WAAW;AAE/B,uBAAO;AACX,oBAAM,eAAe,aAAa,QAAQ;AAC1C,oBAAM,WAAW,aAAa,WAAW;AACzC,kBACI,iBAAiB,UACjB,aAAa,QACf;AACE,uBACI,KAAK;AAAA,kBACD,iBAAiB,YAAY;AAAA,gBACjC,MAAM,KAAK,UAAU,iBAAiB,QAAQ,CAAC;AAAA,cAEvD;AACA,qBAAO;AAAA,YACX;AAEA,gBAAI,oBAAoB,YAAY,SAAS;AAC7C,uBAAW,QAAQ,aAAa;AAC5B,oBAAM,UAAU,MAAM;AAAA,gBAClB;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,KAAK;AAAA,cACT;AACA,kBAAI,CAAC,QAAQ,IAAI;AACb,oBAAI,QAAQ,WAAW,KAAK;AACxB,sCAAoB;AACpB;AAAA,gBACJ;AAEA,oCAAoB;AACpB;AAAA,cACJ;AACA,kBACI,UAAU,gBACV,yBAAyB,KAAK,OAAO,KACrC,CAAC,yBAAyB,QAAQ,WAAW,GAC/C;AACE,oCAAoB;AACpB;AAAA,cACJ;AACA,kBAAI,CAAC,cAAc,QAAQ,aAAa,KAAK,OAAO,GAAG;AACnD,oCAAoB;AACpB;AAAA,cACJ;AAAA,YACJ;AAEA,gBAAI,qBAAqB,CAAC,wBAAwB;AAC9C,kCAAoB;AAAA,YACxB;AAEA,gBAAI,mBAAmB;AACnB,oBAAM,kBACF,UAAU,aACJ,gCAAgC,mBAAmB,QAAQ,aAAa,sDACxE;AACV,mBAAK,KAAK;AAAA,gBACN,MAAM;AAAA,gBACN,SAAS;AAAA,kBACL,IAAI;AAAA,kBACJ;AAAA,kBACA;AAAA,kBACA,QAAQ;AAAA,kBACR,QAAQ;AAAA,kBACR,SAAS;AAAA,kBACT,QAAQ;AAAA,kBACR,UAAU;AAAA,kBACV,UAAU;AAAA,gBACd;AAAA,cACJ,CAAC;AACD,qBAAO;AAAA,YACX;AAEA,kBAAM,gBAAgB,YAClB;AAAA,cACI;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACJ;AACJ,gBAAI,YAAY,MAAM,cAAc;AACpC,gBAAI,mBAAmB;AACvB,gBACI,CAAC,UAAU,MACX,UAAU,WAAW,OACrB,OAAO,UAAU,YAAY,YAC7B,sBAAsB,KAAK,UAAU,OAAO,GAC9C;AACE,oBAAM,MAAM,GAAG;AACf,0BAAY,MAAM,cAAc;AAChC,iCAAmB;AAAA,YACvB;AACA,gBAAI,CAAC,UAAU,IAAI;AACf,oBAAM,2BACF,UAAU,WAAW,OACrB,OAAO,UAAU,YAAY,YAC7B,sBAAsB,KAAK,UAAU,OAAO;AAChD,kBAAI,4BAA4B,wBAAwB;AACpD,sBAAM,kBACF,UAAU,aACJ,gCAAgC,mBAAmB,QAAQ,aAAa,sDACxE;AACV,qBAAK,KAAK;AAAA,kBACN,MAAM;AAAA,kBACN,SAAS;AAAA,oBACL,IAAI;AAAA,oBACJ;AAAA,oBACA;AAAA,oBACA,QAAQ;AAAA,oBACR,QAAQ;AAAA,oBACR,SAAS;AAAA,oBACT,QAAQ;AAAA,oBACR,UAAU;AAAA,oBACV,UAAU;AAAA,kBACd;AAAA,gBACJ,CAAC;AACD,uBAAO;AAAA,cACX;AACA,mBAAK,KAAK;AAAA,gBACN,MAAM;AAAA,gBACN,SAAS,iCACF,YADE;AAAA,kBAEL,QAAQ;AAAA,kBACR,UAAU;AAAA,kBACV,UAAU;AAAA,gBACd;AAAA,cACJ,CAAC;AACD,mBAAK,KAAK;AAAA,gBACN,MAAM;AAAA,gBACN,SAAS;AAAA,kBACL,SAAS,0BAA0B,UAAU,MAAM,MAAM,UAAU,OAAO,GACtE,mBACM,mBACA,EACV;AAAA,gBACJ;AAAA,cACJ,CAAC;AACD,qBAAO;AAAA,YACX;AAEA,kBAAM,uBAAuB;AAAA,cACzB,QAAQ;AAAA,cACR,UAAU;AAAA,cACV;AAAA,YACJ,CAAC;AAED,gBAAI;AAGJ,gBAAI,UAAU;AACV,yBAAW,MAAM;AAAA,gBACb;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA;AAAA,kBACI,OAAO;AAAA,kBACP,MAAM;AAAA,kBACN,MAAM;AAAA,kBACN,MAAM;AAAA,gBACV;AAAA,cACJ;AAAA,YACJ;AAEA,kBAAM,kBAAkB;AAAA,cACpB,IAAI;AAAA,cACJ;AAAA,cACA;AAAA,cACA,QAAQ;AAAA,cACR,QAAQ;AAAA,cACR,UAAU;AAAA,cACV,UAAU;AAAA,cACV,WAAW,UAAU;AAAA,cACrB,WAAW,UAAU;AAAA,cACrB,SAAS,UAAU;AAAA,cACnB,MAAM,UAAU;AAAA,cAChB,WACI,YAAY,SAAS,KACf;AAAA,gBACI,QAAQ,SAAS;AAAA,gBACjB,KAAK,SAAS;AAAA,gBACd,MAAM,SAAS;AAAA,gBACf,MAAM,SAAS;AAAA,cACnB,IACA;AAAA,YACd;AACA,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,YACb,CAAC;AAED,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,SAAS,aAAa,YAAY,MAAM,eAAe,KAAK,IAAI,IAAI,IAAI,UAAU;AAAA,cACtF;AAAA,YACJ,CAAC;AACD,gBAAI,UAAU;AACV,kBAAI,YAAY,SAAS,IAAI;AACzB,qBAAK,KAAK;AAAA,kBACN,MAAM;AAAA,kBACN,SAAS;AAAA,gBACb,CAAC;AACD,qBAAK,KAAK;AAAA,kBACN,MAAM;AAAA,kBACN,SAAS;AAAA,oBACL,SAAS,eAAe,SAAS,GAAG;AAAA,kBACxC;AAAA,gBACJ,CAAC;AAAA,cACL,WAAW,UAAU;AACjB,qBAAK,KAAK;AAAA,kBACN,MAAM;AAAA,kBACN,SAAS;AAAA,gBACb,CAAC;AACD,qBAAK,KAAK;AAAA,kBACN,MAAM;AAAA,kBACN,SAAS;AAAA,oBACL,SAAS,+BAA+B,SAAS,MAAM,MAAM,SAAS,OAAO;AAAA,kBACjF;AAAA,gBACJ,CAAC;AAAA,cACL;AAAA,YACJ;AAAA,UACJ,SAAS,GAAG;AACR,kBAAM,WAAW,uBAAa,YAAW;AACzC,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,SAAS;AAAA,gBACL,IAAI;AAAA,gBACJ;AAAA,gBACA;AAAA,gBACA,QAAQ;AAAA,gBACR,QAAQ;AAAA,gBACR,SAAS;AAAA,gBACT,QAAQ;AAAA,gBACR,UAAU;AAAA,gBACV,UAAU;AAAA,cACd;AAAA,YACJ,CAAC;AAAA,UACL;AACA,iBAAO;AAAA,QACX;AAAA,QAEA;AACI,iBAAO;AAAA,MACf;AAAA,IACJ;AAEA,mBAAe,YAA2B;AACtC,YAAM,4BAA4B;AAClC,YAAM,MAAM,MAAM,YAAY;AAC9B,UAAI,IAAI,SAAS,IAAI,MAAM;AACvB,aAAK,KAAK,EAAE,MAAM,2BAA2B,SAAS,IAAI,CAAC;AAAA,MAC/D;AAAA,IACJ;AAEA,WAAO,EAAE,QAAQ,UAAU;AAAA,EAC/B;;;AC70DA,GAAC,eAAe,SAAS;AACrB,QAAI,IAAI,KACJ,IAAI;AACR,QAAI;AACA,YAAM,QAAQ,MAAM,MAAM,cAAc,SAAS,QAAQ;AACzD,UACI,SACA,OAAO,MAAM,UAAU,YACvB,OAAO,MAAM,WAAW,UAC1B;AACE,cAAM,KAAK,KAAK,MAAM,MAAM,KAAK;AACjC,cAAM,KAAK,KAAK,MAAM,MAAM,MAAM;AAClC,YAAI,KAAK,IAAI,KAAK,KAAK,IAAI,MAAM,EAAE,CAAC;AACpC,YAAI,KAAK,IAAI,KAAK,KAAK,IAAI,MAAM,EAAE,CAAC;AAAA,MACxC;AAAA,IACJ,SAAQ;AAAA,IAER;AACA,UAAM,OAAO,yonKAAU,EAAE,OAAO,GAAG,QAAQ,EAAE,CAAC;AAAA,EAClD,GAAG;AAEH,WAAS,KAAK,KAAuB;AACjC,UAAM,GAAG,YAAY,GAAG;AAAA,EAC5B;AAEA,MAAM,SAAS,uBAAuB;AAAA,IAClC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ,CAAC;AAWD,MAAM,4BAA4B;AAClC,MAAM,+BAA+B;AACrC,MAAM,4BAA4B;AAClC,MAAM,2BAA2B;AAEjC,MAAI,iBAAiB;AACrB,MAAI,mBAAyD;AAC7D,MAAI,uBAAuB;AAC3B,MAAI,qBAAqB;AACzB,MAAI,oBAA0D;AAE9D,MAAI,yBAAyB;AAC7B,MAAI,wBAAuE;AAC3E,MAAI,qBAAiE;AACrE,MAAI,2BAA0C;AAC9C,MAAI,+BAA8C;AAClD,MAAI,2BAAqD;AACzD,MAAM,qBAAqB,oBAAI,IAS7B;AACF,MAAM,kBAAkB,oBAAI,IAAoB;AAChD,MAAM,gBAAgB,oBAAI,IAAY;AAEtC,WAAS,uCACL,SACM;AACN,UAAM,QAAkB,CAAC;AACzB,UAAM,eAAe,QAAQ,eAAe,CAAC,GACxC,MAAM,EACN,KAAK,CAAC,GAAG,MAAM,EAAE,GAAG,cAAc,EAAE,EAAE,CAAC;AAC5C,aAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AACzC,YAAM,MAAM,YAAY,CAAC;AACzB,UAAI,CAAC,IAAK;AACV,YAAM,KAAK,IAAI,IAAI,IAAI,IAAI;AAC3B,YAAM,SAAS,IAAI,SAAS,CAAC,GACxB,MAAM,EACN,KAAK,CAAC,GAAG,MAAM,EAAE,GAAG,cAAc,EAAE,EAAE,CAAC;AAC5C,eAAS,KAAK,GAAG,KAAK,MAAM,QAAQ,MAAM;AACtC,cAAM,OAAO,MAAM,EAAE;AACrB,cAAM,KAAK,KAAK,IAAI,KAAK,IAAI;AAAA,MACjC;AACA,YAAM,aAAa,IAAI,aAAa,CAAC,GAChC,MAAM,EACN,KAAK,CAAC,GAAG,MAAM,EAAE,GAAG,cAAc,EAAE,EAAE,CAAC;AAC5C,eAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,cAAM,WAAW,UAAU,EAAE;AAC7B,cAAM,KAAK,SAAS,IAAI,SAAS,MAAM,SAAS,IAAI;AAAA,MACxD;AAAA,IACJ;AACA,WAAO,MAAM,KAAK,GAAG;AAAA,EACzB;AAEA,iBAAe,0BAKZ;AACC,UAAM,OAAO,MAAM,yBAAyB;AAC5C,UAAM,OAAO,MAAM,MAAM,cACpB,SAAS,eAAe,EACxB,MAAM,MAAM,IAAI;AACrB,UAAM,mBAAmB,MAAM,MAAM,cAChC,SAAS,eAAe,EACxB,MAAM,MAAM,KAAK;AACtB,UAAM,yBAAyB,MAAM,MAAM,cACtC,SAAS,qBAAqB,EAC9B,MAAM,MAAM,KAAK;AACtB,UAAM,oBAAoB,MAAM,MAAM,cACjC,SAAS,gBAAgB,EACzB,MAAM,MAAM,KAAK;AACtB,UAAM,qBAAqB,MAAM,MAAM,cAClC,SAAS,cAAc,EACvB,MAAM,MAAM,IAAI;AACrB,UAAM,2BAA2B,MAAM,MAAM,cACxC,SAAS,oBAAoB,EAC7B,MAAM,MAAM,IAAI;AACrB,UAAM,kBACF,OAAO,uBAAuB,YAAY,qBAAqB;AACnE,UAAM,wBACF,OAAO,6BAA6B,YAC9B,2BACA;AACV,UAAM,aACF,QACA,OAAO,KAAK,eAAe,YAC3B,OAAO,KAAK,SAAS,WACf,OACA;AAEV,UAAM,UAAkC;AAAA,MACpC,aAAa,KAAK;AAAA,MAClB,MAAM;AAAA,MACN,eAAe,CAAC,CAAC;AAAA,MACjB,qBAAqB,CAAC,CAAC;AAAA,MACvB,gBAAgB,CAAC,CAAC;AAAA,MAClB,cAAc;AAAA,MACd,oBAAoB;AAAA,IACxB;AAEA,WAAO;AAAA,MACH;AAAA,MACA,SAAS,KAAK;AAAA,MACd,OAAO,KAAK,YAAY;AAAA,MACxB,WAAW,uCAAuC,OAAO;AAAA,IAC7D;AAAA,EACJ;AAEA,iBAAe,mBACX,QACA,YACa;AACb,UAAM,eAAe,IAAI,IAAI,aAAa;AAC1C,QAAI;AACA,YAAM,OAAO,MAAM,wBAAwB;AAC3C,YAAM,YAAY,WAAW;AAC7B,UAAI,WAAW;AACX,YAAI,UAAU;AACd,YAAI,WAAW,WAAW;AACtB,oBACI,aAAa,OAAO,KAAK,KAAK,IAAI;AAAA,QAC1C,WAAW,WAAW,UAAU;AAC5B,oBAAU,aAAa,OAAO,KAAK,KAAK,IAAI;AAAA,QAChD,WAAW,eAAe,eAAe;AACrC,oBACI,yCACA,OAAO,KAAK,KAAK,IACjB;AAAA,QACR;AACA,YAAI,SAAS;AACT,eAAK,EAAE,MAAM,QAAQ,SAAS,EAAE,QAAQ,EAAE,CAAC;AAAA,QAC/C;AAAA,MACJ;AACA,WAAK,EAAE,MAAM,oBAAoB,SAAS,KAAK,QAAQ,CAAC;AACxD,WAAK,EAAE,MAAM,wBAAwB,SAAS,EAAE,MAAM,KAAK,QAAQ,EAAE,CAAC;AACtE,iCAA2B,KAAK;AAChC,qCAA+B;AAC/B,YAAM,eAAe,uBAAuB;AAC5C,oBAAc,MAAM;AACpB,mBAAa,QAAQ,CAAC,OAAO,cAAc,IAAI,EAAE,CAAC;AAClD,0BAAoB,cAAc,YAAY;AAAA,IAClD,SAAS,KAAK;AACV,YAAM,WAAW,2BAAe,YAAW;AAC3C,WAAK;AAAA,QACD,MAAM;AAAA,QACN,SAAS,EAAE,SAAS,oCAAoC,QAAQ;AAAA,MACpE,CAAC;AAAA,IACL;AAAA,EACJ;AAEA,iBAAe,sCAA8D;AACzE,QACI,CAAC,MAAM,aACP,OAAO,MAAM,UAAU,qCAAqC,YAC9D;AACE,aAAO;AAAA,IACX;AAEA,UAAM,cACF,MAAM,MAAM,UAAU,iCAAiC;AAC3D,UAAM,aAAuB,CAAC;AAC9B,UAAM,qBAAqB,eAAe,CAAC,GACtC,MAAM,EACN,KAAK,CAAC,GAAG,MAAM,EAAE,GAAG,cAAc,EAAE,EAAE,CAAC;AAC5C,aAAS,IAAI,GAAG,IAAI,kBAAkB,QAAQ,KAAK;AAC/C,YAAM,MAAM,kBAAkB,CAAC;AAC/B,UAAI,CAAC,IAAK;AACV,iBAAW,KAAK,IAAI,IAAI,IAAI,MAAM,IAAI,aAAa;AACnD,YAAM,SAAS,IAAI,SAAS,CAAC,GACxB,MAAM,EACN,KAAK,CAAC,GAAG,MAAM,EAAE,OAAO,cAAc,EAAE,MAAM,CAAC;AACpD,eAAS,KAAK,GAAG,KAAK,MAAM,QAAQ,MAAM;AACtC,cAAM,OAAO,MAAM,EAAE;AACrB,mBAAW,KAAK,KAAK,QAAQ,KAAK,IAAI;AAAA,MAC1C;AACA,YAAM,QAAQ,IAAI,eAAe,CAAC,GAAG,MAAM,EAAE,KAAK;AAClD,eAAS,KAAK,GAAG,KAAK,KAAK,QAAQ,KAAM,YAAW,KAAK,KAAK,EAAE,CAAC;AAAA,IACrE;AAEA,QAAI,OAAO,MAAM,UAAU,2BAA2B,YAAY;AAC9D,YAAM,UAAU,MAAM,MAAM,UAAU,uBAAuB;AAC7D,YAAM,cAAc,WAAW,CAAC,GAC3B,MAAM,EACN,KAAK,CAAC,GAAG,MAAM,EAAE,GAAG,cAAc,EAAE,EAAE,CAAC;AAC5C,eAAS,KAAK,GAAG,KAAK,WAAW,QAAQ,MAAM;AAC3C,cAAM,WAAW,WAAW,EAAE;AAC9B,YAAI,CAAC,SAAU;AACf,mBAAW;AAAA,UACP,SAAS;AAAA,UACT,SAAS;AAAA,UACT,SAAS;AAAA,UACT,SAAS;AAAA,UACT,wBAAwB,SAAS,YAAY;AAAA,QACjD;AAAA,MACJ;AAAA,IACJ;AAEA,WAAO,WAAW,KAAK,GAAG;AAAA,EAC9B;AAEA,WAAS,wBACL,QACM;AACN,QAAI,CAAC,OAAQ,QAAO;AACpB,UAAM,QAAkB,CAAC;AACzB,UAAM,UAAU,OAAO,KAAK,MAAM,EAAE,KAAK;AACzC,aAAS,KAAK,GAAG,KAAK,QAAQ,QAAQ,MAAM;AACxC,YAAM,SAAS,QAAQ,EAAE;AACzB,YAAM,KAAK,QAAQ,oBAAoB,OAAO,MAAM,CAAC,CAAC;AAAA,IAC1D;AACA,WAAO,MAAM,KAAK,GAAG;AAAA,EACzB;AAEA,WAAS,oBAAoB,OAAwB;AACjD,QAAI,UAAU,QAAQ,OAAO,UAAU,YAAa,QAAO;AAC3D,QAAI,OAAO,UAAU,YAAY,OAAO,UAAU;AAC9C,aAAO,OAAO,KAAK;AACvB,QAAI,OAAO,UAAU,SAAU,QAAO;AACtC,QAAI;AACA,aAAO,KAAK,UAAU,KAAK;AAAA,IAC/B,SAAQ;AACJ,aAAO;AAAA,IACX;AAAA,EACJ;AAEA,iBAAe,6BAA+C;AAC1D,QAAI;AACA,YAAM,YAAY,MAAM,oCAAoC;AAC5D,UAAI,CAAC,UAAW,QAAO;AACvB,UAAI,6BAA6B,MAAM;AACnC,uCAA+B;AAC/B,eAAO;AAAA,MACX;AACA,UAAI,cAAc,yBAA0B,QAAO;AACnD,UACI,gCACA,iCAAiC;AAEjC,eAAO;AACX,qCAA+B;AAC/B,aAAO;AAAA,IACX,SAAQ;AACJ,aAAO;AAAA,IACX;AAAA,EACJ;AAEA,WAAS,sBACL,QACO;AACP,QAAI,CAAC,OAAQ,QAAO;AACpB,WACI,OAAO,SAAS,kBAChB,OAAO,SAAS,kBAChB,OAAO,SAAS;AAAA,EAExB;AAEA,WAAS,0BAA0B,OAAkC;AACjE,QAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,MAAM,gBAAiB;AACzD,UAAM,OAAO,MAAM;AACnB,QAAI,iBAAiB;AACrB,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AAClC,YAAM,SAAS,KAAK,CAAC;AACrB,UAAI,sBAAsB,MAAM,GAAG;AAC/B,yBAAiB,iCAAQ,MAAM,iCAAQ,EAAE;AACzC,yBAAiB;AAAA,MACrB;AAAA,IACJ;AACA,QAAI,gBAAgB;AAChB,yBAAmB,aAAa;AAAA,IACpC;AAAA,EACJ;AAEA,WAAS,uBAAuB,OAA+B;AAC3D,QAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,MAAM,aAAc;AACtD,UAAM,OAAO,MAAM;AACnB,QAAI,iBAAiB;AACrB,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AAClC,YAAM,SAAS,KAAK,CAAC;AACrB,UAAI,CAAC,UAAU,CAAC,OAAO,KAAM;AAC7B,uBAAiB,OAAO,MAAM,OAAO,EAAE;AACvC,uBAAiB;AAAA,IACrB;AACA,QAAI,gBAAgB;AAChB,yBAAmB,aAAa;AAAA,IACpC;AAAA,EACJ;AAEA,WAAS,iBAAiB,KAAwC;AAC9D,QAAI,CAAC,IAAK,QAAO;AACjB,UAAM,MAAM,IAAI,QAAQ,GAAG;AAC3B,WAAO,OAAO,IAAI,IAAI,MAAM,GAAG,GAAG,IAAI;AAAA,EAC1C;AAEA,WAAS,iBACL,MACA,OACI;AACJ,QAAI,CAAC,KAAM;AACX,UAAM,KAAK,iBAAiB,KAAK;AACjC,QAAI,CAAC,GAAI;AACT,QACI,SAAS,kBACT,SAAS,kBACT,SAAS,yBACX;AACE;AAAA,IACJ;AACA,QAAI,MAAO,iBAAgB,IAAI,IAAI,KAAK;AACxC,UAAM,QAAQ,mBAAmB,IAAI,EAAE,KAAK,CAAC;AAC7C,QAAI,SAAS,gBAAgB;AACzB,YAAM,SAAS;AACf,YAAM,SAAS;AACf,YAAM,SAAS;AACf,YAAM,eAAe;AAAA,IACzB,WAAW,SAAS,yBAAyB;AACzC,UAAI,CAAC,MAAM,QAAQ;AACf,cAAM,SAAS;AACf,YAAI,CAAC,MAAM,gBAAgB,cAAc,IAAI,EAAE,GAAG;AAC9C,0BAAgB,iBAAiB,gBAAgB,IAAI,EAAE,KAAK,EAAE;AAC9D,gBAAM,eAAe;AAAA,QACzB;AAAA,MACJ;AAAA,IACJ,WAAW,SAAS,gBAAgB;AAChC,YAAM,SAAS;AAAA,IACnB;AACA,UAAM,WAAW,MAAM,YAAY;AACnC,uBAAmB,IAAI,IAAI,KAAK;AAAA,EACpC;AAEA,WAAS,yBAAsC;AAC3C,UAAM,MAAM,oBAAI,IAAY;AAC5B,QAAI;AACA,YAAM,UAAU,CACZ,WACC;AACD,YAAI,CAAC,OAAQ;AACb,iBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACpC,gBAAM,QAAQ,OAAO,CAAC;AACtB,cAAI,CAAC,SAAS,OAAO,MAAM,OAAO,SAAU;AAC5C,gBAAM,OAAO,iBAAiB,MAAM,EAAE,KAAK,MAAM;AACjD,cAAI,IAAI,IAAI;AAAA,QAChB;AAAA,MACJ;AACA,UAAI,OAAO,MAAM,wBAAwB;AACrC,gBAAQ,MAAM,oBAAoB,CAAC;AACvC,UAAI,OAAO,MAAM,uBAAuB;AACpC,gBAAQ,MAAM,mBAAmB,CAAC;AACtC,UAAI,OAAO,MAAM,yBAAyB;AACtC,gBAAQ,MAAM,qBAAqB,CAAC;AACxC,UAAI,OAAO,MAAM,uBAAuB;AACpC,gBAAQ,MAAM,mBAAmB,CAAC;AAAA,IAC1C,SAAQ;AAAA,IAER;AACA,WAAO;AAAA,EACX;AAEA,WAAS,oBAAoB,MAAmB,MAAyB;AACrE,QAAI,mBAAmB,SAAS,EAAG;AACnC,UAAM,YAAY,oBAAI,IAQpB;AACF,uBAAmB,QAAQ,CAAC,OAAO,OAAO;AACtC,YAAM,UAAU,KAAK,IAAI,EAAE;AAC3B,YAAM,UAAU,KAAK,IAAI,EAAE;AAC3B,UAAI,UAAU;AACd,UAAI,MAAM,UAAU,WAAW,CAAC,SAAS;AACrC,wBAAgB,iBAAiB,gBAAgB,IAAI,EAAE,KAAK,EAAE;AAC9D,kBAAU;AAAA,MACd,WAAW,MAAM,UAAU,CAAC,WAAW,SAAS;AAC5C,wBAAgB,iBAAiB,gBAAgB,IAAI,EAAE,KAAK,EAAE;AAC9D,kBAAU;AAAA,MACd,WACI,MAAM,UACN,CAAC,MAAM,UACP,CAAC,MAAM,gBACP,WACA,SACF;AACE,wBAAgB,iBAAiB,gBAAgB,IAAI,EAAE,KAAK,EAAE;AAC9D,kBAAU;AAAA,MACd;AACA,UAAI,CAAC,SAAS;AACV,cAAM,YAAY,MAAM,YAAY,KAAK;AACzC,YAAI,WAAW,GAAG;AACd,oBAAU,IAAI,IAAI,iCAAK,QAAL,EAAY,SAAS,EAAC;AAAA,QAC5C;AAAA,MACJ;AAAA,IACJ,CAAC;AACD,uBAAmB,MAAM;AACzB,cAAU,QAAQ,CAAC,OAAO,QAAQ,mBAAmB,IAAI,KAAK,KAAK,CAAC;AAAA,EACxE;AAEA,WAAS,gBAAgB,QAAgB,KAAmB;AACxD,SAAK,EAAE,MAAM,QAAQ,SAAS,EAAE,SAAS,OAAO,EAAE,CAAC;AAAA,EACvD;AAEA,WAAS,mBAAmB,QAAiC;AACzD,QAAI,CAAC,eAAgB;AACrB,2BAAuB;AACvB,QAAI,WAAW,eAAe;AAC1B,iCAA2B;AAAA,IAC/B,WAAW,6BAA6B,eAAe;AACnD,iCAA2B;AAAA,IAC/B;AACA,QAAI,qBAAqB,KAAM;AAC/B,uBAAmB,WAAW,gBAAgB,wBAAwB;AAAA,EAC1E;AAEA,iBAAe,iBAAgC;AAC3C,uBAAmB;AACnB,QAAI,CAAC,gBAAgB;AACjB,6BAAuB;AACvB;AAAA,IACJ;AACA,QAAI,CAAC,qBAAsB;AAC3B,QAAI,oBAAoB;AACpB,UAAI,qBAAqB,MAAM;AAC3B,2BAAmB;AAAA,UACf;AAAA,UACA;AAAA,QACJ;AAAA,MACJ;AACA;AAAA,IACJ;AAEA,2BAAuB;AACvB,yBAAqB;AACrB,QAAI;AACA,YAAM,SAAS;AACf,iCAA2B;AAC3B,YAAM,mBAAmB,QAAQ,MAAM;AAAA,IAC3C,UAAE;AACE,2BAAqB;AACrB,UACI,kBACA,wBACA,qBAAqB,MACvB;AACE,2BAAmB;AAAA,UACf;AAAA,UACA;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAIA,WAAS,qBACL,UAAkB,2BACd;AACJ,QAAI,CAAC,kBAAkB,sBAAsB,KAAM;AACnD,wBAAoB,WAAW,YAAY;AACvC,0BAAoB;AACpB,UAAI,CAAC,eAAgB;AACrB,UAAI,eAAe;AACnB,UAAI;AACA,uBAAe,MAAM,2BAA2B;AAAA,MACpD,SAAQ;AACJ,uBAAe;AAAA,MACnB;AACA,UAAI,cAAc;AACd,2BAAmB,eAAe;AAClC,iCAAyB;AACzB,6BAAqB,4BAA4B;AAAA,MACrD,OAAO;AACH,YAAI,yBAAyB,GAAG;AAC5B;AACA,+BAAqB,4BAA4B;AAAA,QACrD,OAAO;AACH,+BAAqB,yBAAyB;AAAA,QAClD;AAAA,MACJ;AAAA,IACJ,GAAG,OAAO;AAAA,EACd;AAEA,WAAS,yBAA+B;AACpC,QAAI,eAAgB;AACpB,qBAAiB;AACjB,4BAAwB;AACxB,UAAM,GAAG,kBAAkB,yBAAyB;AACpD,QAAI,OAAO,MAAM,OAAO,YAAY;AAChC,2BAAqB;AACrB,YAAM,GAAG,eAAe,sBAAsB;AAAA,IAClD;AACA,yBAAqB;AAAA,EACzB;AAEA,WAAS,wBAA8B;AACnC,QAAI,CAAC,eAAgB;AACrB,qBAAiB;AACjB,QAAI,uBAAuB;AACvB,YAAM,IAAI,kBAAkB,qBAAqB;AACjD,8BAAwB;AAAA,IAC5B;AACA,QAAI,oBAAoB;AACpB,YAAM,IAAI,eAAe,kBAAkB;AAC3C,2BAAqB;AAAA,IACzB;AACA,QAAI,sBAAsB,MAAM;AAC5B,mBAAa,iBAAiB;AAC9B,0BAAoB;AAAA,IACxB;AACA,2BAAuB;AACvB,QAAI,qBAAqB,MAAM;AAC3B,mBAAa,gBAAgB;AAC7B,yBAAmB;AAAA,IACvB;AACA,yBAAqB;AACrB,+BAA2B;AAC3B,uBAAmB,MAAM;AACzB,oBAAgB,MAAM;AACtB,kBAAc,MAAM;AAAA,EACxB;AAEA,QAAM,GAAG,SAAS,MAAM;AACpB,0BAAsB;AAAA,EAC1B,CAAC;AASD,iBAAe,cAAc,MAAiC;AAC1D,UAAM,mBAAmB,SAAS;AAClC,UAAM,OAAO,UAAU;AACvB,2BAAuB;AAAA,EAC3B;AAGA,iBAAe,uBAAuB,MAAiC;AACnE,UAAM,mBAAmB,QAAQ;AAAA,EACrC;AAGA,iBAAe,iBAAiB,KAAgC;AAC5D,UAAM,UAAW,IAAqC;AACtD,UAAM,WAAW,MAAM,QAAQ,QAAQ,QAAQ,IACzC,QAAQ,SAAS,IAAI,CAAC,MAAM,OAAO,CAAC,CAAC,IACrC,CAAC;AACP,UAAM,UAAU,MAAM,WAAW,QAAQ,MAAM;AAAA,MAC3C,iBAAiB,CAAC,CAAC,QAAQ;AAAA,MAC3B;AAAA,IACJ,CAAC;AAED,UAAM,eAAe,QAAQ,gBAAgB;AAC7C,QAAI,eAAe,GAAG;AAClB,WAAK;AAAA,QACD,MAAM;AAAA,QACN,SAAS;AAAA,UACL,SAAS,6BAA6B,QAAQ,gBAAgB,MAAM,wBAAwB,YAAY;AAAA,QAC5G;AAAA,MACJ,CAAC;AAAA,IACL,OAAO;AACH,WAAK,EAAE,MAAM,QAAQ,SAAS,EAAE,SAAS,oBAAoB,EAAE,CAAC;AAAA,IACpE;AAEA,SAAK;AAAA,MACD,MAAM;AAAA,MACN,SAAS,EAAE,SAAS,WAAW,KAAK,IAAI,GAAG,QAAQ,QAAQ;AAAA,IAC/D,CAAC;AAED,UAAM,OAAO,MAAM,yBAAyB;AAC5C,UAAM,OAAO,MAAM,MAAM,cACpB,SAAS,eAAe,EACxB,MAAM,MAAM,IAAI;AACrB,UAAM,mBAAmB,MAAM,MAAM,cAChC,SAAS,eAAe,EACxB,MAAM,MAAM,KAAK;AACtB,UAAM,yBAAyB,MAAM,MAAM,cACtC,SAAS,qBAAqB,EAC9B,MAAM,MAAM,KAAK;AACtB,UAAM,oBAAoB,MAAM,MAAM,cACjC,SAAS,gBAAgB,EACzB,MAAM,MAAM,KAAK;AACtB,UAAM,qBAAqB,MAAM,MAAM,cAClC,SAAS,cAAc,EACvB,MAAM,MAAM,IAAI;AACrB,UAAM,2BAA2B,MAAM,MAAM,cACxC,SAAS,oBAAoB,EAC7B,MAAM,MAAM,IAAI;AACrB,UAAM,kBACF,OAAO,uBAAuB,YAAY,qBAAqB;AACnE,UAAM,wBACF,OAAO,6BAA6B,YAC9B,2BACA;AACV,UAAM,aACF,QACA,OAAO,KAAK,eAAe,YAC3B,OAAO,KAAK,SAAS,WACf,OACA;AAEV,SAAK;AAAA,MACD,MAAM;AAAA,MACN,SAAS;AAAA,QACL,aAAa,KAAK;AAAA,QAClB,MAAM;AAAA,QACN,eAAe,CAAC,CAAC;AAAA,QACjB,qBAAqB,CAAC,CAAC;AAAA,QACvB,gBAAgB,CAAC,CAAC;AAAA,QAClB,cAAc;AAAA,QACd,oBAAoB;AAAA,MACxB;AAAA,IACJ,CAAC;AACD,SAAK,EAAE,MAAM,wBAAwB,SAAS,EAAE,MAAM,KAAK,QAAQ,EAAE,CAAC;AAAA,EAC1E;AAGA,iBAAe,iBAAiB,KAAgC;AAC5D,UAAM,UAAW,IAAqC;AACtD,UAAM,YAAY,CAAC,CAAC,QAAQ;AAC5B,UAAM,kBAAkB,CAAC,CAAC,QAAQ;AAClC,UAAM,aAAa,CAAC,CAAC,QAAQ;AAC7B,QAAI,WAAW;AACX,YAAM,MAAM,MAAM,WAAW;AAAA,QACzB,QAAQ;AAAA,QACR;AAAA,QACA;AAAA,MACJ,CAAC;AACD,WAAK,EAAE,MAAM,iBAAiB,SAAS,EAAE,OAAO,IAAI,MAAM,EAAE,CAAC;AAC7D;AAAA,IACJ;AAEA,UAAM,iBAAiB,QAAQ,aAAa,QAAQ,aAAa;AACjE,UAAM,WAAW,QAAQ,OAAO,QAAQ,OAAO;AAC/C,UAAM,MAAM,MAAM,WAAW;AAAA,MACzB,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,IACJ,CAAC;AAED,UAAM,cAAc,GAAG,cAAc,MAAM,QAAQ;AACnD,UAAM,cAAc,GAAG,cAAc,MAAM,QAAQ;AACnD,UAAM,UAAU,GAAG,cAAc,SAAS,QAAQ;AAClD,UAAM,UAAU,GAAG,cAAc,SAAS,QAAQ;AAClD,UAAM,UAAU,6BAA6B,gBAAgB,QAAQ;AAErE,QAAI,SAAS,IAAI,MAAM,KAAK,CAAC,MAAM;AAC/B,YAAM,IAAI,QAAO,uBAAG,SAAQ,EAAE;AAC9B,aACI,MAAM,eACN,MAAM,eACN,EAAE,SAAS,GAAG,cAAc,MAAM,QAAQ,EAAE;AAAA,IAEpD,CAAC;AACD,QAAI,CAAC,QAAQ;AACT,eAAS,IAAI,MAAM,KAAK,CAAC,MAAM;AAC3B,cAAM,IAAI,QAAO,uBAAG,SAAQ,EAAE;AAC9B,eACI,EAAE,SAAS,OAAO,KAClB,EAAE,SAAS,OAAO,KAClB,EAAE,SAAS,OAAO;AAAA,MAE1B,CAAC;AAAA,IACL;AAEA,UAAM,cAAc,SAAS,CAAC,MAAM,IAAI,IAAI;AAC5C,QAAI,CAAC,QAAQ;AACT,WAAK;AAAA,QACD,MAAM;AAAA,QACN,SAAS;AAAA,UACL,SAAS,sCAAsC,cAAc,QAAQ,QAAQ;AAAA,QACjF;AAAA,MACJ,CAAC;AAAA,IACL;AACA,SAAK,EAAE,MAAM,iBAAiB,SAAS,EAAE,OAAO,YAAY,EAAE,CAAC;AAAA,EACnE;AAGA,iBAAe,uBAAuB,MAAiC;AACnE,UAAM,SAAS,MAAM,WAAW,EAAE,QAAQ,aAAa,CAAC;AACxD,SAAK,EAAE,MAAM,iBAAiB,SAAS,EAAE,OAAO,OAAO,MAAM,EAAE,CAAC;AAChE,QAAI,OAAO,MAAM,SAAS,GAAG;AACzB,YAAM,QAAQ,OAAO,MAAM,CAAC;AAC5B,WAAK;AAAA,QACD,MAAM;AAAA,QACN,SAAS,EAAE,MAAM,MAAM,MAAM,MAAM,MAAM,KAAK;AAAA,MAClD,CAAC;AAAA,IACL;AAAA,EACJ;AAGA,iBAAe,eAAe,KAAgC;AAC1D,UAAM,UAAW,IAAmC;AACpD,QACI,OAAO,QAAQ,eAAe,YAC9B,OAAO,QAAQ,SAAS,UAC1B;AACE,YAAM,MAAM,cAAc,SAAS,iBAAiB;AAAA,QAChD,YAAY,QAAQ;AAAA,QACpB,MAAM,QAAQ;AAAA,MAClB,CAAC;AAAA,IACL;AAAA,EACJ;AAGA,iBAAe,gBAAgB,KAAgC;AAC3D,UAAM,UAAW,IAAoC;AACrD,QAAI,OAAO,QAAQ,cAAc,WAAW;AACxC,YAAM,MAAM,cAAc;AAAA,QACtB;AAAA,QACA,CAAC,CAAC,QAAQ;AAAA,MACd;AAAA,IACJ;AACA,QAAI,OAAO,QAAQ,oBAAoB,WAAW;AAC9C,YAAM,MAAM,cAAc;AAAA,QACtB;AAAA,QACA,CAAC,CAAC,QAAQ;AAAA,MACd;AAAA,IACJ;AACA,QAAI,OAAO,QAAQ,eAAe,WAAW;AACzC,YAAM,MAAM,cAAc;AAAA,QACtB;AAAA,QACA,CAAC,CAAC,QAAQ;AAAA,MACd;AAAA,IACJ;AACA,QAAI,OAAO,QAAQ,oBAAoB,WAAW;AAC9C,YAAM,MAAM,cAAc;AAAA,QACtB;AAAA,QACA,CAAC,CAAC,QAAQ;AAAA,MACd;AAAA,IACJ;AACA,QAAI,OAAO,QAAQ,wBAAwB,WAAW;AAClD,YAAM,eAAe,CAAC,CAAC,QAAQ;AAC/B,YAAM,MAAM,cAAc,SAAS,sBAAsB,YAAY;AACrE,UAAI,CAAC,cAAc;AACf,cAAM,MAAM,cACP,YAAY,kBAAkB,EAC9B,MAAM,MAAM;AAAA,QAAC,CAAC;AAAA,MACvB;AAAA,IACJ;AAAA,EACJ;AAGA,iBAAe,eAAe,KAAgC;AAC1D,UAAM,UAAW,IAAmC;AACpD,UAAM,IAAI,KAAK,IAAI,KAAK,KAAK,IAAI,MAAM,KAAK,MAAM,QAAQ,KAAK,CAAC,CAAC;AACjE,UAAM,IAAI,KAAK,IAAI,KAAK,KAAK,IAAI,MAAM,KAAK,MAAM,QAAQ,MAAM,CAAC,CAAC;AAClE,UAAM,GAAG,OAAO,GAAG,CAAC;AACpB,QAAI;AACA,YAAM,MAAM,cAAc,SAAS,UAAU,EAAE,OAAO,GAAG,QAAQ,EAAE,CAAC;AAAA,IACxE,SAAQ;AAAA,IAAC;AAAA,EACb;AAGA,iBAAe,qBAAqB,KAAgC;AAChE,UAAM,UAAW,IAAyC;AAC1D,UAAM,iBAAiB,QAAQ,aAAa,OAAO,QAAQ,UAAU,IAAI;AACzE,UAAM,WAAW,QAAQ,OAAO,OAAO,QAAQ,IAAI,IAAI;AACvD,UAAM,kBAAkB,CAAC,CAAC,QAAQ;AAClC,UAAM,aAAa,CAAC,CAAC,QAAQ;AAE7B,UAAM,MAAM,MAAM,WAAW;AAAA,MACzB,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,IACJ,CAAC;AAED,UAAM,cAAc,GAAG,cAAc,MAAM,QAAQ;AACnD,UAAM,cAAc,GAAG,cAAc,MAAM,QAAQ;AACnD,UAAM,UAAU,GAAG,cAAc,SAAS,QAAQ;AAClD,UAAM,UAAU,GAAG,cAAc,SAAS,QAAQ;AAClD,UAAM,UAAU,6BAA6B,gBAAgB,QAAQ;AAErE,UAAM,SAAS,IAAI,MAAM,KAAK,CAAC,MAAM;AACjC,YAAM,IAAI,QAAO,uBAAG,SAAQ,EAAE;AAC9B,aACI,MAAM,eACN,MAAM,eACN,EAAE,SAAS,GAAG,cAAc,MAAM,QAAQ,EAAE;AAAA,IAEpD,CAAC,KACG,IAAI,MAAM,KAAK,CAAC,MAAM;AAClB,YAAM,IAAI,QAAO,uBAAG,SAAQ,EAAE;AAC9B,aACI,EAAE,SAAS,OAAO,KAClB,EAAE,SAAS,OAAO,KAClB,EAAE,SAAS,OAAO;AAAA,IAE1B,CAAC,KACD,IAAI,MAAM,CAAC,KAAK,EAAE,MAAM,qBAAqB,MAAM,CAAC,EAAE;AAE1D,SAAK;AAAA,MACD,MAAM;AAAA,MACN,SAAS,EAAE,MAAM,OAAO,MAAM,MAAM,OAAO,KAAK;AAAA,IACpD,CAAC;AAAA,EACL;AAEA,MAAM,eAAe,oBAAI,IAAiC;AAAA,IACtD,CAAC,YAAY,aAAa;AAAA,IAC1B,CAAC,qBAAqB,sBAAsB;AAAA,IAC5C,CAAC,eAAe,gBAAgB;AAAA,IAChC,CAAC,eAAe,gBAAgB;AAAA,IAChC,CAAC,qBAAqB,sBAAsB;AAAA,IAC5C,CAAC,aAAa,cAAc;AAAA,IAC5B,CAAC,cAAc,eAAe;AAAA,IAC9B,CAAC,aAAa,cAAc;AAAA,IAC5B,CAAC,mBAAmB,oBAAoB;AAAA,EAC5C,CAAC;AAED,QAAM,GAAG,YAAY,OAAO,QAAoB;AAC5C,QAAI;AACA,YAAM,UAAU,aAAa,IAAI,IAAI,IAA0B;AAC/D,UAAI,SAAS;AACT,cAAM,QAAQ,GAAG;AACjB;AAAA,MACJ;AAEA,UAAI,MAAM,OAAO,OAAO,GAAG,EAAG;AAAA,IAClC,SAAS,GAAG;AACR,UAAI,UAAU;AACd,UAAI,KAAM,EAAY,QAAS,WAAW,EAAY;AACtD,YAAM,OAAO,mBAAmB,SAAS,EAAE,SAAS,IAAK,CAAC;AAC1D,WAAK,EAAE,MAAM,SAAS,SAAS,EAAE,QAAQ,EAAE,CAAC;AAE5C,cAAQ,MAAM,CAAC;AAAA,IACnB;AAAA,EACJ;",
  "names": ["figma", "clamp01", "e", "irPath", "ctx", "byCtx", "logInfo", "logWarn", "keysOf", "ctxKey", "e", "canonicalPath", "text"]
}
