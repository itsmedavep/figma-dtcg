{
  "version": 3,
  "sources": ["../src/core/normalize.ts", "../src/core/color.ts", "../src/adapters/dtcg-reader.ts", "../src/adapters/dtcg-writer.ts", "../src/core/ir.ts", "../src/adapters/figma-reader.ts", "../src/adapters/figma-writer.ts", "../src/core/pipeline.ts", "../src/app/main.ts"],
  "sourcesContent": ["// src/core/normalize.ts\n// Shared helpers for names, paths, alias parsing, and graph checks.\n\nimport type { TokenGraph, TokenNode, ValueOrAlias } from './ir';\n\n/* =========================\n   Naming & Path Utilities\n   ========================= */\n\nexport function slugSegment(s: string): string {\n  var cleaned = s.replace(/\\s+/g, '-').trim().toLowerCase();\n  var out = '';\n  var i = 0;\n  for (i = 0; i < cleaned.length; i++) {\n    var ch = cleaned.charAt(i);\n    if (ch === '{' || ch === '}' || ch === '.' || ch === ':' || ch === '\\\\' || ch === '/') ch = '-';\n    var ok =\n      (ch >= 'a' && ch <= 'z') ||\n      (ch >= '0' && ch <= '9') ||\n      ch === '-';\n    out += ok ? ch : '-';\n  }\n  out = out.replace(/-+/g, '-');\n  if (out.length > 0 && out.charAt(0) === '$') out = 'dollar' + out.substring(1);\n  if (out.length === 0) out = 'unnamed';\n  return out;\n}\n\nexport function canonicalPath(collectionName: string, variableName: string): string[] {\n  var segs = variableName.split('/');\n  var out: string[] = [];\n  out.push(slugSegment(collectionName));\n  var i = 0;\n  for (i = 0; i < segs.length; i++) out.push(slugSegment(segs[i]));\n  return out;\n}\n\nexport function toDot(path: string[]): string {\n  var i = 0, s = '';\n  for (i = 0; i < path.length; i++) {\n    if (i > 0) s += '.';\n    s += path[i];\n  }\n  return s;\n}\n\nexport function toAliasString(path: string[]): string {\n  return '{' + toDot(path) + '}';\n}\n\nexport function parseAliasString(s: string): string[] | null {\n  if (typeof s !== 'string') return null;\n  if (s.length < 3) return null;\n  if (s.charAt(0) !== '{' || s.charAt(s.length - 1) !== '}') return null;\n  var inner = s.substring(1, s.length - 1);\n  if (!inner) return null;\n  return inner.split('.');\n}\n\n/* =========================\n   Graph Utilities\n   ========================= */\n\nexport function normalize(graph: TokenGraph): TokenGraph {\n  var seen: { [k: string]: 1 } = {};\n  var copy: TokenNode[] = [];\n  var i = 0;\n  for (i = 0; i < graph.tokens.length; i++) {\n    var t = graph.tokens[i];\n    var key = slashPath(t.path);\n    if (!seen[key]) {\n      seen[key] = 1;\n      copy.push(t);\n    }\n  }\n  copy.sort(function (a, b) {\n    var da = toDot(a.path);\n    var db = toDot(b.path);\n    if (da < db) return -1;\n    if (da > db) return 1;\n    return 0;\n  });\n  return { tokens: copy };\n}\n\nfunction slashPath(path: string[]): string {\n  var i = 0, s = '';\n  for (i = 0; i < path.length; i++) {\n    if (i > 0) s += '/';\n    s += path[i];\n  }\n  return s;\n}\n\nexport function indexByDotPath(graph: TokenGraph): { [dot: string]: TokenNode } {\n  var idx: { [dot: string]: TokenNode } = {};\n  var i = 0;\n  for (i = 0; i < graph.tokens.length; i++) {\n    var t = graph.tokens[i];\n    idx[toDot(t.path)] = t;\n  }\n  return idx;\n}\n\nexport function isAlias(v: ValueOrAlias): v is { kind: 'alias'; path: string[] } {\n  return !!v && v.kind === 'alias';\n}\n\nexport function analyzeAliases(graph: TokenGraph): { missing: string[]; cycles: string[][] } {\n  var idx = indexByDotPath(graph);\n  var edges: { [from: string]: string[] } = {};\n  var nodes: string[] = [];\n\n  var i = 0;\n  for (i = 0; i < graph.tokens.length; i++) {\n    var t = graph.tokens[i];\n    var from = toDot(t.path);\n    nodes.push(from);\n    edges[from] = [];\n    var ctxKeys = keysOf(t.byContext);\n    var k = 0;\n    for (k = 0; k < ctxKeys.length; k++) {\n      var ctx = ctxKeys[k];\n      var val = t.byContext[ctx];\n      if (isAlias(val)) {\n        var to = toDot(val.path);\n        edges[from].push(to);\n      }\n    }\n  }\n\n  var missing: string[] = [];\n  var u = 0;\n  for (u = 0; u < nodes.length; u++) {\n    var n = nodes[u];\n    var outs = edges[n];\n    var j = 0;\n    for (j = 0; j < outs.length; j++) {\n      var target = outs[j];\n      if (!idx[target]) {\n        var seen = false;\n        var m = 0;\n        for (m = 0; m < missing.length; m++) if (missing[m] === target) { seen = true; break; }\n        if (!seen) missing.push(target);\n      }\n    }\n  }\n\n  var WHITE = 0, GRAY = 1, BLACK = 2;\n  var color: { [node: string]: number } = {};\n  for (u = 0; u < nodes.length; u++) color[nodes[u]] = WHITE;\n\n  var cycles: string[][] = [];\n\n  function dfs(start: string, stack: string[]): boolean {\n    color[start] = GRAY;\n    stack.push(start);\n    var arr = edges[start];\n    var p = 0;\n    for (p = 0; p < arr.length; p++) {\n      var v = arr[p];\n      if (color[v] === WHITE) {\n        if (dfs(v, stack)) return true;\n      } else if (color[v] === GRAY) {\n        var ci = stack.length - 1;\n        var cyc: string[] = [];\n        while (ci >= 0 && stack[ci] !== v) { ci--; }\n        if (ci >= 0) {\n          var w = ci;\n          for (w = ci; w < stack.length; w++) cyc.push(stack[w]);\n          cyc.push(v);\n        }\n        cycles.push(cyc);\n        return true;\n      }\n    }\n    stack.pop();\n    color[start] = BLACK;\n    return false;\n  }\n\n  for (u = 0; u < nodes.length; u++) {\n    var node = nodes[u];\n    if (color[node] === WHITE) {\n      var stack: string[] = [];\n      dfs(node, stack);\n    }\n  }\n\n  return { missing: missing, cycles: cycles };\n}\n\nfunction keysOf<T>(obj: { [k: string]: T }): string[] {\n  var keys: string[] = [];\n  var k: string;\n  for (k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) keys.push(k);\n  return keys;\n}\n", "// src/core/color.ts\n// Accurate, spec-aligned color handling for DTCG <-> Figma.\n\nimport type { ColorValue } from './ir';\n\nexport type DocumentProfile = 'SRGB' | 'DISPLAY_P3' | 'LEGACY';\n\nfunction clamp01(x: number): number {\n  if (x < 0) return 0;\n  if (x > 1) return 1;\n  return x;\n}\nfunction clamp01Array(v: number[]): number[] {\n  var out: number[] = [];\n  var i = 0;\n  for (i = 0; i < v.length; i++) out.push(clamp01(v[i]));\n  return out;\n}\n\n// sRGB / P3 TRC\nfunction srgbEncode(linear: number): number {\n  if (linear <= 0.0031308) return 12.92 * linear;\n  return 1.055 * Math.pow(linear, 1 / 2.4) - 0.055;\n}\nfunction srgbDecode(encoded: number): number {\n  if (encoded <= 0.04045) return encoded / 12.92;\n  return Math.pow((encoded + 0.055) / 1.055, 2.4);\n}\nvar p3Encode = srgbEncode;\nvar p3Decode = srgbDecode;\n\nfunction mul3(m: number[][], v: number[]): number[] {\n  return [\n    m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2],\n    m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2],\n    m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2],\n  ];\n}\n\n// D65 matrices\nconst M_SRGB_TO_XYZ = [\n  [0.4124564, 0.3575761, 0.1804375],\n  [0.2126729, 0.7151522, 0.0721750],\n  [0.0193339, 0.1191920, 0.9503041],\n];\nconst M_XYZ_TO_SRGB = [\n  [3.2404542, -1.5371385, -0.4985314],\n  [-0.9692660, 1.8760108, 0.0415560],\n  [0.0556434, -0.2040259, 1.0572252],\n];\n\nconst M_P3_TO_XYZ = [\n  [0.4865709486482162, 0.26566769316909306, 0.1982172852343625],\n  [0.2289745640697488, 0.6917385218365064, 0.0792869140937450],\n  [0.0000000000000000, 0.04511338185890264, 1.0439443689009760],\n];\nconst M_XYZ_TO_P3 = [\n  [2.493496911941425, -0.9313836179191239, -0.40271078445071684],\n  [-0.8294889695615747, 1.7626640603183463, 0.02362468584194358],\n  [0.03584583024378447, -0.07617238926804182, 0.9568845240076872],\n];\n\nfunction encode(space: 'srgb' | 'display-p3', linearRGB: number[]): number[] {\n  if (space === 'display-p3') return [p3Encode(linearRGB[0]), p3Encode(linearRGB[1]), p3Encode(linearRGB[2])];\n  return [srgbEncode(linearRGB[0]), srgbEncode(linearRGB[1]), srgbEncode(linearRGB[2])];\n}\nfunction decode(space: 'srgb' | 'display-p3', encodedRGB: number[]): number[] {\n  if (space === 'display-p3') return [p3Decode(encodedRGB[0]), p3Decode(encodedRGB[1]), p3Decode(encodedRGB[2])];\n  return [srgbDecode(encodedRGB[0]), srgbDecode(encodedRGB[1]), srgbDecode(encodedRGB[2])];\n}\n\nfunction convertRgbSpace(rgb: number[], src: 'srgb' | 'display-p3', dst: 'srgb' | 'display-p3'): number[] {\n  if (src === dst) return clamp01Array(rgb);\n  var lin = decode(src, clamp01Array(rgb));\n  var xyz: number[] = src === 'srgb' ? mul3(M_SRGB_TO_XYZ, lin) : mul3(M_P3_TO_XYZ, lin);\n  var linDst: number[] = dst === 'srgb' ? mul3(M_XYZ_TO_SRGB, xyz) : mul3(M_XYZ_TO_P3, xyz);\n  var enc = encode(dst, linDst);\n  return clamp01Array(enc);\n}\n\nfunction srgbToHex6(rgb: number[]): string {\n  var r = Math.round(clamp01(rgb[0]) * 255);\n  var g = Math.round(clamp01(rgb[1]) * 255);\n  var b = Math.round(clamp01(rgb[2]) * 255);\n  function to2(n: number): string { var s = n.toString(16); return s.length === 1 ? '0' + s : s; }\n  return '#' + to2(r) + to2(g) + to2(b);\n}\nfunction srgbToHex8(rgba: { r: number; g: number; b: number; a: number }): string {\n  var r = Math.round(clamp01(rgba.r) * 255);\n  var g = Math.round(clamp01(rgba.g) * 255);\n  var b = Math.round(clamp01(rgba.b) * 255);\n  var a = Math.round(clamp01(rgba.a) * 255);\n  function to2(n: number): string { var s = n.toString(16); return s.length === 1 ? '0' + s : s; }\n  return '#' + to2(r) + to2(g) + to2(b) + to2(a);\n}\n\nfunction isHexCharCode(code: number): boolean {\n  if (code >= 48 && code <= 57) return true;\n  if (code >= 65 && code <= 70) return true;\n  if (code >= 97 && code <= 102) return true;\n  return false;\n}\nfunction hexPairToByte(h1: number, h2: number): number {\n  function val(c: number): number {\n    if (c >= 48 && c <= 57) return c - 48;\n    if (c >= 65 && c <= 70) return c - 55;\n    if (c >= 97 && c <= 102) return c - 87;\n    return 0;\n  }\n  return (val(h1) << 4) | val(h2);\n}\n\nexport function parseHexToSrgbRGBA(hex: string): { r: number; g: number; b: number; a: number } {\n  var s = hex;\n  if (s.length > 0 && s.charAt(0) === '#') s = s.substring(1);\n\n  var i = 0;\n  for (i = 0; i < s.length; i++) {\n    if (!isHexCharCode(s.charCodeAt(i))) throw new Error('Invalid hex color: ' + hex);\n  }\n\n  var r = 0, g = 0, b = 0, a = 255;\n\n  if (s.length === 3 || s.length === 4) {\n    var rNib = s.charCodeAt(0);\n    var gNib = s.charCodeAt(1);\n    var bNib = s.charCodeAt(2);\n    var aNib = s.length === 4 ? s.charCodeAt(3) : 102;\n    r = hexPairToByte(rNib, rNib);\n    g = hexPairToByte(gNib, gNib);\n    b = hexPairToByte(bNib, bNib);\n    a = hexPairToByte(aNib, aNib);\n  } else if (s.length === 6 || s.length === 8) {\n    r = hexPairToByte(s.charCodeAt(0), s.charCodeAt(1));\n    g = hexPairToByte(s.charCodeAt(2), s.charCodeAt(3));\n    b = hexPairToByte(s.charCodeAt(4), s.charCodeAt(5));\n    if (s.length === 8) a = hexPairToByte(s.charCodeAt(6), s.charCodeAt(7));\n  } else {\n    throw new Error('Invalid hex length: ' + hex);\n  }\n\n  return { r: clamp01(r / 255), g: clamp01(g / 255), b: clamp01(b / 255), a: clamp01(a / 255) };\n}\n\nfunction docProfileToSpaceKey(profile: DocumentProfile): 'srgb' | 'display-p3' {\n  if (profile === 'DISPLAY_P3') return 'display-p3';\n  return 'srgb';\n}\n\n/** DTCG -> Figma RGBA in current doc profile. */\nexport function dtcgToFigmaRGBA(\n  value: ColorValue,\n  docProfile: DocumentProfile\n): { r: number; g: number; b: number; a: number } {\n  var alpha = typeof value.alpha === 'number' ? value.alpha : 1;\n  var dst = docProfileToSpaceKey(docProfile);\n\n  var comps = value.components;\n  if (comps && comps.length >= 3) {\n    var space = value.colorSpace;\n    if (space === 'srgb' || space === 'display-p3') {\n      var converted = convertRgbSpace([comps[0], comps[1], comps[2]], space, dst);\n      return { r: converted[0], g: converted[1], b: converted[2], a: clamp01(alpha) };\n    }\n    throw new Error('Unsupported colorSpace: ' + space + '. Supported: srgb, display-p3.');\n  }\n\n  if (value.hex && typeof value.hex === 'string') {\n    var fromHex = parseHexToSrgbRGBA(value.hex);\n    var a = typeof value.alpha === 'number' ? clamp01(value.alpha) : fromHex.a;\n    if (dst === 'srgb') return { r: fromHex.r, g: fromHex.g, b: fromHex.b, a: a };\n    var toDst = convertRgbSpace([fromHex.r, fromHex.g, fromHex.b], 'srgb', dst);\n    return { r: toDst[0], g: toDst[1], b: toDst[2], a: a };\n  }\n\n  throw new Error('Color has neither components nor hex.');\n}\n\n/** Figma -> DTCG in document-native space + sRGB hex fallback. */\nexport function figmaRGBAToDtcg(\n  rgba: { r: number; g: number; b: number; a: number },\n  docProfile: DocumentProfile\n): ColorValue {\n  var src = docProfileToSpaceKey(docProfile);\n  var rgb = [clamp01(rgba.r), clamp01(rgba.g), clamp01(rgba.b)];\n  var a = clamp01(rgba.a);\n\n  var colorSpace: 'srgb' | 'display-p3' = src;\n  var components: [number, number, number] = [rgb[0], rgb[1], rgb[2]];\n\n  var srgbRgb = src === 'srgb' ? rgb : convertRgbSpace(rgb, 'display-p3', 'srgb');\n  var hex = srgbToHex6(srgbRgb);\n\n  return { colorSpace: colorSpace, components: components, alpha: a, hex: hex };\n}\n\n// Legacy wrappers kept for existing callers\nexport function srgbToFigma(color: ColorValue): { r: number; g: number; b: number; a: number } {\n  return dtcgToFigmaRGBA(color, 'SRGB');\n}\nexport function figmaToSrgb(r: number, g: number, b: number, a: number): ColorValue {\n  var comps: [number, number, number] = [clamp01(r), clamp01(g), clamp01(b)];\n  return { colorSpace: 'srgb', components: comps, alpha: clamp01(a) };\n}\n\n// Hex helpers for tooling\nexport function toHex6FromSrgb(rgb: { r: number; g: number; b: number }): string {\n  return srgbToHex6([clamp01(rgb.r), clamp01(rgb.g), clamp01(rgb.b)]);\n}\nexport function toHex8FromSrgb(rgba: { r: number; g: number; b: number; a: number }): string {\n  return srgbToHex8({ r: clamp01(rgba.r), g: clamp01(rgba.g), b: clamp01(rgba.b), a: clamp01(rgba.a) });\n}\nexport function hexToDtcgColor(hex: string): ColorValue {\n  var rgba = parseHexToSrgbRGBA(hex);\n  var comps: [number, number, number] = [rgba.r, rgba.g, rgba.b];\n  return { colorSpace: 'srgb', components: comps, alpha: rgba.a, hex: toHex6FromSrgb({ r: rgba.r, g: rgba.g, b: rgba.b }) };\n}\n\n\n// ==== DTCG color guards & normalization ===================================\n\n/**\n * Lightweight structural check for a DTCG color object.\n * Accepts { components[3], colorSpace?, alpha?, hex? }.\n * (colorSpace may be absent; we'll default it during normalization.)\n */\nexport function isValidDtcgColorValueObject(v: unknown): v is {\n  colorSpace?: string;\n  components?: unknown;\n  alpha?: unknown;\n  hex?: unknown;\n} {\n  if (!v || typeof v !== \"object\") return false;\n  const o = v as any;\n  if (!Array.isArray(o.components) || o.components.length < 3) return false;\n  if (typeof o.components[0] !== \"number\" ||\n    typeof o.components[1] !== \"number\" ||\n    typeof o.components[2] !== \"number\") return false;\n  return true;\n}\n\n/**\n * Normalize a DTCG color object into your internal ColorValue:\n * - clamps components/alpha to [0,1]\n * - preserves hex when present (no rounding/quantization)\n * - defaults missing colorSpace to \"srgb\"\n */\nexport function normalizeDtcgColorValue(input: {\n  colorSpace?: string;\n  components: [number, number, number] | number[];\n  alpha?: number;\n  hex?: string;\n}): ColorValue {\n  function clamp01(x: number): number {\n    if (!Number.isFinite(x)) return 0;\n    if (x < 0) return 0;\n    if (x > 1) return 1;\n    return x;\n  }\n  const comps = [\n    clamp01(Number(input.components[0])),\n    clamp01(Number(input.components[1])),\n    clamp01(Number(input.components[2]))\n  ] as [number, number, number];\n\n  const alpha =\n    typeof input.alpha === \"number\" ? clamp01(input.alpha) : undefined;\n\n  // Honor provided colorSpace when it's one of the supported ones; default to srgb\n  const cs = input.colorSpace === \"display-p3\" ? \"display-p3\" : \"srgb\";\n\n  return {\n    colorSpace: cs,\n    components: comps,\n    ...(alpha !== undefined ? { alpha } : {}),\n    ...(typeof input.hex === \"string\" ? { hex: input.hex } : {})\n  };\n}\n\n// STRICT range check: components and alpha must be in [0..1] with no clamping.\nexport function isDtcgColorInUnitRange(input: {\n  components?: [number, number, number] | number[];\n  alpha?: number;\n}): { ok: boolean; reason?: string } {\n  if (!input || !Array.isArray(input.components) || input.components.length < 3) {\n    return { ok: false, reason: 'components missing' };\n  }\n  for (let i = 0; i < 3; i++) {\n    const n = Number(input.components[i]);\n    if (!Number.isFinite(n) || n < 0 || n > 1) {\n      return { ok: false, reason: `component[${i}] out of range (${input.components[i]})` };\n    }\n  }\n  if (typeof input.alpha === 'number') {\n    const a = Number(input.alpha);\n    if (!Number.isFinite(a) || a < 0 || a > 1) {\n      return { ok: false, reason: `alpha out of range (${input.alpha})` };\n    }\n  }\n  return { ok: true };\n}\n\n", "// src/adapters/dtcg-reader.ts\n// DTCG JSON -> IR TokenGraph (handles aliases, strict $type, preserves names)\n\nimport {\n  type TokenGraph,\n  type TokenNode,\n  type PrimitiveType,\n  type ValueOrAlias,\n  ctxKey,\n  type ColorValue\n} from '../core/ir';\nimport { hexToDtcgColor, isDtcgColorInUnitRange } from '../core/color';\n\n// ---------- lightweight logging (no toasts) ----------\nfunction logInfo(msg: string) {\n  try { figma.ui?.postMessage({ type: 'INFO', payload: { message: msg } }); } catch { /* ignore */ }\n}\nfunction logWarn(msg: string) { logInfo('Warning: ' + msg); }\n\n// ---------- helpers ----------\nfunction hasKey(o: unknown, k: string): boolean {\n  return !!o && typeof o === 'object' && Object.prototype.hasOwnProperty.call(o, k);\n}\n\nfunction isAliasString(v: unknown): v is string {\n  return typeof v === 'string' && v.startsWith('{') && v.endsWith('}') && v.length > 2;\n}\nfunction parseAliasToSegments(v: string): string[] {\n  // exact segments, keep spacing/punctuation as-is (only trim around the dot delimiter)\n  return v.slice(1, -1).split('.').map(s => s.trim());\n}\n\nfunction isLikelyHexString(v: unknown): v is string {\n  return typeof v === 'string'\n    && /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(v.trim());\n}\n\nfunction toNumber(x: unknown, def: number): number {\n  return typeof x === 'number' ? x : def;\n}\n\nfunction parseColorSpaceUnion(x: unknown): 'srgb' | 'display-p3' {\n  if (x === 'display-p3') return 'display-p3';\n  return 'srgb';\n}\n\nfunction isColorObject(obj: unknown): obj is { colorSpace?: string; components?: number[]; alpha?: number; hex?: string } {\n  if (!obj || typeof obj !== 'object') return false;\n  const o = obj as any;\n  return (\n    typeof o.colorSpace === 'string' ||\n    (Array.isArray(o.components) && o.components.length >= 3) ||\n    typeof o.hex === 'string'\n  );\n}\n\nfunction readColorValue(raw: unknown): ColorValue | null {\n  // Only call this after we've decided it *should* be a color.\n  if (typeof raw === 'string') {\n    if (!isLikelyHexString(raw)) return null;\n    try {\n      return hexToDtcgColor(raw);\n    } catch {\n      return null;\n    }\n  }\n  const obj = raw as { colorSpace?: string; components?: number[]; alpha?: number; hex?: string };\n  const cs = parseColorSpaceUnion(obj?.colorSpace);\n  let comps: [number, number, number] = [0, 0, 0];\n  if (Array.isArray(obj?.components) && obj!.components.length >= 3) {\n    comps = [\n      toNumber(obj!.components[0], 0),\n      toNumber(obj!.components[1], 0),\n      toNumber(obj!.components[2], 0),\n    ];\n  }\n  const alpha = typeof obj?.alpha === 'number' ? obj!.alpha : undefined;\n  const hex = typeof obj?.hex === 'string' ? obj!.hex : undefined;\n\n  return { colorSpace: cs, components: comps, alpha, hex };\n}\n\n// Extract minimal Figma metadata from $extensions.com.figma (if present)\nfunction readComFigma(o: unknown): { collectionName?: string; modeName?: string; variableName?: string } | null {\n  if (!o || typeof o !== 'object') return null;\n  const ext = (o as any)['$extensions'];\n  if (!ext || typeof ext !== 'object') return null;\n  const com = (ext as any)['com.figma'];\n  if (!com || typeof com !== 'object') return null;\n\n  const out: { collectionName?: string; modeName?: string; variableName?: string } = {};\n  if (typeof com.collectionName === 'string') out.collectionName = com.collectionName;\n  if (typeof com.modeName === 'string') out.modeName = com.modeName;\n  if (typeof com.variableName === 'string') out.variableName = com.variableName;\n  return out;\n}\n\n/**\n * Compute IR path and ctx for a token based on:\n *  - $extensions.com.figma.collectionName / modeName / variableName (if present, use EXACT strings)\n *  - otherwise the JSON group path literally (no normalization)\n *  - flat tokens (single segment) go under \"tokens\" collection by default\n *  - default Figma mode when missing = \"Mode 1\"\n */\nfunction computePathAndCtx(path: string[], obj: unknown): { irPath: string[]; ctx: string } {\n  const irPath = path.slice(); // EXACT JSON path\n  let mode = 'Mode 1';\n  const ext = hasKey(obj, '$extensions') ? (obj as any)['$extensions'] as Record<string, unknown> : undefined;\n  const cf = ext && typeof ext === 'object' ? (ext as any)['com.figma'] : undefined;\n  if (cf && typeof cf === 'object' && typeof (cf as any).modeName === 'string') {\n    mode = (cf as any).modeName as string;\n  }\n  const collection = irPath[0] ?? 'Tokens';\n  return { irPath, ctx: `${collection}/${mode}` };\n}\n\n\nfunction guessTypeFromValue(v: unknown): PrimitiveType {\n  if (typeof v === 'number') return 'number';\n  if (typeof v === 'boolean') return 'boolean';\n  if (typeof v === 'string') return 'string';\n  return 'string';\n}\n\nexport function readDtcgToIR(root: unknown): TokenGraph {\n  const tokens: TokenNode[] = [];\n\n  function visit(obj: unknown, path: string[], inheritedType: PrimitiveType | null): void {\n    if (!obj || typeof obj !== 'object') return;\n\n    // group-level $type inheritance (DTCG)\n    let groupType: PrimitiveType | null = inheritedType;\n    if (hasKey(obj, '$type') && typeof (obj as any).$type === 'string') {\n      const t = String((obj as any).$type);\n      if (t === 'color' || t === 'number' || t === 'string' || t === 'boolean') {\n        groupType = t as PrimitiveType;\n      }\n    }\n\n    // Token node?\n    if (hasKey(obj, '$value')) {\n      const rawVal = (obj as any).$value;\n\n      // Aliases are always strings of the form {a.b.c}\n      if (isAliasString(rawVal)) {\n        const segs = parseAliasToSegments(rawVal);\n        const { irPath, ctx } = computePathAndCtx(path, obj);\n        const byCtx: { [k: string]: ValueOrAlias } = {};\n        byCtx[ctx] = { kind: 'alias', path: segs };\n\n        // after you build `byCtx` and before pushing:\n        // (this is inside the \"$value is an alias\" branch \u2014 repeat the same in the color & primitive branches)\n        const ext: Record<string, unknown> | undefined =\n          hasKey(obj, '$extensions') ? (obj as any)['$extensions'] as Record<string, unknown> : undefined;\n        const comFigma: Record<string, unknown> =\n          ext && typeof ext === 'object' && ext['com.figma'] && typeof (ext as any)['com.figma'] === 'object'\n            ? (ext as any)['com.figma'] as Record<string, unknown>\n            : (ext ? ((ext['com.figma'] = {}), (ext as any)['com.figma'] as Record<string, unknown>) : {});\n\n        // NEW: capture the *raw* JSON identifiers for strict checks in the writer\n        (comFigma as any).__jsonCollection = (path[0] ?? '');\n        (comFigma as any).__jsonKey = path.slice(1).join('/');\n\n        // \u2190 keep EXACT JSON keys (no normalization)\n        // tokens.push({\n        //   path: path.slice(),                 \n        //   type: groupType ?? 'string',\n        //   byContext: byCtx,\n        //   ...(ext ? { extensions: { ...ext, 'com.figma': comFigma } } : {})\n        // });\n\n\n        tokens.push({\n          path: irPath,\n          type: groupType ?? 'string',\n          byContext: byCtx,\n          ...(hasKey(obj, '$extensions') ? { extensions: (obj as any)['$extensions'] as Record<string, unknown> } : {})\n        });\n        return;\n      }\n\n      // Colors: ONLY when $type (inherited or local) is 'color'\n      if (groupType === 'color') {\n        const parsed = readColorValue(rawVal);\n        const { irPath, ctx } = computePathAndCtx(path, obj);\n\n        if (!parsed) {\n          logWarn(`Skipped invalid color for \u201C${irPath.join('/')}\u201D \u2014 expected hex or color object.`);\n          return;\n        }\n\n        // STRICT: components/alpha must be within [0..1]; do not clamp during import\n        const range = isDtcgColorInUnitRange(parsed);\n        if (!range.ok) {\n          logWarn(`Skipped invalid color for \u201C${irPath.join('/')}\u201D \u2014 ${range.reason}; components/alpha must be within [0..1].`);\n          return;\n        }\n\n        const byCtx: { [k: string]: ValueOrAlias } = {};\n        byCtx[ctx] = { kind: 'color', value: parsed };\n\n        tokens.push({\n          path: irPath,\n          type: 'color',\n          byContext: byCtx,\n          ...(hasKey(obj, '$extensions') ? { extensions: (obj as any)['$extensions'] as Record<string, unknown> } : {})\n        });\n        return;\n      }\n\n\n\n      // Primitives (respect declared type; no color coercion here)\n      const t2: PrimitiveType = groupType ?? guessTypeFromValue(rawVal);\n      let valObj: ValueOrAlias | null = null;\n\n      if (t2 === 'number' && typeof rawVal === 'number') {\n        valObj = { kind: 'number', value: rawVal };\n      } else if (t2 === 'boolean' && typeof rawVal === 'boolean') {\n        valObj = { kind: 'boolean', value: rawVal };\n      } else if (t2 === 'string' && typeof rawVal === 'string') {\n        valObj = { kind: 'string', value: rawVal };\n      } else {\n        // Fallback: minimally coerce by JS type (but still never to color)\n        if (typeof rawVal === 'string') valObj = { kind: 'string', value: rawVal };\n        else if (typeof rawVal === 'number') valObj = { kind: 'number', value: rawVal };\n        else if (typeof rawVal === 'boolean') valObj = { kind: 'boolean', value: rawVal };\n      }\n\n      if (valObj) {\n        const { irPath, ctx } = computePathAndCtx(path, obj);\n        const byCtx: { [k: string]: ValueOrAlias } = {};\n        byCtx[ctx] = valObj;\n\n        tokens.push({\n          path: irPath,\n          type: t2,\n          byContext: byCtx,\n          ...(hasKey(obj, '$extensions') ? { extensions: (obj as any)['$extensions'] as Record<string, unknown> } : {})\n        });\n      }\n      return;\n    }\n\n    // Group: recurse children with *exact* key names (no slugging/canonicalization)\n    for (const k in obj as Record<string, unknown>) {\n      if (!Object.prototype.hasOwnProperty.call(obj, k)) continue;\n      if (k.startsWith('$')) continue; // skip metadata keys\n      const child = (obj as Record<string, unknown>)[k];\n      const newPath = path.concat([k]); // preserve key *exactly*\n      visit(child, newPath, groupType);\n    }\n  }\n\n  visit(root, [], null);\n  return { tokens };\n}\n", "// src/adapters/dtcg-writer.ts\n// IR -> DTCG object (grouped), including aliases and color values.\n\nimport { type TokenGraph, type TokenNode, type ValueOrAlias } from '../core/ir';\n\n// We must emit EXACT names as Figma shows them when available via $extensions.\n// No normalization, no whitespace collapsing, no hyphen munging.\n\n// ---------- tiny utils (lookup-only; never used for emission) ----------\nfunction dotRaw(segs: string[]): string {\n  return segs.join('.');\n}\n\n/** Matching-only slug so aliases written in slug form still resolve.\n * NEVER used for emission, only for building index keys.\n */\nfunction slugForMatch(s: string): string {\n  return s\n    .trim()\n    .replace(/\\s+/g, '-')   // collapse whitespace to single '-'\n    .replace(/-+/g, '-')    // collapse multiple '-' to one\n    .toLowerCase();\n}\n\ntype DisplayNames = { collection: string; variable: string };\n\n// Extract Figma display names, preferring perContext[ctx], then top-level, then path fallback.\n// Do NOT mutate or normalize these strings in any way.\nfunction getFigmaDisplayNames(t: TokenNode, ctx?: string): DisplayNames {\n  const extAll = (t.extensions && typeof t.extensions === 'object')\n    ? (t.extensions as any)['com.figma'] ?? (t.extensions as any)['org.figma']\n    : undefined;\n\n  // pull top-level first\n  let collection = (extAll && typeof extAll.collectionName === 'string')\n    ? extAll.collectionName\n    : undefined;\n\n  let variable = (extAll && typeof extAll.variableName === 'string')\n    ? extAll.variableName\n    : undefined;\n\n  // if a context is chosen, prefer perContext overrides for names\n  if (ctx && extAll && typeof extAll === 'object' && typeof (extAll as any).perContext === 'object') {\n    const ctxBlock = (extAll as any).perContext[ctx];\n    if (ctxBlock && typeof ctxBlock === 'object') {\n      if (typeof (ctxBlock as any).collectionName === 'string') collection = (ctxBlock as any).collectionName;\n      if (typeof (ctxBlock as any).variableName === 'string') variable = (ctxBlock as any).variableName;\n    }\n  }\n\n  // final fallback to IR path\n  if (!collection) collection = t.path[0];\n  if (!variable) variable = t.path.slice(1).join('/');\n\n  return { collection, variable };\n}\n\n// ---------- Build alias resolution index (using per-context names) ----------\nfunction buildDisplayNameIndex(graph: TokenGraph): Map<string, DisplayNames> {\n  const byKey = new Map<string, DisplayNames>();\n\n  for (const t of graph.tokens) {\n    const ctxKeys = keysOf(t.byContext);\n    const chosenCtx = ctxKeys.length > 0 ? ctxKeys[0] : undefined;\n\n    const { collection, variable } = getFigmaDisplayNames(t, chosenCtx);\n    const entry: DisplayNames = { collection, variable };\n\n    // 1) raw IR path key\n    byKey.set(dotRaw(t.path), entry);\n\n    // 2) exact display key\n    const displaySegs = [collection, ...variable.split('/')];\n    byKey.set(dotRaw(displaySegs), entry);\n\n    // 3) slug-for-match key (lookup only)\n    const slugSegs = [slugForMatch(collection), ...variable.split('/').map((s: string) => slugForMatch(s))];\n    byKey.set(dotRaw(slugSegs), entry);\n  }\n\n  return byKey;\n}\n\nexport interface SerializeResult { json: unknown; }\nexport interface ExportOpts { /* reserved */ }\n\nexport function serialize(graph: TokenGraph, _opts?: ExportOpts): SerializeResult {\n  const root: { [k: string]: unknown } = {};\n  const displayIndex = buildDisplayNameIndex(graph);\n\n  for (const t of graph.tokens) {\n    writeTokenInto(root, t, displayIndex);\n  }\n\n  return { json: root };\n}\n\nfunction writeTokenInto(\n  root: { [k: string]: unknown },\n  t: TokenNode,\n  displayIndex: Map<string, DisplayNames>\n): void {\n  // DTCG has no modes; pick one context just to serialize value/ids\n  const ctxKeys = keysOf(t.byContext);\n  const chosenCtx = ctxKeys.length > 0 ? ctxKeys[0] : undefined;\n\n  const chosen: ValueOrAlias | null =\n    chosenCtx !== undefined ? (t.byContext[chosenCtx] as ValueOrAlias | undefined) ?? null : null;\n\n  // ******** THE CRITICAL CHANGE ********\n  // Names now come from perContext (when present), falling back to top-level, then path.\n  const { collection: collectionDisplay, variable: variableDisplay } = getFigmaDisplayNames(t, chosenCtx);\n\n  // Build groups from path, but force the first segment to the EXACT collectionDisplay.\n  // Keep the legacy \"strip collection-1\" safeguard on the second segment.\n  let groupSegments = t.path.slice(0, t.path.length - 1);\n  if (groupSegments.length > 0) groupSegments[0] = collectionDisplay;\n  if (groupSegments.length > 1) {\n    const firstChild = groupSegments[1].toLowerCase();\n    if (/^collection(\\s|-)?\\d+/.test(firstChild)) {\n      groupSegments = [groupSegments[0], ...groupSegments.slice(2)];\n    }\n  }\n\n  // Walk/build the group objects\n  let obj = root;\n  for (let i = 0; i < groupSegments.length; i++) {\n    const seg = groupSegments[i];\n    let next = obj[seg];\n    if (!next || typeof next !== 'object') {\n      next = {};\n      obj[seg] = next;\n    }\n    obj = next as { [k: string]: unknown };\n  }\n\n  // Leaf key = EXACT variable name from Figma (can include spaces, double hyphens, etc.)\n  const leaf = variableDisplay;\n\n  const tokenObj: { [k: string]: unknown } = {};\n  tokenObj['$type'] = t.type;\n\n  // ----- value emission -----\n  if (chosen !== null) {\n    switch (chosen.kind) {\n      case 'alias': {\n        // Resolve to display names if we can (no normalization on emitted string).\n        const segs: string[] = Array.isArray((chosen as any).path)\n          ? ((chosen as any).path as string[]).slice()\n          : String((chosen as any).path).split('.').map((p: string) => p.trim()).filter(Boolean);\n\n        let refDisp = displayIndex.get(dotRaw(segs));\n        if (!refDisp) {\n          // try slug-for-match\n          refDisp = displayIndex.get(dotRaw(segs.map((s: string) => slugForMatch(s))));\n        }\n\n        if (!refDisp && segs.length > 0) {\n          // As a courtesy, try swapping a slugged collection with a matching display collection\n          const firstSlug = slugForMatch(segs[0]);\n          for (const [k, v] of displayIndex.entries()) {\n            const parts = k.split('.');\n            if (parts.length === 0) continue;\n            if (slugForMatch(parts[0]) === firstSlug) {\n              const cand1 = [parts[0], ...segs.slice(1)];\n              const cand2 = [parts[0], ...segs.slice(1).map((s: string) => slugForMatch(s))];\n              refDisp = displayIndex.get(dotRaw(cand1)) || displayIndex.get(dotRaw(cand2));\n              if (refDisp) break;\n            }\n          }\n        }\n\n        tokenObj['$value'] = refDisp\n          ? `{${[refDisp.collection, ...refDisp.variable.split('/')].join('.')}}`\n          : `{${segs.join('.')}}`;\n        break;\n      }\n\n      case 'color': {\n        const cv = chosen.value;\n        const out: { [k: string]: unknown } = {\n          colorSpace: cv.colorSpace,\n          components: [cv.components[0], cv.components[1], cv.components[2]],\n        };\n        if (typeof cv.alpha === 'number') out['alpha'] = cv.alpha;\n        if (typeof cv.hex === 'string') out['hex'] = cv.hex;\n        tokenObj['$value'] = out;\n        break;\n      }\n\n      case 'number':\n      case 'string':\n      case 'boolean': {\n        tokenObj['$value'] = chosen.value;\n        break;\n      }\n    }\n  }\n\n  if (t.description) tokenObj['$description'] = t.description;\n\n  // Flatten $extensions.(com|org).figma.perContext[chosenCtx] into $extensions.com.figma\n  if (t.extensions) {\n    const flattened = flattenFigmaExtensionsForCtx(t.extensions as Record<string, unknown>, chosenCtx);\n    tokenObj['$extensions'] = flattened ?? t.extensions;\n  }\n\n  obj[leaf] = tokenObj;\n}\n\n/**\n * Flattens either $extensions.com.figma or $extensions.org.figma.\n * - Copies all other namespaces through unchanged.\n * - Removes \"perContext\" and merges the selected context's identifiers.\n * - Always emits under \"com.figma\" to follow current DTCG guidance.\n */\nfunction flattenFigmaExtensionsForCtx(\n  ext: Record<string, unknown>,\n  ctx?: string\n): Record<string, unknown> | null {\n  if (!ext || typeof ext !== 'object') return null;\n\n  const out: Record<string, unknown> = {};\n\n  // Copy non-figma namespaces as-is\n  for (const k in ext) {\n    if (!Object.prototype.hasOwnProperty.call(ext, k)) continue;\n    if (k !== 'com.figma' && k !== 'org.figma') {\n      out[k] = (ext as any)[k];\n    }\n  }\n\n  // Prefer com.figma if present; otherwise accept org.figma for backward-compat\n  const ns = (ext as any)['com.figma']\n    ? 'com.figma'\n    : ((ext as any)['org.figma'] ? 'org.figma' : null);\n\n  if (ns) {\n    const figmaBlock = (ext as any)[ns];\n    if (figmaBlock && typeof figmaBlock === 'object') {\n      const base: Record<string, unknown> = {};\n      // copy all keys except perContext\n      for (const k of Object.keys(figmaBlock)) {\n        if (k !== 'perContext') base[k] = (figmaBlock as any)[k];\n      }\n      // merge selected context\n      const per = (figmaBlock as any)['perContext'];\n      if (ctx && per && typeof per === 'object') {\n        const ctxData = (per as any)[ctx];\n        if (ctxData && typeof ctxData === 'object') {\n          Object.assign(base, ctxData);\n        }\n      }\n      if (Object.keys(base).length > 0) {\n        // Always emit using the standardized \"com.figma\" key\n        out['com.figma'] = base;\n      }\n    }\n  }\n\n  return Object.keys(out).length > 0 ? out : null;\n}\n\nfunction keysOf<T>(o: { [k: string]: T } | undefined): string[] {\n  const out: string[] = [];\n  if (!o) return out;\n  for (const k in o) if (Object.prototype.hasOwnProperty.call(o, k)) out.push(k);\n  return out;\n}\n", "// src/core/ir.ts\n\nexport type PrimitiveType = 'color' | 'number' | 'string' | 'boolean';\n\nexport interface ColorValue {\n  colorSpace: 'srgb' | 'display-p3';\n  components: [number, number, number]; // 0..1\n  alpha?: number;                       // 0..1\n  hex?: string;                         // sRGB fallback \"#RRGGBB\"\n}\n\nexport type ValueOrAlias =\n  | { kind: 'alias'; path: string[] }\n  | { kind: 'color'; value: ColorValue }\n  | { kind: 'number'; value: number }\n  | { kind: 'string'; value: string }\n  | { kind: 'boolean'; value: boolean };\n\nexport interface TokenNode {\n  path: string[];                         // canonical path segments\n  type: PrimitiveType;\n  byContext: { [ctx: string]: ValueOrAlias }; // ctx like \"Collection/Mode\"\n  description?: string;\n  extensions?: { [k: string]: unknown };\n}\n\nexport interface TokenGraph {\n  tokens: TokenNode[];\n}\n\n/** Build a context key like \"Collection/Mode\". */\nexport function ctxKey(collection: string, mode: string): string {\n  return collection + '/' + mode;\n}\n", "// src/adapters/figma-reader.ts\n// Read Figma variables -> IR TokenGraph\n\nimport { figmaRGBAToDtcg, type DocumentProfile } from '../core/color';\nimport { canonicalPath } from '../core/normalize';\nimport { ctxKey, type TokenGraph, type TokenNode, type PrimitiveType, type ValueOrAlias } from '../core/ir';\n\nfunction mapType(t: VariableResolvedDataType): PrimitiveType {\n  if (t === 'COLOR') return 'color';\n  if (t === 'FLOAT') return 'number';\n  if (t === 'STRING') return 'string';\n  return 'boolean';\n}\n\nfunction isAliasValue(v: unknown): v is { type: 'VARIABLE_ALIAS'; id: string } {\n  return !!v && typeof v === 'object' && (v as { type?: string }).type === 'VARIABLE_ALIAS' && typeof (v as { id?: unknown }).id === 'string';\n}\n\nfunction isRGBA(v: unknown): v is { r: number; g: number; b: number; a: number } {\n  return !!v && typeof v === 'object' &&\n    typeof (v as { r?: unknown }).r === 'number' &&\n    typeof (v as { g?: unknown }).g === 'number' &&\n    typeof (v as { b?: unknown }).b === 'number' &&\n    typeof (v as { a?: unknown }).a === 'number';\n}\n\nexport async function readFigmaToIR(): Promise<TokenGraph> {\n  const profile = (figma.root.documentColorProfile as DocumentProfile);\n  const variablesApi = figma.variables;\n\n  // Load collections\n  const collections = await variablesApi.getLocalVariableCollectionsAsync();\n\n  // Build a map variableId -> { name, collectionId }\n  const varMeta: { [id: string]: { name: string; collectionId: string } } = {};\n  for (let ci = 0; ci < collections.length; ci++) {\n    const col = collections[ci];\n    for (let vi = 0; vi < col.variableIds.length; vi++) {\n      const id = col.variableIds[vi];\n      const v = await variablesApi.getVariableByIdAsync(id);\n      if (v) varMeta[v.id] = { name: v.name, collectionId: col.id };\n    }\n  }\n\n  const tokens: TokenNode[] = [];\n\n  for (let ci = 0; ci < collections.length; ci++) {\n    const c = collections[ci];\n\n    // Mode name lookup\n    const modeNameById: { [id: string]: string } = {};\n    for (let mi = 0; mi < c.modes.length; mi++) modeNameById[c.modes[mi].modeId] = c.modes[mi].name;\n\n    for (let vi2 = 0; vi2 < c.variableIds.length; vi2++) {\n      const vid = c.variableIds[vi2];\n      const v2 = await variablesApi.getVariableByIdAsync(vid);\n      if (!v2) continue;\n\n      const path = canonicalPath(c.name, v2.name);\n      const type = mapType(v2.resolvedType);\n      const byContext: { [ctx: string]: ValueOrAlias } = {};\n\n      // NEW: collect per-context figma metadata we\u2019ll store under $extensions.org.figma.perContext\n      const perContext: {\n        [ctx: string]: {\n          collectionName: string; collectionID: string;\n          modeName: string; modeID: string;\n          variableName: string; variableID: string;\n        }\n      } = {};\n\n      // For each mode, collect value\n      for (let mi2 = 0; mi2 < c.modes.length; mi2++) {\n        const md = c.modes[mi2];\n        const ctx = ctxKey(c.name, md.name);\n        const mv = v2.valuesByMode[md.modeId];\n\n        // Always record per-context figma metadata\n        perContext[ctx] = {\n          collectionName: c.name,\n          collectionID: c.id,\n          modeName: md.name,\n          modeID: md.modeId,\n          variableName: v2.name,\n          variableID: v2.id,\n        };\n\n        if (isAliasValue(mv)) {\n          const target = await variablesApi.getVariableByIdAsync(mv.id);\n          if (target) {\n            // resolve collection name for target\n            const meta = varMeta[target.id];\n            const collName =\n              meta\n                ? collections.find(cc => cc.id === meta.collectionId)?.name || c.name\n                : c.name;\n            const aPath = canonicalPath(collName, target.name);\n            byContext[ctx] = { kind: 'alias', path: aPath };\n          }\n          continue;\n        }\n\n        if (type === 'color' && isRGBA(mv)) {\n          const cv = figmaRGBAToDtcg({ r: mv.r, g: mv.g, b: mv.b, a: mv.a }, profile);\n          byContext[ctx] = { kind: 'color', value: cv };\n          continue;\n        }\n\n        if (typeof mv === 'number') { byContext[ctx] = { kind: 'number', value: mv }; continue; }\n        if (typeof mv === 'boolean') { byContext[ctx] = { kind: 'boolean', value: mv }; continue; }\n        if (typeof mv === 'string') { byContext[ctx] = { kind: 'string', value: mv }; continue; }\n        // else unhandled null/undefined -> skip\n      }\n\n      const token: TokenNode = {\n        path,\n        type,\n        byContext,\n        // NEW: attach $extensions payload so it shows in preview and exports\n        extensions: {\n          'com.figma': { perContext }\n        }\n      };\n\n      tokens.push(token);\n    }\n  }\n\n  return { tokens };\n}\n", "// src/adapters/figma-writer.ts\n// Apply IR TokenGraph -> Figma variables (create/update, then set per-mode values)\n\nimport { slugSegment } from '../core/normalize';\nimport { type TokenGraph, type TokenNode, type PrimitiveType } from '../core/ir';\n\nimport {\n  dtcgToFigmaRGBA,\n  type DocumentProfile,\n  isValidDtcgColorValueObject,\n  normalizeDtcgColorValue,\n  isDtcgColorInUnitRange\n} from '../core/color';\n\n// ---------- logging to UI (no toasts) ----------\nfunction logInfo(msg: string) {\n  try { figma.ui?.postMessage({ type: 'INFO', payload: { message: msg } }); } catch { /* ignore */ }\n}\nfunction logWarn(msg: string) { logInfo('Warning: ' + msg); }\nfunction logError(msg: string) { logInfo('Error: ' + msg); }\n\n// ---------- helpers ----------\n\n// Token has at least one non-alias, correctly-typed value in any context\nfunction tokenHasDirectValue(t: TokenNode): boolean {\n  const byCtx = t.byContext || {};\n  for (const k in byCtx) {\n    const v = byCtx[k] as any;\n    if (!v) continue;\n\n    if (t.type === 'color') {\n      if (v.kind === 'color' && isValidDtcgColorValueObject(v.value)) return true;\n    } else {\n      // number/string/boolean must match kind exactly\n      if (v.kind === t.type) return true;\n    }\n  }\n  return false;\n}\n\n// True if token has at least one *settable* direct value in any context.\n// (Color requires in-range components/alpha; other primitives just need correct kind.)\nfunction tokenHasAtLeastOneValidDirectValue(t: TokenNode): boolean {\n  const byCtx = t.byContext || {};\n  for (const ctx in byCtx) {\n    const v = (byCtx as any)[ctx];\n    if (!v || v.kind === 'alias') continue;\n\n    if (t.type === 'color') {\n      if (v.kind !== 'color') continue;\n      if (!isValidDtcgColorValueObject(v.value)) continue;\n      const range = isDtcgColorInUnitRange(v.value);\n      if (range.ok) return true;\n    } else if (t.type === 'number' || t.type === 'string' || t.type === 'boolean') {\n      if (v.kind === t.type) return true;\n    }\n  }\n  return false;\n}\n\n\n\nfunction resolvedTypeFor(t: PrimitiveType): VariableResolvedDataType {\n  if (t === 'color') return 'COLOR';\n  if (t === 'number') return 'FLOAT';\n  if (t === 'string') return 'STRING';\n  return 'BOOLEAN';\n}\nfunction forEachKey<T>(obj: { [k: string]: T } | undefined): string[] {\n  const out: string[] = [];\n  if (!obj) return out;\n  for (const k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) out.push(k);\n  return out;\n}\n\n// Token has at least one alias among its contexts\nfunction tokenHasAlias(t: TokenNode): boolean {\n  const byCtx = t.byContext || {};\n  for (const k in byCtx) {\n    const v = byCtx[k] as any;\n    if (v && v.kind === 'alias') return true;\n  }\n  return false;\n}\n\n// Compare value-hex vs extensions-hex and warn (but prefer $value)\nfunction maybeWarnColorMismatch(t: TokenNode, ctx: string, importedHexOrNull: string | null): void {\n  try {\n    const extAll = t.extensions && typeof t.extensions === 'object' ? (t.extensions as any)['com.figma'] : undefined;\n    if (!extAll || typeof extAll !== 'object') return;\n\n    let hintHex: string | undefined;\n    if (typeof extAll.hex === 'string') hintHex = extAll.hex;\n    const pc = extAll.perContext && typeof extAll.perContext === 'object' ? extAll.perContext : undefined;\n    if (!hintHex && pc && pc[ctx] && typeof pc[ctx].hex === 'string') hintHex = pc[ctx].hex;\n\n    if (!hintHex || !importedHexOrNull) return;\n    const a = hintHex.trim().toLowerCase();\n    const b = importedHexOrNull.trim().toLowerCase();\n    if (a !== b) logWarn(`color mismatch for \u201C${t.path.join('/')}\u201D in ${ctx}. Using $value over $extensions.`);\n  } catch { /* never throw from logging */ }\n}\n\n// Normalize alias path segments (array or string) and adjust first segment:\n// - If first segment matches a known collection, keep it.\n// - Else if it matches a slug of a known collection, replace with the display name.\n// - Else treat as relative to the current token\u2019s collection and prefix it.\nfunction normalizeAliasSegments(\n  rawPath: string[] | string,\n  currentCollection: string,\n  displayBySlug: { [slug: string]: string },\n  knownCollections: Set<string>\n): string[] {\n  const segs = Array.isArray(rawPath)\n    ? rawPath.slice()\n    : String(rawPath).split('.').map(s => s.trim()).filter(Boolean);\n\n  if (segs.length === 0) return [currentCollection];\n\n  const first = segs[0];\n  if (knownCollections.has(first)) return segs;\n\n  const mapped = displayBySlug[first];\n  if (mapped && knownCollections.has(mapped)) {\n    segs[0] = mapped;\n    return segs;\n  }\n\n  // relative \u2192 prefix current collection\n  return [currentCollection, ...segs];\n}\n\n// ---- strict name check helper (extensions vs JSON path)\nfunction namesMatchExtensions(t: TokenNode): { ok: boolean; reason?: string } {\n  // Only care about com.figma\n  const ext = t.extensions && typeof t.extensions === 'object'\n    ? (t.extensions as any)['com.figma']\n    : undefined;\n\n  if (!ext || typeof ext !== 'object') return { ok: true };\n\n  const pathCollection = t.path[0];\n  const pathVariable = t.path.slice(1).join('/'); // exact JSON key\n\n  let expectedCollection: string | undefined =\n    typeof (ext as any).collectionName === 'string' ? (ext as any).collectionName : undefined;\n  let expectedVariable: string | undefined =\n    typeof (ext as any).variableName === 'string' ? (ext as any).variableName : undefined;\n\n  // Per your note: you only use com.figma; still, if top-level absent but perContext exists, be lenient\n  if (!expectedCollection || !expectedVariable) {\n    const per = (ext as any).perContext;\n    if (per && typeof per === 'object') {\n      const ctxKeys = forEachKey(t.byContext);\n      let ctxToUse: string | undefined;\n\n      for (const k of ctxKeys) {\n        if (per[k] && typeof per[k] === 'object') { ctxToUse = k; break; }\n      }\n      if (!ctxToUse) {\n        for (const k in per) {\n          if (Object.prototype.hasOwnProperty.call(per, k) && per[k] && typeof per[k] === 'object') {\n            ctxToUse = k; break;\n          }\n        }\n      }\n\n      if (ctxToUse) {\n        const ctxData = per[ctxToUse] as any;\n        if (!expectedCollection && typeof ctxData.collectionName === 'string') expectedCollection = ctxData.collectionName;\n        if (!expectedVariable && typeof ctxData.variableName === 'string') expectedVariable = ctxData.variableName;\n      }\n    }\n  }\n\n  if (typeof expectedCollection === 'string' && expectedCollection !== pathCollection) {\n    return {\n      ok: false,\n      reason:\n        `Skipping \u201C${t.path.join('/')}\u201D \u2014 $extensions.com.figma.collectionName (\u201C${expectedCollection}\u201D) ` +\n        `doesn\u2019t match JSON group (\u201C${pathCollection}\u201D).`\n    };\n  }\n\n  if (typeof expectedVariable === 'string' && expectedVariable !== pathVariable) {\n    return {\n      ok: false,\n      reason:\n        `Skipping \u201C${t.path.join('/')}\u201D \u2014 $extensions.com.figma.variableName (\u201C${expectedVariable}\u201D) ` +\n        `doesn\u2019t match JSON key (\u201C${pathVariable}\u201D).`\n    };\n  }\n\n  return { ok: true };\n}\n\n// --- Key indexing helpers: index display + slug for BOTH collection and variable segments\nfunction dot(segs: string[]): string { return segs.join('.'); }\n\nfunction indexVarKeys(\n  map: { [k: string]: string },\n  collectionDisplay: string,\n  varSegsRaw: string[],\n  varId: string\n): void {\n  const colDisp = collectionDisplay;\n  const colSlug = slugSegment(collectionDisplay);\n  const varRaw = varSegsRaw;\n  const varSlug = varSegsRaw.map(s => slugSegment(s));\n\n  // 1) Display collection + Raw variable segs\n  map[dot([colDisp, ...varRaw])] = varId;\n  // 2) Display collection + Slugged variable segs\n  map[dot([colDisp, ...varSlug])] = varId;\n  // 3) Slugged collection + Raw variable segs\n  map[dot([colSlug, ...varRaw])] = varId;\n  // 4) Slugged collection + Slugged variable segs\n  map[dot([colSlug, ...varSlug])] = varId;\n}\n\nexport async function writeIRToFigma(graph: TokenGraph): Promise<void> {\n  const profile = figma.root.documentColorProfile as DocumentProfile;\n  const variablesApi = figma.variables;\n\n  // ---- snapshot existing collections + variables\n  const existingCollections = await variablesApi.getLocalVariableCollectionsAsync();\n  const colByName: { [name: string]: VariableCollection } = {};\n  for (const c of existingCollections) colByName[c.name] = c;\n\n  // Build existing variables map keyed by display/slug *for collection and variable segments*\n  const existing = await variablesApi.getLocalVariableCollectionsAsync();\n  const existingVarIdByPathDot: { [dot: string]: string } = {};\n  for (const c of existing) {\n    const cDisplay = c.name;\n    for (const vid of c.variableIds) {\n      const v = await variablesApi.getVariableByIdAsync(vid);\n      if (!v) continue;\n      const varSegs = v.name.split('/'); // keep exact segs as Figma stores them\n      indexVarKeys(existingVarIdByPathDot, cDisplay, varSegs, v.id);\n    }\n  }\n\n  // ---- build slug\u2192display mapping for collections (existing + incoming)\n  const knownCollections = new Set<string>(Object.keys(colByName));\n  const displayBySlug: { [slug: string]: string } = {};\n  for (const name of knownCollections) displayBySlug[slugSegment(name)] = name;\n  for (const t of graph.tokens) {\n    const name = t.path[0];\n    knownCollections.add(name);\n    displayBySlug[slugSegment(name)] = name;\n  }\n\n  // ---- buckets for Pass 1a (direct values) and 1b (alias-only)\n  const directTokens: TokenNode[] = [];\n  const aliasOnlyTokens: TokenNode[] = [];\n\n  for (const t of graph.tokens) {\n    const hasDirect = tokenHasDirectValue(t);\n    const hasAlias = tokenHasAlias(t);\n\n    if (hasDirect) {\n      directTokens.push(t);\n    } else if (hasAlias) {\n      aliasOnlyTokens.push(t);\n    } else {\n      logWarn(`Skipped ${t.type} token \u201C${t.path.join('/')}\u201D \u2014 needs a ${t.type} $value or an alias reference.`);\n    }\n\n    // Do NOT create a collection/variable unless we have at least one *valid* direct value.\n    // This does not affect alias-only tokens (handled in Pass 1b).\n    if (!tokenHasAtLeastOneValidDirectValue(t)) {\n      logWarn(`Skipped ${t.type} token \u201C${t.path.join('/')}\u201D \u2014 no valid direct values in any context; not creating variable or collection.`);\n      continue;\n    }\n\n  }\n\n\n  // helper to ensure collection exists (only when we actually create a var)\n  function ensureCollection(name: string): VariableCollection {\n    let col = colByName[name];\n    if (!col) {\n      col = variablesApi.createVariableCollection(name);\n      colByName[name] = col;\n      knownCollections.add(name);\n      displayBySlug[slugSegment(name)] = name;\n    }\n    return col;\n  }\n\n  // ---- Pass 1a: create direct-value variables, collect ids\n  const idByPath: { [dot: string]: string } = {};\n\n  function varNameFromPath(path: string[]): string {\n    // everything after the collection joined with '/'\n    return path.slice(1).join('/') || (path[0] || 'token');\n  }\n\n  for (const t of directTokens) {\n    if (t.path.length < 1) continue;\n\n    // enforce strict name match vs $extensions (when present)\n    const nameChk = namesMatchExtensions(t);\n    if (!nameChk.ok) { logWarn(nameChk.reason!); continue; }\n\n    const collectionName = t.path[0];\n    const varName = varNameFromPath(t.path);\n\n    // Do NOT create a collection or variable unless we have at least one *valid* direct value.\n    if (!tokenHasAtLeastOneValidDirectValue(t)) {\n      logWarn(`Skipped ${t.type} token \u201C${t.path.join('/')}\u201D \u2014 no valid direct values in any context; not creating variable or collection.`);\n      continue;\n    }\n\n    const col = ensureCollection(collectionName);\n\n\n    // find existing\n    let existingVarId: string | null = null;\n    for (const vid of col.variableIds) {\n      const cand = await variablesApi.getVariableByIdAsync(vid);\n      if (cand && cand.name === varName) { existingVarId = cand.id; break; }\n    }\n\n    let v: Variable;\n    if (existingVarId) {\n      const got = await variablesApi.getVariableByIdAsync(existingVarId);\n      if (!got) continue;\n      v = got;\n    } else {\n      v = variablesApi.createVariable(varName, col, resolvedTypeFor(t.type));\n    }\n\n    // Index display & slug for BOTH collection and variable segments\n    const varSegs = varName.split('/');\n    indexVarKeys(idByPath, collectionName, varSegs, v.id);\n  }\n\n  // ---- Pass 1b: create alias-only variables in ROUNDS so intra-collection chains work\n  const pending: TokenNode[] = aliasOnlyTokens.slice();\n  while (pending.length) {\n    let progress = false;\n    const nextRound: TokenNode[] = [];\n\n    for (const t of pending) {\n      // enforce strict name match vs $extensions (when present)\n      const nameChk = namesMatchExtensions(t);\n      if (!nameChk.ok) { logWarn(nameChk.reason!); continue; }\n\n      const collectionName = t.path[0];\n      const varName = varNameFromPath(t.path);\n\n      // Self keys (display + slug) for skipping self-alias resolvability\n      const selfVarSegs = varName.split('/');\n      const selfKeys = new Set<string>();\n      (function addSelfKeys() {\n        const colDisp = collectionName;\n        const colSlug = slugSegment(collectionName);\n        const varRaw = selfVarSegs;\n        const varSlug = selfVarSegs.map(s => slugSegment(s));\n        selfKeys.add(dot([colDisp, ...varRaw]));\n        selfKeys.add(dot([colDisp, ...varSlug]));\n        selfKeys.add(dot([colSlug, ...varRaw]));\n        selfKeys.add(dot([colSlug, ...varSlug]));\n      })();\n\n      // Is ANY alias context resolvable now? (newly created, direct, or existing doc) \u2014 excluding self\n      let resolvable = false;\n      const ctxKeys = forEachKey(t.byContext);\n      for (const ctx of ctxKeys) {\n        const val = (t.byContext as any)[ctx];\n        if (!val || val.kind !== 'alias') continue;\n\n        const segs = normalizeAliasSegments(val.path, collectionName, displayBySlug, knownCollections);\n        const aliasDot = dot(segs);\n\n        if (selfKeys.has(aliasDot)) continue; // ignore self-alias\n\n        if (idByPath[aliasDot] || existingVarIdByPathDot[aliasDot]) {\n          resolvable = true;\n          break;\n        }\n      }\n\n      if (!resolvable) {\n        // hold for next round\n        nextRound.push(t);\n        continue;\n      }\n\n      // Create the variable now (even if its value will be set in Pass 2)\n      const col = ensureCollection(collectionName);\n\n      // find existing\n      let existingVarId: string | null = null;\n      for (const vid of col.variableIds) {\n        const cand = await variablesApi.getVariableByIdAsync(vid);\n        if (cand && cand.name === varName) { existingVarId = cand.id; break; }\n      }\n\n      let v: Variable;\n      if (existingVarId) {\n        const got = await variablesApi.getVariableByIdAsync(existingVarId);\n        if (!got) continue;\n        v = got;\n      } else {\n        v = variablesApi.createVariable(varName, col, resolvedTypeFor(t.type));\n      }\n\n      // Index display & slug for BOTH collection and variable segments\n      const varSegs = varName.split('/');\n      indexVarKeys(idByPath, collectionName, varSegs, v.id);\n\n      progress = true;\n    }\n\n    if (!progress) {\n      // Nothing more could be created; warn & drop what\u2019s left\n      for (const t of nextRound) {\n        logWarn(`Alias target not found for \u201C${t.path.join('/')}\u201D. Variable not created.`);\n      }\n      break;\n    }\n\n    // Continue with whatever is still pending\n    pending.length = 0;\n    Array.prototype.push.apply(pending, nextRound);\n  }\n\n  // ---- Build mode id lookup (collectionName/modeName \u2192 modeId)\n  const modeIdByKey: { [key: string]: string } = {};\n  const colsPost = await variablesApi.getLocalVariableCollectionsAsync();\n  for (const c of colsPost) {\n    for (const m of c.modes) {\n      modeIdByKey[c.name + '/' + m.name] = m.modeId;\n    }\n  }\n\n  // ---- Pass 2: set values (including aliases)\n  for (const node of graph.tokens) {\n    // resolve our variable id via any of the 4 keys we indexed\n    const collectionName = node.path[0];\n    const varName = node.path.slice(1).join('/');\n    const varSegs = varName.split('/');\n    const possibleSelfKeys: string[] = [];\n    (function addSelfKeys() {\n      const colDisp = collectionName;\n      const colSlug = slugSegment(collectionName);\n      const varRaw = varSegs;\n      const varSlug = varSegs.map(s => slugSegment(s));\n      possibleSelfKeys.push(\n        dot([colDisp, ...varRaw]),\n        dot([colDisp, ...varSlug]),\n        dot([colSlug, ...varRaw]),\n        dot([colSlug, ...varSlug]),\n      );\n    })();\n    let varId: string | undefined;\n    for (const k of possibleSelfKeys) { varId = idByPath[k]; if (varId) break; }\n    if (!varId) continue; // not created (e.g., unresolved alias or name mismatch)\n\n    const targetVar = await variablesApi.getVariableByIdAsync(varId);\n    if (!targetVar) continue;\n\n    const ctxKeys = forEachKey(node.byContext);\n    for (const ctx of ctxKeys) {\n      const val = node.byContext[ctx] as any;\n\n      // ensure mode exists (default \"Mode 1\" when missing)\n      let modeId = modeIdByKey[ctx];\n      if (!modeId) {\n        const parts = ctx.split('/');\n        const cName = parts[0];\n        const mName = parts.slice(1).join('/') || 'Mode 1';\n        const col = colByName[cName];\n        if (col) {\n          const found = col.modes.find(m => m.name === mName);\n          modeId = found ? found.modeId : col.addMode(mName);\n          modeIdByKey[ctx] = modeId;\n        }\n      }\n      if (!modeId) continue;\n\n      if (val.kind === 'alias') {\n        const currentCollection = collectionName;\n\n        // Build candidates (as-written, relative, slug\u2192display for first seg).\n        const rawSegs = Array.isArray(val.path)\n          ? (val.path as string[]).slice()\n          : String(val.path).split('.').map(s => s.trim()).filter(Boolean);\n\n        const candidates: string[][] = [];\n        if (rawSegs.length > 0) candidates.push(rawSegs);\n        candidates.push([currentCollection, ...rawSegs]);\n        if (rawSegs.length > 0 && displayBySlug[rawSegs[0]]) {\n          candidates.push([displayBySlug[rawSegs[0]], ...rawSegs.slice(1)]);\n        }\n\n        let targetId: string | undefined;\n        for (const cand of candidates) {\n          // Try exact, and also a fully-slugged form (for non-color types referencing other collections)\n          const exact = dot(cand);\n          const fullySlugged = dot([slugSegment(cand[0] || ''), ...cand.slice(1).map(s => slugSegment(s))]);\n\n          targetId =\n            idByPath[exact] ||\n            idByPath[fullySlugged] ||\n            existingVarIdByPathDot[exact] ||\n            existingVarIdByPathDot[fullySlugged];\n\n          if (targetId) break;\n        }\n\n        if (!targetId) {\n          logWarn(`Alias target not found while setting \u201C${node.path.join('/')}\u201D in ${ctx}. Skipped this context.`);\n          continue;\n        }\n\n        // prevent self-alias even if resolvable\n        if (targetId === targetVar.id) {\n          logWarn(`Self-alias is not allowed for \u201C${node.path.join('/')}\u201D in ${ctx}. Skipped this context.`);\n          continue;\n        }\n\n        const aliasObj = await variablesApi.createVariableAliasByIdAsync(targetId);\n        targetVar.setValueForMode(modeId, aliasObj);\n        continue;\n      }\n      else if (val.kind === 'color') {\n        if (!isValidDtcgColorValueObject(val.value)) {\n          logWarn(`Skipped setting color for \u201C${node.path.join('/')}\u201D in ${ctx} \u2014 $value must be a color object with { colorSpace, components[3] }.`);\n          continue;\n        }\n\n        // STRICT: components/alpha must be within [0..1]; do not clamp here\n        const range = isDtcgColorInUnitRange(val.value);\n        if (!range.ok) {\n          logWarn(`Skipped setting color for \u201C${node.path.join('/')}\u201D in ${ctx} \u2014 ${range.reason}; components/alpha must be within [0..1].`);\n          continue;\n        }\n\n        const norm = normalizeDtcgColorValue(val.value); // safe: only epsilon clamping now\n        maybeWarnColorMismatch(node, ctx, typeof norm.hex === 'string' ? norm.hex : null);\n        const rgba = dtcgToFigmaRGBA(norm, profile);\n        targetVar.setValueForMode(modeId, { r: rgba.r, g: rgba.g, b: rgba.b, a: rgba.a });\n\n\n      } else if (val.kind === 'number' || val.kind === 'string' || val.kind === 'boolean') {\n        targetVar.setValueForMode(modeId, val.value);\n      }\n    }\n    // After Pass 2 and after setting values\n    for (const name of Object.keys(colByName)) {\n      const col = colByName[name];\n      if (col && col.variableIds.length === 0) {\n        try { col.remove(); } catch { /* ignore */ }\n        knownCollections.delete(name);\n        delete colByName[name];\n      }\n    }\n\n  }\n}\n", "// src/core/pipeline.ts\n// Pipeline glue between adapters and the UI.\n// - importDtcg: DTCG JSON -> IR -> write to Figma\n// - exportDtcg: read IR from Figma -> serialize to DTCG; package as files\n\nimport { normalize } from './normalize';\nimport { toDot } from './normalize';\nimport { readDtcgToIR } from '../adapters/dtcg-reader';\nimport { serialize } from '../adapters/dtcg-writer';\nimport { readFigmaToIR } from '../adapters/figma-reader';\nimport { writeIRToFigma } from '../adapters/figma-writer';\nimport type { TokenGraph, TokenNode, ValueOrAlias } from './ir';\n\nexport interface ExportOpts { format: 'single' | 'perMode' }\nexport interface ExportResult { files: Array<{ name: string; json: unknown }> }\n\n// ---------- helpers ----------\n\nfunction keysOf<T>(obj: { [k: string]: T }): string[] {\n  var out: string[] = [];\n  var k: string;\n  for (k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) out.push(k);\n  return out;\n}\n\nfunction sanitizeForFile(s: string): string {\n  var out = '';\n  var i = 0;\n  for (i = 0; i < s.length; i++) {\n    var ch = s.charAt(i);\n    if (ch === '/' || ch === '\\\\' || ch === ':') out += '_';\n    else out += ch;\n  }\n  return out;\n}\n\nfunction cloneTokenWithSingleContext(t: TokenNode, ctx: string): TokenNode | null {\n  var val = t.byContext[ctx];\n  if (!val) return null;\n\n  // shallow clone without spreads\n  var copyByCtx: { [k: string]: ValueOrAlias } = {};\n  copyByCtx[ctx] = val;\n\n  return {\n    path: (function () { var arr: string[] = []; var i = 0; for (i = 0; i < t.path.length; i++) arr.push(t.path[i]); return arr; })(),\n    type: t.type,\n    byContext: copyByCtx,\n    description: t.description,\n    extensions: t.extensions\n  };\n}\n\n// ---------- API ----------\n\nexport async function importDtcg(json: unknown): Promise<void> {\n  // Build desired graph from DTCG, then write directly to Figma.\n  // (Diffing/plan is optional; we keep a single code path for now.)\n  var desired = normalize(readDtcgToIR(json));\n  await writeIRToFigma(desired);\n}\n\nexport async function exportDtcg(opts: ExportOpts): Promise<ExportResult> {\n  var current = await readFigmaToIR();\n  var graph = normalize(current);\n\n  if (opts.format === 'single') {\n    // One file with whatever contexts exist; writer will emit the first available per token.\n    var single = serialize(graph);\n    return { files: [{ name: 'tokens.json', json: single.json }] };\n  }\n\n  // Per mode: split graph by context \"Collection/Mode\", one file each.\n  var contexts: string[] = [];\n  var i = 0;\n  for (i = 0; i < graph.tokens.length; i++) {\n    var t = graph.tokens[i];\n    var ks = keysOf(t.byContext);\n    var j = 0;\n    for (j = 0; j < ks.length; j++) {\n      var c = ks[j];\n      // push if unique\n      var found = false;\n      var k = 0;\n      for (k = 0; k < contexts.length; k++) if (contexts[k] === c) { found = true; break; }\n      if (!found) contexts.push(c);\n    }\n  }\n\n  // Build a file per context\n  var files: Array<{ name: string; json: unknown }> = [];\n  var ci = 0;\n  for (ci = 0; ci < contexts.length; ci++) {\n    var ctx = contexts[ci];\n\n    // Create a filtered graph where each token only carries this ctx (if present)\n    var filtered: TokenGraph = { tokens: [] };\n    var ii = 0;\n    for (ii = 0; ii < graph.tokens.length; ii++) {\n      var tok = graph.tokens[ii];\n      var one = cloneTokenWithSingleContext(tok, ctx);\n      if (one) filtered.tokens.push(one);\n    }\n\n    // If nothing in this context, skip\n    if (filtered.tokens.length === 0) continue;\n\n    var out = serialize(filtered);\n\n    // ctx format is \"Collection/Mode\"\n    var slash = ctx.indexOf('/');\n    var collection = slash >= 0 ? ctx.substring(0, slash) : ctx;\n    var mode = slash >= 0 ? ctx.substring(slash + 1) : 'default';\n\n    var fname = sanitizeForFile(collection) + '_mode=' + sanitizeForFile(mode) + '.tokens.json';\n    files.push({ name: fname, json: out.json });\n  }\n\n  // Fallback: if no contexts were found, still emit a single file\n  if (files.length === 0) {\n    var fallback = serialize(graph);\n    files.push({ name: 'tokens.json', json: fallback.json });\n  }\n\n  return { files: files };\n}\n", "// src/app/main.ts\nimport type { UiToPlugin, PluginToUi } from './messages';\nimport { importDtcg, exportDtcg } from '../core/pipeline';\n\n// __html__ is injected by your build (esbuild) from dist/ui.html with ui.js inlined.\ndeclare const __html__: string;\n\n// Use saved size if available; fall back to 960\u00D7540.\n(async function initUI() {\n  var w = 960, h = 540;\n  try {\n    var saved = await figma.clientStorage.getAsync('uiSize');\n    if (saved && typeof saved.width === 'number' && typeof saved.height === 'number') {\n      var sw = Math.floor(saved.width);\n      var sh = Math.floor(saved.height);\n      w = Math.max(720, Math.min(1600, sw));\n      h = Math.max(420, Math.min(1200, sh));\n    }\n  } catch (_e) { /* ignore */ }\n  figma.showUI(__html__, { width: w, height: h });\n})();\n\n\nfunction send(msg: PluginToUi): void {\n  figma.ui.postMessage(msg);\n}\n\nasync function snapshotCollectionsForUi(): Promise<{\n  collections: Array<{\n    id: string;\n    name: string;\n    modes: Array<{ id: string; name: string }>;\n    variables: Array<{ id: string; name: string; type: string }>;\n  }>;\n  rawText: string;\n}> {\n  if (typeof figma.editorType !== 'string' || figma.editorType !== 'figma') {\n    return {\n      collections: [],\n      rawText:\n        'Variables API is not available in this editor.\\n' +\n        'Open a Figma Design file (not FigJam) and try again.'\n    };\n  }\n  if (\n    typeof figma.variables === 'undefined' ||\n    typeof figma.variables.getLocalVariableCollectionsAsync !== 'function' ||\n    typeof figma.variables.getVariableByIdAsync !== 'function'\n  ) {\n    return {\n      collections: [],\n      rawText:\n        'Variables API methods not found. Ensure your Figma version supports Variables and try again.'\n    };\n  }\n\n  const locals: VariableCollection[] = await figma.variables.getLocalVariableCollectionsAsync();\n\n  const out: Array<{\n    id: string;\n    name: string;\n    modes: Array<{ id: string; name: string }>;\n    variables: Array<{ id: string; name: string; type: string }>;\n  }> = [];\n  const rawLines: string[] = [];\n\n  let i = 0;\n  for (i = 0; i < locals.length; i++) {\n    const c = locals[i];\n    if (!c) continue;\n\n    const modes: Array<{ id: string; name: string }> = [];\n    let mi = 0;\n    for (mi = 0; mi < c.modes.length; mi++) {\n      const m = c.modes[mi];\n      modes.push({ id: m.modeId, name: m.name });\n    }\n\n    const varsList: Array<{ id: string; name: string; type: string }> = [];\n    let vi = 0;\n    for (vi = 0; vi < c.variableIds.length; vi++) {\n      const varId = c.variableIds[vi];\n      const v = await figma.variables.getVariableByIdAsync(varId);\n      if (!v) continue;\n      varsList.push({ id: v.id, name: v.name, type: v.resolvedType });\n    }\n\n    out.push({ id: c.id, name: c.name, modes: modes, variables: varsList });\n\n    rawLines.push('Collection: ' + c.name + ' (' + c.id + ')');\n    const modeNames: string[] = [];\n    let zi = 0; for (zi = 0; zi < modes.length; zi++) modeNames.push(modes[zi].name);\n    rawLines.push('  Modes: ' + (modeNames.length > 0 ? modeNames.join(', ') : '(none)'));\n    rawLines.push('  Variables (' + String(varsList.length) + '):');\n    let qi = 0; for (qi = 0; qi < varsList.length; qi++) rawLines.push('    - ' + varsList[qi].name + ' [' + varsList[qi].type + ']');\n    rawLines.push('');\n  }\n\n  if (out.length === 0) {\n    rawLines.push('No local Variable Collections found.');\n    rawLines.push('Create one in the Variables panel, then press Refresh.');\n  }\n\n  return { collections: out, rawText: rawLines.join('\\n') };\n}\n\nfunction safeKeyFromCollectionAndMode(collectionName: string, modeName: string): string {\n  const base = collectionName + '/mode=' + modeName;\n  let i = 0, out = '';\n  for (i = 0; i < base.length; i++) {\n    const ch = base.charAt(i);\n    if (ch === '/' || ch === '\\\\' || ch === ':') out += '_'; else out += ch;\n  }\n  return out;\n}\n\nfigma.ui.onmessage = async (msg: UiToPlugin) => {\n  try {\n    if (msg.type === 'UI_READY') {\n      const snap = await snapshotCollectionsForUi();\n      // Load prefs\n      const last = await figma.clientStorage.getAsync('lastSelection').catch(function () { return null; });\n      const exportAllPrefVal = await figma.clientStorage.getAsync('exportAllPref').catch(function () { return false; });\n      const lastOrNull = last && typeof last.collection === 'string' && typeof last.mode === 'string'\n        ? last\n        : null;\n\n      send({ type: 'INFO', payload: { message: 'Fetched ' + String(snap.collections.length) + ' collections (initial)' } });\n      send({ type: 'COLLECTIONS_DATA', payload: { collections: snap.collections, last: lastOrNull, exportAllPref: !!exportAllPrefVal } });\n      send({ type: 'RAW_COLLECTIONS_TEXT', payload: { text: snap.rawText } });\n      return;\n    }\n\n    if (msg.type === 'FETCH_COLLECTIONS') {\n      const snapshot = await snapshotCollectionsForUi();\n      const last = await figma.clientStorage.getAsync('lastSelection').catch(function () { return null; });\n      const exportAllPrefVal = await figma.clientStorage.getAsync('exportAllPref').catch(function () { return false; });\n      const lastOrNull = last && typeof last.collection === 'string' && typeof last.mode === 'string'\n        ? last\n        : null;\n\n      send({ type: 'INFO', payload: { message: 'Fetched ' + String(snapshot.collections.length) + ' collections' } });\n      send({ type: 'COLLECTIONS_DATA', payload: { collections: snapshot.collections, last: lastOrNull, exportAllPref: !!exportAllPrefVal } });\n      send({ type: 'RAW_COLLECTIONS_TEXT', payload: { text: snapshot.rawText } });\n      return;\n    }\n\n    if (msg.type === 'IMPORT_DTCG') {\n      await importDtcg(msg.payload.json);\n      send({ type: 'INFO', payload: { message: 'Import completed.' } });\n      const snap2 = await snapshotCollectionsForUi();\n      const last = await figma.clientStorage.getAsync('lastSelection').catch(function () { return null; });\n      const exportAllPrefVal = await figma.clientStorage.getAsync('exportAllPref').catch(function () { return false; });\n      const lastOrNull = last && typeof last.collection === 'string' && typeof last.mode === 'string'\n        ? last\n        : null;\n\n      send({ type: 'COLLECTIONS_DATA', payload: { collections: snap2.collections, last: lastOrNull, exportAllPref: !!exportAllPrefVal } });\n      send({ type: 'RAW_COLLECTIONS_TEXT', payload: { text: snap2.rawText } });\n      return;\n    }\n\n    if (msg.type === 'EXPORT_DTCG') {\n      const exportAll = !!msg.payload.exportAll;\n      if (exportAll) {\n        const all = await exportDtcg({ format: 'single' });\n        send({ type: 'EXPORT_RESULT', payload: { files: all.files } });\n        return;\n      }\n\n      const collectionName = msg.payload.collection ? msg.payload.collection : '';\n      const modeName = msg.payload.mode ? msg.payload.mode : '';\n      const per = await exportDtcg({ format: 'perMode' });\n\n      const key = safeKeyFromCollectionAndMode(collectionName, modeName);\n      const picked: Array<{ name: string; json: unknown }> = [];\n      let i2 = 0; for (i2 = 0; i2 < per.files.length; i2++) if (per.files[i2].name.indexOf(key) !== -1) picked.push(per.files[i2]);\n      send({ type: 'EXPORT_RESULT', payload: { files: picked.length > 0 ? picked : per.files } });\n      return;\n    }\n\n    if (msg.type === 'SAVE_LAST') {\n      // Persist selection\n      if (msg.payload && typeof msg.payload.collection === 'string' && typeof msg.payload.mode === 'string') {\n        await figma.clientStorage.setAsync('lastSelection', { collection: msg.payload.collection, mode: msg.payload.mode });\n      }\n      return;\n    }\n\n    if (msg.type === 'SAVE_PREFS') {\n      await figma.clientStorage.setAsync('exportAllPref', !!msg.payload.exportAll);\n      return;\n    }\n\n    if (msg.type === 'UI_RESIZE') {\n      var w = Math.max(720, Math.min(1600, Math.floor(msg.payload.width)));\n      var h = Math.max(420, Math.min(1200, Math.floor(msg.payload.height)));\n      figma.ui.resize(w, h);\n      try { await figma.clientStorage.setAsync('uiSize', { width: w, height: h }); } catch (_err) { }\n      // send({ type: 'INFO', payload: { message: 'Resized UI to ' + w + '\u00D7' + h } }); // <\u2014 add this single line\n      return;\n    }\n\n    if (msg.type === 'PREVIEW_REQUEST') {\n      const collectionName = msg.payload.collection ? String(msg.payload.collection) : '';\n      const modeName = msg.payload.mode ? String(msg.payload.mode) : '';\n\n      // Build all per-mode files with the current graph\n      const per = await exportDtcg({ format: 'perMode' });\n\n      // Reuse your key logic to pick the right one\n      const key = safeKeyFromCollectionAndMode(collectionName, modeName);\n      let picked = per.files.find(f => f.name.indexOf(key) !== -1);\n      if (!picked) picked = per.files[0]; // graceful fallback\n      if (!picked) picked = { name: 'tokens-empty.json', json: {} };\n\n      send({ type: 'W3C_PREVIEW', payload: { name: picked.name, json: picked.json } });\n      return;\n    }\n\n\n\n  } catch (e) {\n    var message = 'Unknown error';\n    if (e && (e as Error).message) message = (e as Error).message;\n    figma.notify('Plugin error: ' + message, { timeout: 4000 });\n    send({ type: 'ERROR', payload: { message: message } });\n    // eslint-disable-next-line no-console\n    console.error(e);\n  }\n};\n"],
  "mappings": "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",
  "names": ["clamp01", "logInfo", "logWarn", "logWarn", "keysOf"]
}
